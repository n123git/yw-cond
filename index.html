<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Yo-kai Watch Cond Parser</title>
  <style>
    .warning { color: #c77f00; font-weight: bold; }
    .error { color: #c00; font-weight: bold; }
    .muted { opacity: 0.6; }
    /* more lightly weathered cut copper - I mean light CSS lol */

    #pseudo {
      white-space: pre;
      font-family: monospace;
    }
    #pseudo span[data-off] {
      display: inline;
      padding: 2px 4px;
    }
    #pseudo span[data-off].highlight {
      background-color: yellow;
      transition: background 1s ease;
    }

    .highlight {
      background: yellow;
      transition: background 1s ease;
    }

    /* making a feature I added show that it exists more obviously */

    .tree-line {
      cursor: pointer;
      transition: background 0.2s ease;
      padding: 1px 3px;
      border-radius: 3px;
    }

    .tree-line:hover {
      background-color: rgba(100, 100, 255, 0.1);
      color: #333;
    }

    /* even more CSS magic! :0 */
    .tree-line::before {
      content: '→ ';
      opacity: 0.3;
      transition: opacity 0.2s ease;
    }

    .tree-line:hover::before {
      opacity: 0.7; 
    }

  </style>
</head>
<body style="font-family:monospace;padding:10px;">
  <h2>Yo-kai Watch Cond Parser</h2>

  <label for="input" class="muted">Paste hex (spaced or continuous), or Base64</label>
  <textarea id="input" placeholder="Paste hex (e.g. '00 0A 01') or base64 here" style="width:100%;min-height:140px"></textarea>

  <div id="controls">
    <button id="parseBtn" title="Parse input (Ctrl+Enter)">Parse</button>
    <button id="parseB64Btn" title="Try to decode input as Base64 then parse">Parse Base64</button>
    <button id="sampleBtn">Load Sample</button>
    <button id="clearBtn">Clear</button>
    <button id="copyPseudoBtn">Copy Pseudocode</button>
    <button id="downloadBtn">Download Psuedocode (cond.txt)</button>
    <button id="generateBtn">Generate Known Cond(s)</button>



    <label><input type="checkbox" id="expectTerm78"> Only accept 0x78 terminator</label>
    <label><input type="checkbox" id="strictMode"> Strict mode (stop on first warning)</label>
  </div>

  <pre id="log" aria-live="polite"></pre>
  <div id="tree" role="region" aria-label="Parsed tree"></div>

  <h3>Pseudocode Output</h3>
  <pre id="pseudo"></pre>

  <!-- Modal (hidden by default) -->
<dialog id="generateModal">
  <h3>Generate Known Cond(s)</h3>
  <label>
    Condition:
    <select id="condSelect">
      <option value="mainStory">Yo-kai Watch 2 – Main Story Completed</option>
      <option value="rankXX">Yo-kai Watch 2 – Rank XX or higher</option>
      <option value="hasItem">Yo-kai Watch 2 – Has Item</option>
      <option value="tunnelXX">Yo-kai Watch 2 – Beaten Infinite Tunnel XX Times</option>
    </select>
  </label>
  <div id="extraInputs"></div>
  <div style="margin-top: 10px;">
    <button id="generateCondBtn">Generate</button>
    <button id="closeModalBtn">Cancel</button>
  </div>
</dialog>
  <script>
    /* lots of general codebase updates - and comments :0 */
    const el = id => document.getElementById(id);
    let ver = 1.222;

    const hexChars = /^[0-9a-fA-F]+$/;

    function toHex(b){ return b.toString(16).padStart(2,'0').toUpperCase(); }
    function toHexWord(bytes){ if(!bytes) return '0x'; return '0x' + Array.from(bytes).map(toHex).join(''); }

    function log(msg, kind){
      const container = el('log');
      const prefix = kind === 'error' ? 'Error: ' : kind === 'warn' ? 'Warning: ' : '';
      const line = prefix + msg;
      container.textContent += line + '\n';
      container.scrollTop = container.scrollHeight;
    }
    function clearLog(){ el('log').textContent = ''; }
    normalizeInputRaw = text => (text||'').trim(); 

    function tryDecodeBase64(s){
      // support standard and URL-safe base64;
      try {
        // quick check - base64 has letters, numbers, +/-, and = for padding
        return atob(s);
      } catch(e){
        // attempt URL-safe replacement and padding
        try {
          const urlFixed = s.replace(/-/g, '+').replace(/_/g, '/');
          const pad = urlFixed.length % 4 === 0 ? urlFixed : urlFixed + '='.repeat(4 - (urlFixed.length % 4));
          return atob(pad);
        } catch(e2){
          throw new Error('Not valid base64');
        }
      }
    }

    function parseInputToBytes(text){
      text = normalizeInputRaw(text);
      if(!text) return new Uint8Array([]);

      // Check if it looks like hex first
      const hexCandidate = text.replace(/0x/gi,'')
                              .replace(/[:,\-<>]/g,'')
                              .replace(/\s+/g,'')
                              .trim();

      const isAllHex = /^[0-9a-fA-F]*$/.test(hexCandidate);
      if (isAllHex && hexCandidate.length % 2 === 0 && hexCandidate.length > 0) {
        // decode as continuous hex
        const arr = new Uint8Array(hexCandidate.length / 2);
        for(let i=0;i<arr.length;i++){
          const h = hexCandidate.substr(i*2,2);
          arr[i] = parseInt(h,16);
        }
        return arr;
      }

      // Otherwise, if it's probably b64, try to decode it lol
      const looksLikeBase64 = /^[A-Za-z0-9+\/=_\-]+$/.test(text) && !/[ \t\r\n:,\-<>]/.test(text);
      if (looksLikeBase64) {
        try {
          const decoded = tryDecodeBase64(text);
          const arr = new Uint8Array(decoded.length);
          for(let i=0;i<decoded.length;i++) arr[i] = decoded.charCodeAt(i);
          return arr;
        } catch(e){
          log('Base64 detection failed: ' + e.message, 'warn');
        }
      }

      const cleaned = text.replace(/0x/gi,'') 
                          .replace(/[:,\-<>]/g,' ') 
                          .replace(/\s+/g,' ') 
                          .trim();

      const parts = cleaned.split(' ');
      const bytes = new Uint8Array(parts.length);
      for(let i=0;i<parts.length;i++){
        const p = parts[i].trim();
        if(!hexChars.test(p)) throw new Error('Invalid hex token: "'+p+'"');
        if(p.length !== 2) throw new Error('Expected 2-hex-digit tokens when separated by spaces, got "'+p+'"');
        bytes[i]=parseInt(p,16);
      }
      return bytes;
    }


    class Reader{
      constructor(u8){ this.bytes = u8; this.pos = 0; }
      len(){ return this.bytes.length; }
      rem(){ return this.bytes.length - this.pos; }
      eof(){ return this.pos >= this.bytes.length; }
      read(n){ if(this.pos + n > this.bytes.length) throw new Error('Unexpected EOF at offset '+this.pos); const slice = this.bytes.slice(this.pos, this.pos+n); this.pos += n; return slice; }
      readByte(){ return this.read(1)[0]; }
      peekByte(){ return this.pos >= this.bytes.length ? null : this.bytes[this.pos]; }
      offset(){ return this.pos; }
      skip(n){ this.pos += n; }
    }

function parseCondStrict(bytes, opts = { force78: false, strict: false }) {
  const r = new Reader(bytes);
  const result = {
    fields: [],
    warnings: [],
    errors: [],
    skipped: [],
    stopped: false
  };

  // Helper to add a field
  function addField(name, off, val, label) {
    result.fields.push({ name, off, val, label });
  }

  // Helper to handle warnings/errors
  function warn(msg) {
    result.warnings.push({ msg });
    if (opts.strict) stop(`Strict mode: ${msg}`);
  }
  function error(msg) {
    result.errors.push({ msg });
    stop(msg);
  }
  function stop(reason) {
    result.stopped = true;
    throw new Error(reason);
  }

  // Known condcodes
  const knowncondCodes = {
    '0F05': 'Basic Cond (Basic constant checking)',
    '1805': 'Basic Extension Cond (Used for flags)',
    'F03B': 'Chain? condCode (Rarely used)',
    '300B': 'CompareFirst?? (Weird Order)',
    '6017': 'Also Chain??',
  };

  // --- Small Parsing Functions ---

  function parseHeader() {
    const off = r.offset();
    const val = r.read(4);
    addField("HEADER", off, val);
  }

  function parsecondCode() {
    if (r.rem() < 2) return false;
    const off = r.offset();
    const val = r.read(2);
    const hex = Array.from(val).map(toHex).join('');
    const label = knowncondCodes[hex];
    addField("CONDCODE", off, val, label);

    if (!label) warn(`Unknown condCode ${hex} at ${off}`);
    if (hex === "300B") parsecondCodeComparison();
    return true;
  }

  function parsecondCodeComparison() {
    if (r.peekByte() === 0x32) addField("SUB_DELIM_32", r.offset(), new Uint8Array([r.readByte()]));
    if (r.rem() >= 4) {
      const off = r.offset();
      addField("COMPARISON_VALUE", off, r.read(4));
    } else {
      warn("Truncated comparison value after condCode 300B");
    }
  }

  function parseSection() {
    const startOff = r.offset();
    const s = r.readByte();
    addField("SECTION_START", startOff, new Uint8Array([s]));
    if (s !== 0x35) warn(`Expected SECTION_START 0x35 at ${startOff}, got ${toHex(s)}`);

    if (r.rem() < 4) return error("Not enough bytes for RESOURCE_ID");
    addField("RESOURCE_ID_A", r.offset(), r.read(4));

    if (r.rem() >= 3) {
      const ctypeAOff = r.offset();
      const ctypeA = r.read(3);
      addField("CTYPE_A", ctypeAOff, ctypeA);

      const cHex = Array.from(ctypeA).map(toHex).join(" ");
      const knownCTypes = ["00 0A 01", "00 01 00"];
      if (!knownCTypes.includes(cHex) && !(ctypeA[0] === 0x00 && ctypeA[2] === 0x01))
        warn("Unknown CTYPE_A " + cHex + ", treating as extended");
    }

    if (r.peekByte() === 0x28) {
      addField("EXTENSION_DELIMITER", r.offset(), new Uint8Array([r.readByte()]));
      if (r.rem() >= 3) addField("CTYPE_B", r.offset(), r.read(3));
      else warn("Truncated CTYPE_B");

      if (r.peekByte() === 0x34) {
        addField("NEST_DELIMITER_34", r.offset(), new Uint8Array([r.readByte()]));
        if (r.rem() >= 4) addField("RESOURCE_ID_B", r.offset(), r.read(4));
        else warn("Truncated RESOURCE_ID_B");
      }
    }

    if (r.peekByte() === 0x32) addField("SECTION_END", r.offset(), new Uint8Array([r.readByte()]));
    else warn("Missing SECTION_END before comparison");

    // parse comparisons / terminators
    while (r.rem() > 0) {
      const p = r.peekByte();

      if (p === 0x8F) {
        addField("EOCI", r.offset(), new Uint8Array([r.readByte()]));
        break;
      }
      if (p === 0x35) break;

      if (p === 0x32) {
        addField("SUB_DELIM_32", r.offset(), new Uint8Array([r.readByte()]));
        if (r.rem() >= 4) addField("COMPARISON_VALUE", r.offset(), r.read(4));
        else warn("Truncated comparison");
        continue;
      }

      const terminators = [0x71, 0x78, 0x6F, 0x79];
      if (terminators.includes(p)) {
        const t = r.readByte();
        addField("TERMINATOR", r.offset() - 1, new Uint8Array([t]));
        const allowed = opts.force78 ? [0x78] : terminators;
        if (!allowed.includes(t)) warn("Unknown terminator " + toHex(t));
        continue;
      }

      if (r.rem() >= 4) {
        addField("COMPARISON_VALUE", r.offset(), r.read(4));
        continue;
      }

      warn("Unexpected byte " + toHex(p) + " at " + r.offset());
      result.skipped.push(r.offset());
      r.readByte(); // consume
      break;
    }
  }

  // --- Main Parse Loop ---
  try {
    while (r.rem() > 0 && !result.stopped) {
      if (r.rem() >= 4 && r.bytes.slice(r.pos, r.pos + 4).every(b => b === 0)) {
        parseHeader();
        continue;
      }

      if (r.peekByte() === 0x8F) {
        warn(`EOCI encountered without preceding terminator at ${r.offset()}`);
        addField("EOCI", r.offset(), new Uint8Array([r.readByte()]));
        continue;
      }

      if (r.peekByte() === 0x35) {
        parseSection();
        continue;
      }

      if (!parsecondCode()) break;

      if (r.peekByte() === 0x35) {
        parseSection();
        continue;
      }

      // Look ahead for a section start; if found, skip to it
      const lookahead = r.bytes.slice(r.pos, r.pos + 64);
      const idx = Array.from(lookahead).indexOf(0x35);
      if (idx >= 0) {
        warn(`condCode not immediately followed by section start; skipping ${idx} bytes to @${r.offset() + idx}`);
        result.skipped.push(r.offset());
        r.skip(idx);
        continue;
      } else {
        warn("condCode not followed by section start; stopping parse");
        break;
      }
    }
  } catch (e) {
    if (!result.stopped) error(e.message);
  }

  return result;
}


    // Renderers
    function renderTree(parsed){
      const div=document.createElement('div');
      const first=document.createElement('div');
      first.textContent="// parsed with yw-cond v"+ver;
      div.appendChild(first);
      parsed.fields.forEach(f=>{
      const hex = Array.from(f.val || []).map(toHex).join(' ');
      const lbl = f.label ? ' ['+f.label+']' : '';
      const line=document.createElement('div');
      line.textContent = `${f.name + lbl} @${f.off}: ${hex}`;
      line.dataset.off = f.off; // <-- store offset for linking
      line.className = "tree-line";
      line.style.cursor = "pointer";
      line.addEventListener("click", () => {
        const target = document.querySelector(`#pseudo span[data-off="${f.off}"]`);
        if (target) {
            target.scrollIntoView({ behavior: "smooth", block: "center" });
            target.classList.add("highlight");
            setTimeout(() => target.classList.remove("highlight"), 1200);
        }
      });
      div.appendChild(line);
    });
    parsed.warnings.forEach(w=>{
      const ln=document.createElement('div');
      ln.className='warning';
      ln.textContent='Warning: '+w.msg;
      div.appendChild(ln);
    });
    parsed.errors.forEach(e=>{
      const ln=document.createElement('div');
      ln.className='error';
      ln.textContent='Error: '+e.msg;
      div.appendChild(ln);
    });
    if(parsed.skipped.length>0){
      const ln=document.createElement('div');
      ln.className='muted';
      ln.textContent='Skipped offsets: '+parsed.skipped.join(', ');
      div.appendChild(ln);
    }
    return div;
  }


function renderPseudo(parsed){ // copy pasted from my dev copy :3
  let out="// parsed using yw-cond v" + ver + "\n";
  const stack=[];
  let lineCount=0;
  function indent(){ return '  '.repeat(stack.length); }
  function maybeComment(){ if(++lineCount % 10 === 0) out += indent() + '// @' + (parsed.fields[lineCount-1]?.off||'?') + '\n'; }
  parsed.fields.forEach(f=>{
    const startTag = `<span data-off="${f.off}">`;
    const endTag = `</span>`;
    switch(f.name){
      case 'HEADER': out+=startTag+'#header '+toHexWord(f.val)+endTag+'\n'; break;
      case 'CONDCODE': out+=startTag+'#condCode '+toHexWord(f.val)+(f.label?' // '+f.label:'')+endTag+'\n'; break;
      case 'SECTION_START': out+=startTag+'start {'+endTag+'\n'; stack.push('start'); break;
      case 'RESOURCE_ID_A': out+=startTag+indent()+'RESOURCE_ID_A = '+toHexWord(f.val)+endTag+'\n'; break;
      case 'CTYPE_A': out+=startTag+indent()+'CTYPE_A = '+toHexWord(f.val)+'\n'+indent()+'extendConditional(RESOURCE_ID_A, CTYPE_A)'+endTag+'\n'; break;
      case 'EXTENSION_DELIMITER': if(stack[stack.length-1]==='start'){ stack.pop(); out+='} '; } out+=startTag+'extend {'+endTag+'\n'; stack.push('extend'); break;
      case 'CTYPE_B': out+=startTag+indent()+'CTYPE_B = '+toHexWord(f.val)+endTag+'\n'; break;
      case 'NEST_DELIMITER_34': out+=startTag+indent()+'nest {'+endTag+'\n'; stack.push('nest'); break;
      case 'RESOURCE_ID_B': out+=startTag+indent()+'RESOURCE_ID_B = '+toHexWord(f.val)+'\n'+indent()+'extendConditional(RESOURCE_ID_B, CTYPE_B)'+endTag+'\n'; if(stack[stack.length-1]==='nest'){ stack.pop(); out+=indent()+'}\n';} break;
      case 'SECTION_END': if(stack.length>0) stack.pop(); out+=startTag+'}'+endTag+'\n'; break;
      case 'COMPARISON_VALUE': out+=startTag+indent()+'COMPARISON_VALUE = '+toHexWord(f.val)+'\n'+indent()+'compare(COMPARISON_VALUE)'+endTag+'\n'; break;
      case 'SUB_DELIM_32': out+=startTag+indent()+'// sub-delimiter 0x32'+endTag+'\n'; break;
      case 'TERMINATOR': out+=startTag+indent()+'TERMINATOR = '+toHexWord(f.val)+';\n'+indent()+'terminate(TERMINATOR)'+endTag+'\n'; break;
      case 'EOCI': out+=startTag+indent()+'end-chain; // EOCI (End of Chain Instance)'+endTag+'\n'; break;
      default: out+=startTag+indent()+'// '+f.name+' '+toHexWord(f.val)+endTag+'\n';
    }
    maybeComment();
  });
  return out;
}


    // UI actions
    function doParseFromInput(text, opts){ // why did I name it this way..........
      clearLog();
      el('tree').innerHTML = '';
      el('pseudo').textContent = '';
      try {
        const bytes = parseInputToBytes(text);
        log('Bytes: ' + bytes.length);
        const parsed = parseCondStrict(bytes, { force78: el('expectTerm78').checked, strict: el('strictMode').checked });
        el('tree').appendChild(renderTree(parsed));
        el('pseudo').innerHTML = renderPseudo(parsed); // gotta love XSS risks js aside from being safe input this is all client side anyway - unless devtools console counts as a major security risk lmao :P
      } catch(e){
        log('Fatal: ' + e.message, 'error');
      }
    }

    el('parseBtn').addEventListener('click', ()=> doParseFromInput(el('input').value));

    el('parseB64Btn').addEventListener('click', ()=>{
      clearLog();
      try {
        const raw = el('input').value.trim();
        const decoded = tryDecodeBase64(raw);
        const hex = Array.from(decoded).map(c=>c.charCodeAt ? c.charCodeAt(0) : c).map(n=>n.toString(16).padStart(2,'0')).join(' ');
        el('input').value = hex;
        doParseFromInput(hex);
      } catch(e){
        log('Base64 decode failed: ' + e.message, 'error');
      }
    });

    el('sampleBtn').addEventListener('click', ()=>{
      el('input').value = '00 00 00 00 f0 3b 35 77 b4 63 e5 00 0a 01 28 00 06 02 32 00 00 00 01 32 00 00 00 01 78 35 77 b4 63 e5 00 0a 01 28 00 06 02 32 00 00 00 02 32 00 00 00 01 78 8f 35 77 b4 63 e5 00 0a 01 28 00 06 02 32 00 00 00 03 32 00 00 00 01 78 8f';
      el('parseBtn').click();
    });

    el('clearBtn').addEventListener('click', ()=>{
      el('input').value=''; clearLog(); el('tree').innerHTML=''; el('pseudo').textContent='';
    });

    el('copyPseudoBtn').addEventListener('click', ()=>{
      const txt = el('pseudo').textContent;
      if(!txt) { log('Nothing to copy', 'warn'); return; }
      navigator.clipboard?.writeText(txt).then(()=> log('Pseudocode copied to clipboard'), ()=> log('Copy failed', 'warn'));
    });

    el('downloadBtn').addEventListener('click', ()=>{
      const pseudo = el('pseudo').textContent || '';
      const blob = new Blob([pseudo], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'cond.txt';
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    });

    // keyboard shortcut: Ctrl+Enter to parse
    el('input').addEventListener('keydown', (ev)=>{
      if((ev.ctrlKey || ev.metaKey) && ev.key === 'Enter'){
        ev.preventDefault();
        el('parseBtn').click();
      }
    });

    // small check catch uncaught errors so they appear in log
    window.addEventListener('error', (ev)=> {
      log('Uncaught error: ' + (ev.error?.message || ev.message || ev), 'error');
    });
    let x = document.createElement("footer");
    document.body.appendChild(x) // archiving my stupidity again - I almost released this with: document.getElementsByTagName("body")[0].appendChild(x)
    x.outerHTML = `<footer style="font-size: large;">yw-cond. Version: <span id="vdisplay">${ver}</span></footer>`;
   const generateModal = el('generateModal');
  const condSelect = el('condSelect');
  const extraInputs = el('extraInputs');

  const condTemplates = {
    mainStory: { 
      type: "b64",
      value: "AAAAAA8FNRCxQJYAAQAyAAAAAXg="
    },
    rankXX: {
      type: "hex",
      template: "00 00 00 00 0f 05 35 dd 77 26 95 00 01 00 32 00 00 00 {RANK} 71",
      params: [{ name: "RANK", label: "Rank (00–FF)", placeholder: "e.g. 06" }]
    },
    hasItem: {
      type: "hex",
      template: "00 00 00 00 18 05 35 8d 76 66 d8 00 0a 01 28 00 06 02 34 {ITEM} 32 00 00 00 01 78",
      params: [{ name: "ITEM", label: "Item ID (4-byte little endian)", placeholder: "e.g. 1678239 or 0x638297A etc" }]
    },
    tunnelXX: {
      type: "hex",
      template: "00 00 00 00 18 05 35 9e 99 84 8c 00 0a 01 28 00 06 02 34 89 20 ff e7 32 00 00 00 {COUNT} 78",
      params: [{ name: "COUNT", label: "Times Beaten (00–FF)", placeholder: "e.g. 05" }]
    },
    npcFlagYW3: {
  type: "hex",
  template: "00 00 00 00 18 05 35 2a 3d 45 43 00 0a 01 28 00 06 02 34 {FLAG} 32 00 00 00 01 78",
  params: [
    { name: "FLAG", label: "Flag ID (4-byte big endian)", placeholder: "e.g. 12345678 or 0x00ABCDEF" }
  ]
};
  };

  function updateExtraInputs() {
    extraInputs.innerHTML = "";
    const selected = condTemplates[condSelect.value];
    if (selected?.params) {
      selected.params.forEach(p => {
        const input = document.createElement("input");
        input.type = "text";
        input.placeholder = p.placeholder;
        input.id = "param_" + p.name;
        input.style = "margin-left:5px;";
        const label = document.createElement("label");
        label.textContent = p.label + ": ";
        label.appendChild(input);
        extraInputs.appendChild(label);
        extraInputs.appendChild(document.createElement("br"));
      });
    }
  }

  condSelect.addEventListener("change", updateExtraInputs);
  updateExtraInputs();

  el('generateBtn').addEventListener('click', () => generateModal.showModal());
  el('closeModalBtn').addEventListener('click', () => generateModal.close());

  // --- Helper Functions ---
  function intToHexNoPad(n) {
    const hex = n.toString(16).toUpperCase();
    return hex.length % 2 ? '0' + hex : hex; // ensure even number of digits
  }
function parseBigEndianId(input) {
  let num;
  if (input.startsWith("0x") || input.startsWith("0X")) {
    num = parseInt(input, 16);
  } else {
    num = parseInt(input, 10);
  }
  if (isNaN(num)) throw new Error("Invalid flag ID");
  num = (num >>> 0); // ensure unsigned 32-bit
  const arr = new Uint8Array(4);
  const dv = new DataView(arr.buffer);
  dv.setUint32(0, num, false); // false = big-endian
  return Array.from(arr).map(b => b.toString(16).padStart(2, "0")).join(" ");
}

  function parseItemId(input) {
    let num;
    if (input.startsWith("0x") || input.startsWith("0X")) {
      num = parseInt(input, 16);
    } else {
      num = parseInt(input, 10);
    }
    if (isNaN(num)) throw new Error("Invalid item ID");
    num = (num >> 0); // force to 32-bit signed
    const arr = new Uint8Array(4);
    const dv = new DataView(arr.buffer);
    dv.setInt32(0, num, true); // little endian
    return Array.from(arr).map(b => b.toString(16).padStart(2, "0")).join(" ");
  }

  el('generateCondBtn').addEventListener('click', () => {
    const selected = condTemplates[condSelect.value];
    let finalText = selected.value || selected.template;

    try {
      if (selected.params) {
selected.params.forEach(p => {
  let val = el("param_" + p.name).value.trim();
  if (p.name === "RANK" || p.name === "COUNT") {
    const intVal = parseInt(val, 10);
    if (isNaN(intVal) || intVal < 0 || intVal > 255) throw new Error("Invalid " + p.label);
    val = intToHexNoPad(intVal); // unpadded hex
  } else if (p.name === "ITEM") {
    val = parseItemId(val); // little-endian
  } else if (p.name === "FLAG") {
    val = parseBigEndianId(val); // big-endian
  }
  finalText = finalText.replace("{" + p.name + "}", val);
});

      }
      el('input').value = finalText;
      generateModal.close();
      doParseFromInput(finalText);
    } catch (err) {
      log("Generation failed: " + err.message, "error");
    }
  });
  </script>
</body>
</html>
