<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Yo-kai Watch Cond Parser</title>
  <style>
    .warning { color: #c77f00; font-weight: bold; }
    .error { color: #c00; font-weight: bold; }
    .muted { opacity: 0.6; }
    /* more lightly weathered cut copper - I mean light CSS lol */

    #pseudo {
      white-space: pre;
      font-family: monospace;
    }
    #pseudo span[data-off] {
      display: inline;
      padding: 2px 4px;
    }
    #pseudo span[data-off].highlight {
      background-color: yellow;
      transition: background 1s ease;
    }

    .highlight {
      background: yellow;
      transition: background 1s ease;
    }

    /* making a feature I added show that it exists more obviously */

    .tree-line {
      cursor: pointer;
      transition: background 0.2s ease;
      padding: 1px 3px;
      border-radius: 3px;
    }

    .tree-line:hover {
      background-color: rgba(100, 100, 255, 0.1);
      color: #333;
    }

    /* even more CSS magic! :0 */
    .tree-line::before {
      content: 'â†’ ';
      opacity: 0.3;
      transition: opacity 0.2s ease;
    }

    .tree-line:hover::before {
      opacity: 0.7; 
    }

  </style>
</head>
<body style="font-family:monospace;padding:10px;">
  <h2>Yo-kai Watch Cond Parser</h2>

  <label for="input" class="muted">Paste hex (spaced or continuous), or Base64</label>
  <textarea id="input" placeholder="Paste hex (e.g. '00 0A 01') or base64 here" style="width:100%;min-height:140px"></textarea>

  <div id="controls">
    <button id="parseBtn" title="Parse input (Ctrl+Enter)">Parse</button>
    <button id="parseB64Btn" title="Try to decode input as Base64 then parse">Parse Base64</button>
    <button id="sampleBtn">Load Sample</button>
    <button id="clearBtn">Clear</button>
    <button id="copyPseudoBtn">Copy Pseudocode</button>
    <button id="downloadBtn">Download Psuedocode (cond.txt)</button>

    <label><input type="checkbox" id="expectTerm78"> Only accept 0x78 terminator</label>
    <label><input type="checkbox" id="strictMode"> Strict mode (stop on first warning)</label>
  </div>

  <pre id="log" aria-live="polite"></pre>
  <div id="tree" role="region" aria-label="Parsed tree"></div>

  <h3>Pseudocode Output</h3>
  <pre id="pseudo"></pre>

  <script>
    /* lots of general codebase updates - and comments :0 */
    const el = id => document.getElementById(id);
    let ver = 1.21551;

    const hexChars = /^[0-9a-fA-F]+$/;

    function toHex(b){ return b.toString(16).padStart(2,'0').toUpperCase(); }
    function toHexWord(bytes){ if(!bytes) return '0x'; return '0x' + Array.from(bytes).map(toHex).join(''); }

    function log(msg, kind){
      const container = el('log');
      const prefix = kind === 'error' ? 'Error: ' : kind === 'warn' ? 'Warning: ' : '';
      const line = prefix + msg;
      container.textContent += line + '\n';
      container.scrollTop = container.scrollHeight;
    }
    function clearLog(){ el('log').textContent = ''; }
    normalizeInputRaw = text => (text||'').trim(); 

    function tryDecodeBase64(s){
      // support standard and URL-safe base64;
      try {
        // quick check - base64 has letters, numbers, +/-, and = for padding
        return atob(s);
      } catch(e){
        // attempt URL-safe replacement and padding
        try {
          const urlFixed = s.replace(/-/g, '+').replace(/_/g, '/');
          const pad = urlFixed.length % 4 === 0 ? urlFixed : urlFixed + '='.repeat(4 - (urlFixed.length % 4));
          return atob(pad);
        } catch(e2){
          throw new Error('Not valid base64');
        }
      }
    }

    function parseInputToBytes(text){
      text = normalizeInputRaw(text);
      if(!text) return new Uint8Array([]);

      // Check if it looks like hex first
      const hexCandidate = text.replace(/0x/gi,'')
                              .replace(/[:,\-<>]/g,'')
                              .replace(/\s+/g,'')
                              .trim();

      const isAllHex = /^[0-9a-fA-F]*$/.test(hexCandidate);
      if (isAllHex && hexCandidate.length % 2 === 0 && hexCandidate.length > 0) {
        // decode as continuous hex
        const arr = new Uint8Array(hexCandidate.length / 2);
        for(let i=0;i<arr.length;i++){
          const h = hexCandidate.substr(i*2,2);
          arr[i] = parseInt(h,16);
        }
        return arr;
      }

      // Otherwise, if it's probably b64, try to decode it lol
      const looksLikeBase64 = /^[A-Za-z0-9+\/=_\-]+$/.test(text) && !/[ \t\r\n:,\-<>]/.test(text);
      if (looksLikeBase64) {
        try {
          const decoded = tryDecodeBase64(text);
          const arr = new Uint8Array(decoded.length);
          for(let i=0;i<decoded.length;i++) arr[i] = decoded.charCodeAt(i);
          return arr;
        } catch(e){
          log('Base64 detection failed: ' + e.message, 'warn');
        }
      }

      const cleaned = text.replace(/0x/gi,'') 
                          .replace(/[:,\-<>]/g,' ') 
                          .replace(/\s+/g,' ') 
                          .trim();

      const parts = cleaned.split(' ');
      const bytes = new Uint8Array(parts.length);
      for(let i=0;i<parts.length;i++){
        const p = parts[i].trim();
        if(!hexChars.test(p)) throw new Error('Invalid hex token: "'+p+'"');
        if(p.length !== 2) throw new Error('Expected 2-hex-digit tokens when separated by spaces, got "'+p+'"');
        bytes[i]=parseInt(p,16);
      }
      return bytes;
    }


    class Reader{
      constructor(u8){ this.bytes = u8; this.pos = 0; }
      len(){ return this.bytes.length; }
      rem(){ return this.bytes.length - this.pos; }
      eof(){ return this.pos >= this.bytes.length; }
      read(n){ if(this.pos + n > this.bytes.length) throw new Error('Unexpected EOF at offset '+this.pos); const slice = this.bytes.slice(this.pos, this.pos+n); this.pos += n; return slice; }
      readByte(){ return this.read(1)[0]; }
      peekByte(){ return this.pos >= this.bytes.length ? null : this.bytes[this.pos]; }
      offset(){ return this.pos; }
      skip(n){ this.pos += n; }
    }

    function parseCondStrict(bytes, opts = { force78: false, strict: false }) {
      const r = new Reader(bytes);
      const result = { fields: [], warnings: [], errors: [], stopped: false, skipped: [] };
      const knownOpcodes = {
        '0F05': 'Basic Cond (Basic constant checking)',
        '1805': 'Basic Extension Cond (Used for flags)',
        'F03B': 'Chain? Opcode (Rarely used)',
        '300B': 'CompareFirst?? (Weird Order)',
        "6017": "Also Chain??",
      };

      function f(name, len) {
        const off = r.offset();
        const val = r.read(len);
        result.fields.push({ name, off, val });
        return val;
      }
      function fb(name) {
        const off = r.offset();
        const v = r.readByte();
        result.fields.push({ name, off, val: new Uint8Array([v]) });
        return v;
      }
      function warn(msg) {
        result.warnings.push({ msg });
        if (opts.strict) {
          result.stopped = true;
          alert('Strict stop: ' + msg)
          throw new Error('Strict stop: ' + msg);
        }
      }
      function error(msg) {
        result.errors.push({ msg });
        if (opts.strict) {
          result.stopped = true;
          alert('Strict stop: ' + msg)
          throw new Error('Strict stop: ' + msg);
        }
      }

      function parseSection() {
        const startOff = r.offset();
        const s = fb('SECTION_START');
        if (s !== 0x35) warn('Expected SECTION_START 0x35 at ' + startOff + ', got ' + toHex(s));

        if (r.rem() < 4) return error('Not enough bytes for RESOURCE_ID');
        const rid = f('RESOURCE_ID_A', 4);

        if (r.rem() >= 3) {
          const ctypeA = f('CTYPE_A', 3);
          const cHex = Array.from(ctypeA).map(toHex).join(' ');
          const knownCTypes = [
            '00 0A 01', // extended mode ctype (used in flag checks)
            '00 01 00', // basic ctype - used for basic value checks
          ];

          const isKnown = knownCTypes.includes(cHex) || (ctypeA[0] === 0x00 && ctypeA[2] === 0x01); // keep old check because I forgot why I had it >:(
          if (!isKnown) warn('Unknown CTYPE_A ' + cHex + ', treating as extended');
        }
        if (r.peekByte() === 0x28) {
          fb('EXTENSION_DELIMITER');
          if (r.rem() >= 3) f('CTYPE_B', 3);
          else warn('Truncated CTYPE_B');
          if (r.peekByte() === 0x34) {
            fb('NEST_DELIMITER_34');
            if (r.rem() >= 4) f('RESOURCE_ID_B', 4);
            else warn('Truncated RESOURCE_ID_B');
          }
        }

        if (r.peekByte() === 0x32) fb('SECTION_END');
        else warn('Missing SECTION_END before comparison');

        while (r.rem() > 0) {
          const p = r.peekByte();
          if (p === 0x8F) {
            fb('EOCI');
            break;
          }
          if (p === 0x35) break;
          if (p === 0x32) {
            fb('SUB_DELIM_32');
            if (r.rem() >= 4) f('COMPARISON_VALUE', 4);
            else warn('Truncated comparison');
            continue;
          }
          let terminators = [0x71, 0x78, 0x6F, 0x79]
          if (terminators.includes(Number(p))) { // dont know why im cooercing when previous versions used === anyway and that worked but....... whatever lmao :P
            const t = fb('TERMINATOR');
            const allowed = opts.force78 ? [0x78] : terminators;
            if (!allowed.includes(t)) warn('Unknown terminator ' + toHex(t));
            continue;
          }
          if (r.rem() >= 4) {
            f('COMPARISON_VALUE', 4);
            continue;
          }
          warn('Unexpected byte ' + toHex(p) + ' at ' + r.offset());
          result.skipped.push(r.offset());
          fb('TRAILING_BYTE');
          break;
        }
      }

      try {
        while (r.rem() > 0 && !result.stopped) {
          if (r.rem() >= 4 && r.bytes.slice(r.pos, r.pos + 4).every(b => b === 0)) f('HEADER', 4); // HEADER

          // EOCI without terminator
          if (r.peekByte() === 0x8F) {
            warn('EOCI encountered without preceding terminator at ' + r.offset());
            fb('EOCI');
            continue;
          }

          // SECTION START
          if (r.peekByte() === 0x35) {
            parseSection();
            continue;
          }

          // OPCODES
          if (r.rem() >= 2) {
            const op = f('OPCODE', 2);
            const opHex = Array.from(op).map(toHex).join('');
            if (!knownOpcodes[opHex]) warn('Unknown opcode ' + opHex + ' at ' + (r.offset() - 2));
            else result.fields[result.fields.length - 1].label = knownOpcodes[opHex];

            // SPECIAL CASE: 30 0B is weird; it has comparison value before section
            if (opHex === '300B') {
              if (r.peekByte() === 0x32) fb('SUB_DELIM_32');
              if (r.rem() >= 4) f('COMPARISON_VALUE', 4);
              else warn('Truncated comparison value after opcode 300B');
            }

            // If section follows, parse it
            if (r.peekByte() === 0x35) {
              parseSection();
              continue;
            }

            // Otherwise look ahead for next section
            const lookahead = r.bytes.slice(r.pos, r.pos + 64);
            const idx = Array.from(lookahead).indexOf(0x35);
            if (idx >= 0) {
              warn('Opcode not immediately followed by section start; skipping ' + idx + ' bytes to @' + (r.offset() + idx));
              result.skipped.push(r.offset());
              r.skip(idx);
              continue;
            } else {
              warn('Opcode not followed by section start; stopping parse');
              break;
            }
          }

          // Any remaining bytes -> trailing
          if (r.rem() > 0) {
            result.skipped.push(r.offset());
            f('TRAILING', r.rem());
            break;
          }
        }
      } catch (e) {
        if (!result.stopped) error(e.message);
      }

      return result;
    }

    // Renderers
    function renderTree(parsed){
      const div=document.createElement('div');
      const first=document.createElement('div');
      first.textContent="// parsed with yw-cond v"+ver;
      div.appendChild(first);
      parsed.fields.forEach(f=>{
      const hex = Array.from(f.val || []).map(toHex).join(' ');
      const lbl = f.label ? ' ['+f.label+']' : '';
      const line=document.createElement('div');
      line.textContent = `${f.name + lbl} @${f.off}: ${hex}`;
      line.dataset.off = f.off; // <-- store offset for linking
      line.className = "tree-line";
      line.style.cursor = "pointer";
      line.addEventListener("click", () => {
        const target = document.querySelector(`#pseudo span[data-off="${f.off}"]`);
        if (target) {
            target.scrollIntoView({ behavior: "smooth", block: "center" });
            target.classList.add("highlight");
            setTimeout(() => target.classList.remove("highlight"), 1200);
        }
      });
      div.appendChild(line);
    });
    parsed.warnings.forEach(w=>{
      const ln=document.createElement('div');
      ln.className='warning';
      ln.textContent='Warning: '+w.msg;
      div.appendChild(ln);
    });
    parsed.errors.forEach(e=>{
      const ln=document.createElement('div');
      ln.className='error';
      ln.textContent='Error: '+e.msg;
      div.appendChild(ln);
    });
    if(parsed.skipped.length>0){
      const ln=document.createElement('div');
      ln.className='muted';
      ln.textContent='Skipped offsets: '+parsed.skipped.join(', ');
      div.appendChild(ln);
    }
    return div;
  }


function renderPseudo(parsed){ // copy pasted from my dev copy :3
  let out="// parsed using yw-cond v" + ver + "\n";
  const stack=[];
  let lineCount=0;
  function indent(){ return '  '.repeat(stack.length); }
  function maybeComment(){ if(++lineCount % 10 === 0) out += indent() + '// @' + (parsed.fields[lineCount-1]?.off||'?') + '\n'; }
  parsed.fields.forEach(f=>{
    const startTag = `<span data-off="${f.off}">`;
    const endTag = `</span>`;
    switch(f.name){
      case 'HEADER': out+=startTag+'#header '+toHexWord(f.val)+endTag+'\n'; break;
      case 'OPCODE': out+=startTag+'#opcode '+toHexWord(f.val)+(f.label?' // '+f.label:'')+endTag+'\n'; break;
      case 'SECTION_START': out+=startTag+'start {'+endTag+'\n'; stack.push('start'); break;
      case 'RESOURCE_ID_A': out+=startTag+indent()+'RESOURCE_ID_A = '+toHexWord(f.val)+endTag+'\n'; break;
      case 'CTYPE_A': out+=startTag+indent()+'CTYPE_A = '+toHexWord(f.val)+'\n'+indent()+'extendConditional(RESOURCE_ID_A, CTYPE_A)'+endTag+'\n'; break;
      case 'EXTENSION_DELIMITER': if(stack[stack.length-1]==='start'){ stack.pop(); out+='} '; } out+=startTag+'extend {'+endTag+'\n'; stack.push('extend'); break;
      case 'CTYPE_B': out+=startTag+indent()+'CTYPE_B = '+toHexWord(f.val)+endTag+'\n'; break;
      case 'NEST_DELIMITER_34': out+=startTag+indent()+'nest {'+endTag+'\n'; stack.push('nest'); break;
      case 'RESOURCE_ID_B': out+=startTag+indent()+'RESOURCE_ID_B = '+toHexWord(f.val)+'\n'+indent()+'extendConditional(RESOURCE_ID_B, CTYPE_B)'+endTag+'\n'; if(stack[stack.length-1]==='nest'){ stack.pop(); out+=indent()+'}\n';} break;
      case 'SECTION_END': if(stack.length>0) stack.pop(); out+=startTag+'}'+endTag+'\n'; break;
      case 'COMPARISON_VALUE': out+=startTag+indent()+'COMPARISON_VALUE = '+toHexWord(f.val)+'\n'+indent()+'compare(COMPARISON_VALUE)'+endTag+'\n'; break;
      case 'SUB_DELIM_32': out+=startTag+indent()+'// sub-delimiter 0x32'+endTag+'\n'; break;
      case 'TERMINATOR': out+=startTag+indent()+'TERMINATOR = '+toHexWord(f.val)+';\n'+indent()+'terminate(TERMINATOR)'+endTag+'\n'; break;
      case 'EOCI': out+=startTag+indent()+'end-chain; // EOCI (End of Chain Instance)'+endTag+'\n'; break;
      default: out+=startTag+indent()+'// '+f.name+' '+toHexWord(f.val)+endTag+'\n';
    }
    maybeComment();
  });
  return out;
}


    // UI actions
    function doParseFromInput(text, opts){ // why did I name it this way..........
      clearLog();
      el('tree').innerHTML = '';
      el('pseudo').textContent = '';
      try {
        const bytes = parseInputToBytes(text);
        log('Bytes: ' + bytes.length);
        const parsed = parseCondStrict(bytes, { force78: el('expectTerm78').checked, strict: el('strictMode').checked });
        el('tree').appendChild(renderTree(parsed));
        el('pseudo').innerHTML = renderPseudo(parsed); // gotta love XSS risks js aside from being safe input this is all client side anyway - unless devtools console counts as a major security risk lmao :P
      } catch(e){
        log('Fatal: ' + e.message, 'error');
      }
    }

    el('parseBtn').addEventListener('click', ()=> doParseFromInput(el('input').value));

    el('parseB64Btn').addEventListener('click', ()=>{
      clearLog();
      try {
        const raw = el('input').value.trim();
        const decoded = tryDecodeBase64(raw);
        const hex = Array.from(decoded).map(c=>c.charCodeAt ? c.charCodeAt(0) : c).map(n=>n.toString(16).padStart(2,'0')).join(' ');
        el('input').value = hex;
        doParseFromInput(hex);
      } catch(e){
        log('Base64 decode failed: ' + e.message, 'error');
      }
    });

    el('sampleBtn').addEventListener('click', ()=>{
      el('input').value = '00 00 00 00 f0 3b 35 77 b4 63 e5 00 0a 01 28 00 06 02 32 00 00 00 01 32 00 00 00 01 78 35 77 b4 63 e5 00 0a 01 28 00 06 02 32 00 00 00 02 32 00 00 00 01 78 8f 35 77 b4 63 e5 00 0a 01 28 00 06 02 32 00 00 00 03 32 00 00 00 01 78 8f';
      el('parseBtn').click();
    });

    el('clearBtn').addEventListener('click', ()=>{
      el('input').value=''; clearLog(); el('tree').innerHTML=''; el('pseudo').textContent='';
    });

    el('copyPseudoBtn').addEventListener('click', ()=>{
      const txt = el('pseudo').textContent;
      if(!txt) { log('Nothing to copy', 'warn'); return; }
      navigator.clipboard?.writeText(txt).then(()=> log('Pseudocode copied to clipboard'), ()=> log('Copy failed', 'warn'));
    });

    el('downloadBtn').addEventListener('click', ()=>{
      const pseudo = el('pseudo').textContent || '';
      const blob = new Blob([pseudo], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'cond.txt';
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    });

    // keyboard shortcut: Ctrl+Enter to parse
    el('input').addEventListener('keydown', (ev)=>{
      if((ev.ctrlKey || ev.metaKey) && ev.key === 'Enter'){
        ev.preventDefault();
        el('parseBtn').click();
      }
    });

    // small check catch uncaught errors so they appear in log
    window.addEventListener('error', (ev)=> {
      log('Uncaught error: ' + (ev.error?.message || ev.message || ev), 'error');
    });
    let x = document.createElement("footer");
    document.body.appendChild(x) // archiving my stupidity again - I almost released this with: document.getElementsByTagName("body")[0].appendChild(x)
    x.outerHTML = `<footer style="font-size: large;">yw-cond. Version: <span id="vdisplay">${ver}</span></footer>`
  </script>
</body>
</html>
