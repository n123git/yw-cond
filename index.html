<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>YW-Cond v1.395</title>
  <style>
    :root{
      --bg:#0f1115; --panel:#0b0d10; --text:#e6eef6; --muted:#9aa6b2; --accent:#6ea8ff; --good:#8bd18b; --bad:#ff7b7b;
    }
    body{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, monospace; margin:12px; color:var(--text); background:var(--bg);}
    .container{max-width:980px;margin:0 auto;padding:12px}
    h2{margin:0 0 8px 0}
    textarea{width:100%;min-height:120px;padding:8px;background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--text);}
    button{background:transparent;border:1px solid rgba(255,255,255,0.08);color:var(--text);padding:6px 8px;margin:4px;border-radius:6px;cursor:pointer}
    .controls{display:flex;flex-wrap:wrap;gap:6px;align-items:center;margin:8px 0}
    #log{white-space:pre-wrap;background:transparent;border:1px dashed rgba(255,255,255,0.03);padding:8px;min-height:36px;color:var(--muted)}
    .tree{background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent);padding:8px;border-radius:6px;margin-top:8px}
    .node{padding:6px;border-radius:4px;margin:2px 0;cursor:pointer}
    /* updated to work on light mode too (eugh) */
    .node:hover {
       background: rgba(255, 255, 255, 0.04);
       border: 1px solid transparent;
    }
  
    /* Light mode stuff :< */
    .light .node:hover {
      background: rgba(0, 0, 0, 0.08);
      border: 1px solid rgba(0, 0, 0, 0.08);
    }
    .light .node:active,
    .light .node.selected {
      background: rgba(0, 0, 0, 0.12);
      border: 1px solid rgba(0, 0, 0, 0.12);
    }


    .label{color:var(--accent);font-weight:600;margin-left:8px}
    .small{font-size:0.85em;color:var(--muted)}
    .muted{color:var(--muted)}
    .danger{color:var(--bad)}
    .ok{color:var(--good)}
    .pseudo{white-space:pre;background:transparent;border:1px solid rgba(255,255,255,0.03);padding:8px;border-radius:6px;margin-top:8px}

/* ====== Light Mode Enhancements ====== */
.light {
  --bg: #f4f6f8;
  --panel: #ffffff;
  --text: #222;
  --muted: #6b7280;
  --accent: #d08b00;
  --good: #16803c;
  --bad: #cc3b3b;
}

/* Give light mode a faint shadowed feel to offset white */
.light body {
  background: linear-gradient(180deg, #fafafa, #f3f4f6);
}

/* Light mode textarea and pseudo blocks pop slightly */
.light textarea,
.light .pseudo {
  background: rgba(0, 0, 0, 0.02);
  border-color: rgba(0, 0, 0, 0.1);
}

/* Buttons and selects look more tactile in light mode */
.light button,
.light select {
  background: rgba(0, 0, 0, 0.02);
  border-color: rgba(0, 0, 0, 0.1);
}

.light button:hover,
.light select:hover {
  background: rgba(0, 0, 0, 0.06);
  border-color: rgba(0, 0, 0, 0.18);
}

    /* modal basics */
    dialog{border:1px solid rgba(0,0,0,0.08);background:var(--panel);color:var(--text);padding:12px;border-radius:8px}
    label{display:inline-block}
    input[type=text]{padding:6px;border-radius:6px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:var(--text)}

    /* gotta add select/option CSS too */

    select { /* chevron sounds so fancy */
      padding: 6px;
      border-radius: 6px;
      border: 1px solid rgba(255, 255, 255, 0.04);
      background: transparent;
      color: var(--text);
      font-family: inherit;
      font-size: 0.95em;
      cursor: pointer;
      appearance: none; /* remove native arrow (for custom look) */
      background-image: linear-gradient(45deg, transparent 50%, var(--muted) 50%),
                        linear-gradient(135deg, var(--muted) 50%, transparent 50%);
      background-position: calc(100% - 16px) center, calc(100% - 12px) center;
      background-size: 5px 5px, 5px 5px;
      background-repeat: no-repeat;
      padding-right: 28px; /* space for arrow */
      transition: border-color 0.2s, background-color 0.2s;
    }
    
    select:hover, select:focus {
      border-color: rgba(255, 255, 255, 0.12);
      background-color: rgba(255, 255, 255, 0.02);
      outline: none;
    }
    
    option {
      background: var(--panel);
      color: var(--text);
      font-family: inherit;
    }

/* ====== Global smooth transitions ====== */
* {
  transition: background 0.25s ease, border-color 0.25s ease,
              color 0.25s ease, box-shadow 0.25s ease,
              transform 0.2s ease;
}

/* Button hover animation */
button:hover {
  background: rgba(255, 255, 255, 0.05);
  transform: translateY(-1px);
  box-shadow: 0 2px 4px rgba(0,0,0,0.2);
}
button:active {
  transform: translateY(0);
  box-shadow: none;
}

/* In light mode */
.light button:hover {
  background: rgba(0, 0, 0, 0.06);
  transform: translateY(-1px);
  box-shadow: 0 2px 6px rgba(0,0,0,0.15);
}

/* Node hover glow */
.node {
  transition: background 0.25s ease, transform 0.2s ease, border-color 0.25s ease;
}
.node:hover {
  transform: scale(1.01);
  background: rgba(255, 255, 255, 0.05);
}
.light .node:hover {
  background: rgba(0, 0, 0, 0.05);
}

/* Tree entry selection feedback */
.node.selected {
  border: 1px solid var(--accent);
  background: rgba(110, 168, 255, 0.1);
}

.light textarea:focus {
  box-shadow: 0 0 0 3px rgba(208, 139, 0, 0.2);
}

/* Pseudo-code block hover motion */
.pseudo:hover {
  transform: scale(1.01);
  border-color: rgba(255,255,255,0.08);
}
.light .pseudo:hover {
  border-color: rgba(0,0,0,0.1);
}



/*a*/
/* === 1. Accent glow only on labels (not on nodes) === */
@keyframes glow {
  0%, 100% { text-shadow: 0 0 4px var(--accent); }
  50%      { text-shadow: 0 0 10px var(--accent); }
}

.label:hover {
  animation: glow 1.5s ease-in-out infinite alternate;
}

/* Prevent nodes from glowing */
.node:hover, .node.selected {
  text-shadow: none;
}


/* === 2. Modal (dialog) Styling === */
dialog {
  border: 1px solid rgba(255,255,255,0.08);
  background: var(--panel);
  color: var(--text);
  padding: 16px 20px;
  border-radius: 10px;
  box-shadow: 0 12px 24px rgba(0,0,0,0.4);
  transition: transform 0.25s ease, opacity 0.25s ease;
  transform: translateY(-8px);
  opacity: 0;
}

dialog[open] {
  transform: translateY(0);
  opacity: 1;
}

/* Backdrop blur for modern feel */
dialog::backdrop {
  backdrop-filter: blur(4px) brightness(0.9);
  background: rgba(0,0,0,0.4);
}

/* Light mode dialog contrast */
.light dialog {
  border-color: rgba(0,0,0,0.08);
  box-shadow: 0 12px 24px rgba(0,0,0,0.15);
}

.light dialog::backdrop {
  backdrop-filter: blur(4px) brightness(1.05);
  background: rgba(255,255,255,0.45);
}

/* Modal buttons alignment */
dialog button {
  background: var(--panel);
  border-color: rgba(255,255,255,0.08);
}
dialog button:hover {
  background: rgba(255,255,255,0.06);
}
.light dialog button:hover {
  background: rgba(0,0,0,0.05);
}


/* === 3. Remove the bright blue focus ring & unify textarea focus === */
textarea,
input[type=text],
select {
  outline: none; /* removes system blue outline */
  transition: border-color 0.25s ease, box-shadow 0.25s ease, transform 0.25s ease;
}

/* unified focus glow */
textarea:focus,
input[type=text]:focus,
select:focus {
  border-color: var(--accent);
  box-shadow: 0 0 0 3px color-mix(in srgb, var(--accent) 40%, transparent);
  transform: scale(1.01);
}

/* Light mode version with adjusted contrast */
.light textarea:focus,
.light input[type=text]:focus,
.light select:focus {
  box-shadow: 0 0 0 3px color-mix(in srgb, var(--accent) 30%, transparent);
}

  </style>
</head>
<body>
  <div class="container" id="app">
    <h2>Yo-kai Watch Cond Parser <span class="small">v1.391</span></h2>
    <div class="small muted">Paste hex (spaced/continuous) or Base64. Parser uses V3 parsing.</div>

    <textarea id="input" placeholder="Paste hex (e.g. '00 0A 01') or base64 here"></textarea>

    <div class="controls">
      <button id="parseBtn">Parse</button>
      <button id="parseB64Btn">Parse Base64</button>
      <button id="sampleBtn">Load Sample</button>
      <button id="clearBtn">Clear</button>
      <button id="copyPseudoBtn">Copy Pseudocode</button>
      <button id="downloadBtn">Download Pseudocode</button>
      <button id="generateBtn">Generate Known Cond(s)</button>
      <label class="small muted" style="margin-left:8px"><input type="checkbox" id="lightMode"> Light mode</label>
    </div>

    <div id="log" aria-live="polite">Ready.</div>

    <div style="display:flex;gap:12px;margin-top:12px;align-items:flex-start">
      <div style="flex:1">
        <div class="tree" id="tree" role="region" aria-label="Parsed tree"></div>
      </div>
      <div style="width:46%">
        <div class="pseudo" id="pseudo"></div>
      </div>
    </div>

    <dialog id="generateModal">
      <h3>Generate Known Cond(s)</h3>
      <label>Condition: <select id="condSelect"></select></label>
      <div id="extraInputs"></div>
      <div style="margin-top:10px"><button id="generateCondBtn">Generate</button> <button id="closeModalBtn">Cancel</button></div>
    </dialog>
  </div>

  <script>
    // version
    const ver = 1.395;

    if(typeof level5 === 'undefined') level5 = {};
    if(typeof level5.cond === 'undefined') level5.cond = {};
    if(typeof level5.cond._internals === 'undefined') level5.cond._internals = {};

    // manually labelled ones; some were before I decompiled it and some are just not in 1s
    const knownResourceIDs = {
      '2A 3D 45 43': 'Check for FLAG_INFO_0 Flag (YW1/YW2/YW3/IEGO)', // output is always a boolean value in the int type (00 06 02); passed param is the FlagID as an int (00 06 02) in BE order
      '10 B1 40 96': 'Is Main Story Completed (YW1/YW2)', // can be obtained from several places; one source (the first place this was found in) was Jungle Hunter shop conds, type: 00 01 00
      'DD 77 26 95': 'Watch Rank (YW1/YW2)', // grabs player watch rank, 0 = E, ..., 5 = S
      '8D 76 66 D8': 'Check if player has Item (YW1/YW2)', // passed param is ItemID as an int (00 06 02) in LE order
      '9E 99 84 8C': 'Check for FLAG_INFO_1 Flag (YW1/YW2/YW3)', // output is always an int (00 06 02); passed param is the FlagID as an int (00 06 02) in BE order
      'DE 17 FE 18': 'Lifetime Oni Orbs Collected in Psychic Blasters (YW2)',
      'B6 B8 67 71': 'Yo-kai HP% (YW2)', // during battle; yokai targeted is dependent on the context of the cond executor - NOT the cond itself
      'B9 19 36 DA': 'Phase (YW2)', // now known as GetPhase - this exists in YW1, YW2 most likely YWB, YW3 and YWB2
      '37 90 0A 0D': 'Unique Yo-kai Cam Photos Taken (YW2)', // type: 00 01 00
      'C6 54 8E E3': 'Unique Bug Species Caught? (YW2)', // ? type: 00 01 00
      '85 E3 BE AF': 'Unique Fish Species Caught? (YW2)', // ? type: 00 01 00
      '83 DD D1 64': 'Psychic Blasters Oni Orbs High Score (YW2)',
      'BE 04 A5 98': 'Quest State (YW2)', // FF = Complete
      '77 B4 63 E5': 'Grab Psychic Blasters Boss IsCleared (YW2)', // params: (int: index) 
      '3F FC EE 50': 'Battle State Data (YW2)', // if the passed param is 0, returns the amount of ally yokai WITHOUT a positive inspirit. Other param values lead to unknown results -- THIS WAS SLIGHTLY WRONG; actual namespace was GetActorForwardToritukuGoodCountLowerCnt and it takes no params dont know how I missed that :< --
      'EE CA 88 5A': 'Map Data2 (YW2)', // 2 param func, 2 params are IDs; example in load sample, used to check certain data in npc-set
      '48 A8 7F D3': 'Map Data1 (YW2)', // same but used to check a different state

      '27 32 6D 47': 'Is Trophy Complete? (YW2)', // params: TrophyID, returns bool, some trophies dont use this cond

      '74 03 A9 CE': 'Unk Phase-like Func (YW2)', // 3 params, 2 are usually function outputs and the 3rd/last seems to be phase; not in yw1

      // RESOURCE_ID_Bs (not Functions)

      // FlagIDs
      '89 20 FF E7': 'Infinite Tunnel Clear Count (YW2)',
    };
    level5.cond._manual = knownResourceIDs; // backup
    const CExpressionInternalNames = [ // list of CExpression Functions; grouped based on similarities, NOT based on the order they are defined :)
      // ywBattleExpressionFunc
      'GetActorAgility',
      'GetActorAttack',
      'GetActorDefence',
      'GetActorHP',
      'GetActorHPRate',
      'GetActorPartsHP',
      'GetActorPartsHPRate',
      'GetActorMagic',
      'GetActorMode',

      'GetActorForwardCnt',
      'GetActorForwardAtkToritukuCnt',

      'GetActorForwardAverageHPRate',
      'GetActorForwardHighNeedSpSkillPointCnt',
      'GetActorForwardHighSpSkillRankCnt',
      'GetActorForwardHpRateHigherCnt',
      'GetActorForwardHpRateLowerCnt',

      'GetActorPartyAtkToritukuCnt',
      'GetActorPartyAverageHPRate',
      'GetActorPartyCnt',
      'GetActorPartyHpRateHigherCnt',
      'GetActorPartyHpRateLowerCnt',
      'GetActorPartyLastSpecialActionCountLowerCnt',

      'GetActorForwardLowNeedSpSkillPointHpRecoverCnt',
      'GetActorForwardLowSpSkillRankHpRecoverCnt',
      'GetActorForwardToritukuBadCountEqualCnt',
      'GetActorForwardToritukuBadCountHigherCnt',
      'GetActorForwardToritukuBadCountLowerCnt',
      'GetActorForwardToritukuGoodCountEqualCnt',
      'GetActorForwardToritukuGoodCountHigherCnt',
      'GetActorForwardToritukuGoodCountLowerCnt',

      'GetActorSpecialCancelOffset',
    
      'GetActorToritukuBadCnt',
      'GetActorToritukuGoodCnt',
      'GetCommonAtkToritukuCnt',
      'GetCommonAverageHPRate',
      'GetCommonPartyCnt',
      'GetCommonToritukuBadCountOpCnt',
      'GetCommonToritukuGoodCountOpCnt',

      'GetPartyDeadCnt',

      'GetTargetForwardAtkElemDefFactorHigherCnt',
      'GetTargetForwardAtkElemDefFactorLowerCnt',
      'GetTargetForwardAtkToritukuCnt',
      'GetTargetForwardChargeCnt',
      'GetTargetForwardCnt',

      'GetTargetForwardHpRateHigherCnt',
      'GetTargetForwardHpRateLowerCnt',
      'GetTargetForwardAverageHPRate',

      'GetTargetForwardLowestDefence',
      'GetTargetForwardNormalGoodCnt',

      'GetTargetForwardToritukuBadCountEqualCnt',
      'GetTargetForwardToritukuBadCountHigherCnt',
      'GetTargetForwardToritukuBadCountLowerCnt',
      'GetTargetForwardToritukuGoodCountEqualCnt',
      'GetTargetForwardToritukuGoodCountHigherCnt',
      'GetTargetForwardToritukuGoodCountLowerCnt',

      'GetTargetPartyAtkToritukuCnt',
      'GetTargetPartyAverageHPRate',
      'GetTargetPartyChargeCnt',
      'GetTargetPartyCnt',
      'GetTargetPartyHpRateHigherCnt',
      'GetTargetPartyHpRateLowerCnt',
      'GetTargetPartyLowestDefence',
      'GetTargetPartyNormalGoodCnt',

      'IsActorMagicHpRecovery',
      'IsActorRegen',
      'IsActorSpecialHpRecovery',
      'IsActorToritukuBad',
      'IsActorToritukuGood',
      'IsCommandDamageDown',

      'IsTargetForwardMagicDamageDown',
      'IsTargetForwardWazaDamageDown',

      'GetFalse', // ??? not in yw::util::CExpression, but should be?

      // ywGDExpressionFunc
      'GameClear', // returns 1 if the main story has been completed, 0 otherwise
      'GetChapter',
      'GetWatchRank',

      'GetGlobalBitFlag', // grabs the value of a FlagID - you can find them in FLAG_INFO_0; input: BE FlagID in XQ: get_global_bitflag()
      'GetGlobalByteFlag', // grabs the value of a FlagID - you can find them in FLAG_INFO_1; input: BE FlagID, returns 0 if something goes wrong i.e. the flag is null/dosent exist
      'GetTempBitFlag', // grabs the value of a FlagID - you can find them in FLAG_INFO_3; input: BE FlagID, returns 0 if something goes wrong i.e. the flag is null/dosent exist
      'GetTempByteFlag',
      'GetTempMapBitFlag',
      'GetTempMapByteFlag',

      'CheckQuestNecessaryCondition',
      'GetGlobalCharaCompFlagCRC',
      'GetGlobalCharaMetFlag',
      'GetGlobalTBoxFlag', // no-opped?

      'GetItemNum',
      'GetMoney', // in yen so: $\£\€1.23 = 123y and 250W = 100y
      'GetPartyNum',
      'GetPhase', // basically a massive number meaning lots of complex positions and stuff in the story; this WILL be a pain and sadly you WILL see it frequently :/
      'GetPlayerVarID', // no params output of 2 means female??
      'GetQuestCompNum',
      'GetQuestPhase', // FF = Quest Complete

      'GetTimeHour', // returns 0 if game time is null and if not the hour which is derived from (time in ticks) / 0x2A30
      'GetTimeNow', // returns -1 if the world isnt loaded, 3 if the game time is null otherwise either 0, 1, 2 or 3 (the repetition of 3 is intentional - it is the default time)
      'GetWeatherNow', // returns -1 if the world isnt loaded (GameManager::spRPGWorld == 0), 0 if the weather data ptr is null else weather byte as uint

      'InPartyMember', // input: (int: BaseID BE) returns 0 if the players party does not contain this yokai, else 1 (Uses CharaParamInfo)
      'IsApeearMitibiki', // typo is level5s fault not mine :/
      'IsAppearMitibiki', // this is not real, read the above one and then this comment: even though im 100% sure the ID will also include the typo, ill include the fixed version cuz why not :P

      'IsBicycleOn', // remember checks only happen when the condition is evaluated, for NPCs thats when the map loads, for shop items its when the shop is opened - dont expect a check using this function to update 60fps lmao (or 30fps outside of UIs this is the 3DS after all)
      'IsFullParty', // returns 0 (false) if party is null or isnt full, else 1 (true)
      'IsHaveItem', // pass the ItemID as BE, 1 (true) if the player has it, else 0 (false); internally just checks if the quantity is not 0
      'IsNpcUtil', // bruh; The function checks if the NPC with a given ID exists in spNpcCtrl, if a second param is provided and is equal to 1, it queries a specific bit flag on that NPC; Returns 1 or 0 based on these checks.

      'RunTrigger', // always returns 1 (true)
      'SetGlobalBitFlag', // FLAG_INFO_0; always returns 1 (true)
      'SetGlobalByteFlag', // FLAG_INFO_1; always returns 1 (true)
      'SetQuestPhase', // input: QuestID BE and int; sets the Quests phase to the passed int; phase FF = complete; function always returns 1 (true)
      'SetTempBitFlag', // input: FlagID and int; sets the temporary (non-global so not in flag_config) flag to the int; function always returns 1 (true)
      'SetTempByteFlag', // input: FlagID and int; sets the temporary (non-global so not in flag_config) flag to the int; function always returns 1 (true)
      'UpdateQuestPurpose', // updates some NPC stuff, quest stuff im too lazy to document this BUT I will laugh at one of level5s infamous typos: CScnObjRPGWorld::UpdataQuestMiniMapIcon

      'YS_CheckYokaiBaseID', // Input: BaseID; Returns 1 if the BaseID can be found in a Yo-kai Spot, else 0
      'YS_IsActive_Map', // Takes two IDs, one is a MapID and returns 1 or 0
      'YS_IsActive_Yokai', // wrapper for ywYokaispotStatus::IsActive_Yokai; returns 1 or 0
      'YS_IsFind_Map',
      'YS_IsFind_Yokai',
      'YS_IsFindFix',
      'YS_IsFindTmp',
      'YS_SetEnd',
      'YS_SetFind',


      // yw::util::CExpression
      // 100% only used internally but may as well
      'GetFloat',
      'GetLastValue',
      'GetResult',
      'GetS16',
      'GetS32',
      'GetS8',
      'GetStackValue',
      'GetU16',
      'GetU32',
      'GetU8',
        // yw::util::CExpression::CValue
        'GetProperValueType',
        'GetValueF32',
        'GetValueS16',
        'GetValueS32',
        'GetValueS32Direct', // Casts the result directly to a CValue, dosent check type, just grabs the value
        'GetValueS8',
        'GetValueU16',
        'GetValueU32',
        'GetValueU8',
        'IsFalse',
        'IsTrue',
        // I skipped alot because I'm lazy
        'SetValue',
        'SetValueF32',
        'SetValueS16',
        'SetValueS32',
        'SetValueS8',
        'SetValueU16',
        'SetValueU32',
        'SetValueU8',
   ]
   level5.cond.CExpressionInternalNames = CExpressionInternalNames;

   // CRC32 implementation (standard polynomial 0xEDB88320)
  function crc32(str) {
    let crc = 0 ^ (-1);

    for (let i = 0; i < str.length; i++) {
      crc = (crc >>> 8) ^ table[(crc ^ str.charCodeAt(i)) & 0xFF];
    }

    return (crc ^ (-1)) >>> 0;
  }

  // Precompute CRC32 table for speed
  const table = (() => {
    let c;
    const tbl = [];
    for (let n = 0; n < 256; n++) {
      c = n;
      for (let k = 0; k < 8; k++) {
        c = (c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1);
      }
      tbl[n] = c >>> 0;
    }
    return tbl;
  })();
     // got sidetracked optimising C++ code - so I ended up writing this code to free up 
    level5.cond.CExpressionInternalMappings = (() => {
      const temp = {};
      for (const funcName of CExpressionInternalNames) {
        const crc = crc32(funcName);
        const hexStr = crc.toString(16).padStart(8, '0').toUpperCase().match(/../g).join(' ');
        knownResourceIDs[hexStr] = funcName;
        temp[hexStr] = funcName;
      }
      return temp;
    })();

    // cond templates
    level5.cond.condTemplates = {
        mainStory: {
            type: "b64", // I dont even know what this does anymore......
            value: "AAAAAA8FNRCxQJYAAQAyAAAAAXg=", // direct value
            label: "Yo-kai Watch 1/2 – Main Story Completed" // label
            // no UI elements accept generate and cancel
        },
        unmainStory: {
            type: "b64",
            value: "AAAAAA8FNRCxQJYAAQAyAAAAAHg=",
            label: "Yo-kai Watch 1/2 – Main Story Not Completed"
        },
        rankXX: {
            type: "hex",
            template: "00 00 00 00 0f 05 35 dd 77 26 95 00 01 00 32 00 00 00 {RANK} 71", // template
            params: [
                { 
                    name: "RANK", // define rank
                    label: "Rank (00–FF)", // UI label
                    inputType: "hex", // input treated as hex
                    max: 0xFF, // byte cap
                    padding: 0x1, // pad as byte
                    placeholder: "e.g. 06" // UI input placeholder
                }
            ],
            label: "Yo-kai Watch 1/2 – Rank XX or higher" // label
        },
        hasItem: {
            type: "hex",
            template: "00 00 00 00 18 05 35 8d 76 66 d8 00 0a 01 28 00 06 02 34 {ITEM} 32 00 00 00 01 78",
            params: [
                { 
                    name: "ITEM", 
                    label: "Item ID (4-byte big endian)", 
                    inputType: "default",
                    padding: 0x4,
                    max: 0xFFFFFFFF,
                    byteCoerce: 4, // coerce to signed 32-bit integer
                    placeholder: "e.g. 1678239 or 0x638297A" 
                }
            ],
            label: "Yo-kai Watch 1/2 – Has Item"
        },
        tunnelXX: {
            type: "hex",
            template: "00 00 00 00 18 05 35 9e 99 84 8c 00 0a 01 28 00 06 02 34 89 20 ff e7 32 00 00 00 {COUNT} 78",
            params: [
                { 
                    name: "COUNT", 
                    label: "Times Beaten (00–FF)", 
                    inputType: "hex",
                    max: 0xFF,
                    padding: 0x1,
                    placeholder: "e.g. 05" 
                }
            ],
            label: "Yo-kai Watch 2/3 – Beaten Infinite Tunnel XX Times"
        },
        npcFlagYW3: {
            type: "hex",
            template: "00 00 00 00 18 05 35 {FLAG_TYPE} 00 0a 01 28 00 06 02 34 {FLAG} 32 00 00 00 01 78",
            params: [
                {
                    name: "FLAG_TYPE",
                    label: "Flag Type",
                    type: "select", // define a select
                    options: [ // with options
                        { label: "FLAG_INFO_0", value: "2A 3D 45 43" }, // label-value, key-value pair except it's not just {'FLAG_INFO_0', '2A 3D 45 43'} for whatever reason.... dont question my very questionable code
                        { label: "FLAG_INFO_1", value: "9E 99 84 8C" }
                    ]
                },
                {
                    name: "FLAG",
                    label: "Flag ID (4-byte big endian)",
                    inputType: "default",
                    padding: 0x4,
                    max: 0xFFFFFFFF,
                    byteCoerce: 4,
                    placeholder: "e.g. 12345678 or 0x00ABCDEF"
                }
            ],
            label: "Yo-kai Watch 1/2/3 - Check for Flag (Activated)"
        },
        unhasItem: {
            type: "hex",
            template: "00 00 00 00 18 05 35 8d 76 66 d8 00 0a 01 28 00 06 02 34 {ITEM} 32 00 00 00 00 78",
            params: [
                { 
                    name: "ITEM", 
                    label: "Item ID (4-byte big endian)", 
                    inputType: "default",
                    padding: 0x4,
                    max: 0xFFFFFFFF,
                    byteCoerce: 4,
                    placeholder: "e.g. 1678239 or 0x638297A" 
                }
            ],
            label: "Yo-kai Watch 1/2 – Does Not Have Item"
        },
        unnpcFlagYW3: {
            type: "hex",
            template: "00 00 00 00 18 05 35 {FLAG_TYPE} 00 0a 01 28 00 06 02 34 {FLAG} 32 00 00 00 00 78",
            params: [
                {
                    name: "FLAG_TYPE",
                    label: "Flag Type",
                    type: "select",
                    options: [
                        { label: "FLAG_INFO_0", value: "2A 3D 45 43" },
                        { label: "FLAG_INFO_1", value: "9E 99 84 8C" }
                    ]
                },
                {
                    name: "FLAG",
                    label: "Flag ID (4-byte big endian)",
                    inputType: "default",
                    padding: 0x4,
                    max: 0xFFFFFFFF,
                    byteCoerce: 4,
                    placeholder: "e.g. 12345678 or 0x00ABCDEF"
                }
            ],
            label: "Yo-kai Watch 1/2/3 - Check for Flag (Not Activated)"
        }
    };

    /* Templates V2.0 (+ a whole lot of suffering to get it to work) */
    level5.cond.TemplateManager = class {
        constructor(templates) {
            if (!templates || typeof templates !== 'object') {
                console.warn('TemplateManager: templates argument missing or invalid. Using empty object.');
                templates = {};
            }
            this.templates = templates;
        }

        get(key) {
            return this.templates[key];
        }

        populateSelect(selectEl) {
            if (!selectEl) throw new Error('populateSelect: selectEl is required');
            selectEl.innerHTML = '';

            const keys = Object.keys(this.templates);
            if (keys.length === 0) {
                const opt = document.createElement('option');
                opt.value = '';
                opt.textContent = 'No templates available';
                selectEl.appendChild(opt);
                return;
            }

            keys.forEach(key => {
                const tpl = this.templates[key] || {};
                const opt = document.createElement('option');
                opt.value = key;
                opt.textContent = tpl.label || key;
                selectEl.appendChild(opt);
            });
        }

        renderInputs(container, key) {
            container.innerHTML = '';
            const tpl = this.get(key);
            if (!tpl || !Array.isArray(tpl.params)) return;

            tpl.params.forEach(param => {
                const label = document.createElement('label');
                label.textContent = param.label + ': ';

                let input;
                if (param.type === 'select' && Array.isArray(param.options)) {
                    input = document.createElement('select');
                    param.options.forEach(opt => {
                        const o = document.createElement('option');
                        // Force literal string storage for values with spaces
                        o.value = String(opt.value);
                        o.textContent = opt.label;
                        input.appendChild(o);
                    });
                } else {
                    input = document.createElement('input');
                    input.type = param.inputType === 'hex' ? 'text' : 'text';
                    input.placeholder = param.placeholder || '';
                    input.dataset.inputType = param.inputType || 'default'; // store type here

                    if (param.inputType === 'hex' || param.inputType === 'default') {
                        if (param.max) input.dataset.max = param.max;
                        if (param.padding) input.dataset.padding = param.padding;
                    }
                }

                input.id = `param_${param.name}`;
                input.dataset.name = param.name;
                input.style.marginLeft = '6px';

                label.appendChild(input);
                container.appendChild(label);
                container.appendChild(document.createElement('br'));
            });
        }

        getValues(container) {
            const inputs = container.querySelectorAll('[id^=param_]');
            const result = {};
            // this method single handedly made me want to- :<<<<<
            // so.... so many edge cases
            inputs.forEach(inp => {
                const name = inp.dataset.name;
                let value;

                // handle selects literally...
                if (inp.tagName.toLowerCase() === 'select') {
                    const selectedOpt = inp.options[inp.selectedIndex];
                    value = selectedOpt?.value ?? '';
                    result[name] = value;
                    return;
                }

                // read text
                value = inp.value.trim();
                if (typeof value !== 'string') value = String(value);

                const inputType = inp.dataset.inputType || 'default';
                const padBytes = parseInt(inp.dataset.padding || '0', 10);
                const byteCoerce = parseInt(inp.dataset.byteCoerce || '0', 10); // NEW
                let num;

                // parse numeric value
                if (inputType === 'hex') {
                    value = value.replace(/^0x/i, '').replace(/[^0-9A-Fa-f-]/g, '');
                    num = parseInt(value || '0', 16);
                } else {
                    // "default" — allow 0x prefix for hex
                    if (/^0x/i.test(value)) {
                        num = parseInt(value, 16);
                    } else {
                        num = parseInt(value, 10);
                    }
                }

                if (isNaN(num)) num = 0;

                // apply the max, if there is one
                const maxRaw = inp.dataset.max;
                let max = 0;
                if (maxRaw) {
                    max = /^0x/i.test(maxRaw)
                        ? parseInt(maxRaw, 16)
                        : parseInt(maxRaw, 10);
                }
                if (!isNaN(max) && max > 0 && num > max) num = max;
                
                // apply byteCoerce
                if (byteCoerce > 0) {
                    switch (byteCoerce) {
                        case 1: num = num & 0xFF; break; // unsigned 8-bit integer (uint8)
                        case 2: num = num & 0xFFFF; break; // unsigned 16-bit integer (uint16)
                        case 4: num = num >>> 0; break; // unsigned 32-bit integer (uint32)
                        default: throw new SyntaxError("Invalid byteCoerce value"); // fancy :3
                    }
                } else if (padBytes > 0) { // else use padding
                    if (padBytes === 1) num = num & 0xFF;
                    else if (padBytes === 2) num = num & 0xFFFF;
                    else if (padBytes === 4) num = num >>> 0;
                }
                
                if (padBytes > 0) { // create the output
                    let hex = (num >>> 0).toString(16).toUpperCase(); // ofc always treat as unsigned for padding
                    value = hex.padStart(padBytes * 2, '0')
                        .match(/.{1,2}/g)
                        .join(' ');
                } else {
                    if (inputType === 'hex' || inputType === 'default') {
                        value = num.toString(16).toUpperCase();
                    } else {
                        value = num.toString(10);
                    }
                }

                result[name] = value;
            });
        
            return result;
        }
        
        
        generate(key, params) {
            const tpl = this.get(key);
            if (!tpl) return null;

            let resultStr = tpl.value ?? tpl.template ?? '';

            if (tpl.template && params && typeof params === 'object') {
                Object.entries(params).forEach(([name, value]) => {
                    const token = new RegExp('\\{' + name + '\\}', 'g'); // escape curly braces properly
                    resultStr = resultStr.replace(token, value);
                });
            }

            return {
                type: tpl.type,
                value: resultStr,
                label: tpl.label,
            };
        }

    };
    level5.cond.templateManager = new level5.cond.TemplateManager(level5.cond.condTemplates); // init class

    /* UI schenaniganagaaggagagagagaggagagagaggagags */
    document.addEventListener('DOMContentLoaded', () => {
        const $ = el;

        const tmplMgr = level5.cond.templateManager; // instance of class NOT the actual class
        const generateModal = $('generateModal');
        const condSelect = $('condSelect');
        const extraInputs = $('extraInputs');

        if (!Object.keys(level5.cond.condTemplates).length) {
            console.info('no level5.cond.condTemplates :/ Current object:', level5.cond.condTemplates);
        }

        tmplMgr.populateSelect(condSelect);
        tmplMgr.renderInputs(extraInputs, condSelect.value);

        condSelect.addEventListener('change', () => tmplMgr.renderInputs(extraInputs, condSelect.value));

        $('generateBtn')?.addEventListener('click', () => generateModal.showModal());
        $('closeModalBtn')?.addEventListener('click', () => generateModal.close());

        $('generateCondBtn')?.addEventListener('click', () => {
            const key = condSelect.value;
            const params = tmplMgr.getValues(extraInputs);
            const result = tmplMgr.generate(key, params);
            if (!result) {
                alert('Invalid condition template!');
                return;
            }
            console.log("wow", result)
            el('input').value = result.value; // used innerText earlier lol; that broke some stuff somehow
            el('parseBtn').click();
            generateModal.close();
        });
    });

    // very basic utils
    function normalizeInputRaw(text){ return (text||'').trim(); }

    function tryDecodeBase64(s){
      try { return atob(s); } catch(e){ try { const urlFixed = s.replace(/-/g,'+').replace(/_/g,'/'); const pad = urlFixed.length % 4 === 0 ? urlFixed : urlFixed + '='.repeat(4 - (urlFixed.length % 4)); return atob(pad);} catch(e2){ throw new Error('Not valid base64'); } }
    }

    function inputToHexString(text){
      const t = normalizeInputRaw(text);
      if(!t) return '';
      // try continuous hex first
      const hexCandidate = t.replace(/0x/gi,'').replace(/[:,\-<>]/g,'').replace(/\s+/g,'').trim();
      if(/^[0-9a-fA-F]*$/.test(hexCandidate) && hexCandidate.length % 2 === 0 && hexCandidate.length>0) return hexCandidate.toUpperCase();
      // try base64 (no spaces)
      const looksLikeB64 = /^[A-Za-z0-9+\/=_\-]+$/.test(t) && !/\s/.test(t);
      if(looksLikeB64){
        try{ const dec = tryDecodeBase64(t); return Array.from(dec).map(c => (typeof c==='string' ? c.charCodeAt(0) : c).toString(16).padStart(2,'0')).join('').toUpperCase(); } catch(e){ /* fallthrough */ }
      }
      // fallback: split on spaces/tokens
      const cleaned = t.replace(/0x/gi,'').replace(/[:,\-<>]/g,' ').replace(/\s+/g,' ').trim();
      const parts = cleaned.split(' ');
      return parts.map(p => p.padStart(2,'0')).join('').toUpperCase();
    }

    // helper: format hex string into spaced groups
    function hexSpaced(h){ return (h||'').match(/.{1,2}/g)?.join(' ') || ''; }

    // gotta organise this:

    // reads
    level5.cond.READ_MEMORY = "35";
    level5.cond.READ_LITERAL = "32";
    level5.cond.READ_SUBSECTION = "34";

    // extension markers?
    level5.cond.EXTENSION_DELIM = "28"; // not fully a read but helps with structure and is always near a READ_SUBSECTION
    level5.cond.UPRM = "5D"; // just the + operator but since I havent rewritten the parser to be more stack-oriented this is neccessary for now
    // EOCIs
    level5.cond.EOCI = "8F";
    level5.cond.AEOCI = "90"; // this exists....

    level5.cond.temp = {
      "32": "+const",  // push constant (int)  
      "33": "+const‑alt",   // push constant (int) alt ?
      "34": "+const‑float",  // push constant (float?)  
      "35": "call", // call function  
    }

    // Operators
    level5.cond.OPERATORS = [
      "46",  // ++ (increment)  
      "47",  // -- (decrement)  
      "50",  // ~ (bitwise NOT)  
      "51",  // ! (logical NOT)  
      "5A",  // * (multiply)  
      "5B",  // / (divide)  
      "5C",  // % (modulus)  
      "5D",  // + (add)  
      "5E",  // - (subtract)  
      "64",  // << (left shift)  
      "65",  // >> (right shift)  
      "6E",  // < (less than)  
      "6F",  // <= (less or equal)  
      "70",  // > (greater than)  
      "71",  // >= (greater or equal)  
      "78",  // == (equal)  
      "79",  // != (not equal)  
      "82",  // & (bitwise AND)  
      "83",  // | (bitwise OR)  
      "84",  // ^ (bitwise XOR)  
  //  "8F",  // && (logical AND)  
  //  "90",  // || (logical OR)  
      "96"   // TECHNICALLY  not an operator - but we'll consider it as one anyway; ?: (conditional jump/ternary)  
      ];
    level5.cond.OPERATOR_LABELS = [
      "++",          // 0x46  
      "--",          // 0x47  
      "~",           // 0x50  
      "!",           // 0x51  
      "*",           // 0x5A  
      "/",           // 0x5B  
      "%",           // 0x5C  
      "+",           // 0x5D  
      "-",           // 0x5E  
      "<<",          // 0x64  
      ">>",          // 0x65  
      "<",           // 0x6E  
      "<=",          // 0x6F  
      ">",           // 0x70  
      ">=",          // 0x71  
      "==",          // 0x78  
      "!=",          // 0x79  
      "&",           // 0x82  
      "|",           // 0x83  
      "^",           // 0x84  
   // "&&",          // 0x8F  
    //"||",          // 0x90  
      "?:",          // TECHNICALLY  not an operator - but we'll consider it as one anyway; 0x96  
    ] // kept seperated into 2 arrays because I didnt want to risk breaking my old code

    level5.cond.dataTypes = [
      "int8", // 0 (char)
      "uint8", // 1 (uchar)
      "int16", // 2 (short)
      "uint16", // 3 (ushort)
      "int32", // 4 (int)
      "uint32", // 5 (uint)
      "float", // 6 float32 (float)
      // rest are unknown rn
    ]
    level5.cond.DEFAULT_OPERATOR = "=="; // kinda true, kinda wrong

    // CTYPEs
    level5.cond.CTYPES = {
      "00 13 02": "2 Param Function",
      "00 1C 03": "3 Param Function",
      "00 0A 01": "1 Param Function", // since conds dont have an array/list type there will often be functions that are just getData(int: index)
      "00 06 02": "Int",
      "00 01 00": "0 Param Function",
    }
    level5.cond.DEFAULT_CTYPE = "(00 01 00?)"; // unconfirmed
    level5.cond.isFunction = (ctype) => {
      return ctype.toUpperCase().replace(/\s+/g,"") != "000602";
    }
    level5.cond.isFunc = level5.cond.isFunction; // simple alias because I cant make up my mind :P
    // COMPARISON_VALUEs
    level5.cond.DEFAULT_COMPARISON_VALUE  = true; // (0x00000000) maybe??? confirm this
    level5.cond.COMPARISON_VALUE_LABELS = {
      "00 00 00 01": "true",
      "00 00 00 00": "false",
      "00 00 00 FF": "Special Case!", // sometimes means max, but is too situational to mention; as a QuestPhase this means quest complete
    }
    // misc
    level5.cond._internals.consumeBytes = function(hexStr, n){ const take = hexStr.slice(0, n*2); const rest = hexStr.slice(n*2); return [rest, take.toUpperCase()]; };
    level5.cond._internals.startsWith = function(hexStr, prefix){ return hexStr.slice(0, prefix.length).toUpperCase() === prefix.toUpperCase(); };

    level5.cond.parsev3Cond = function(inputHex){
      const $ = level5.cond._internals;
      let hex = (inputHex||'').replace(/\s+/g,'').toUpperCase();
      const parsedCond = [];
      function err(msg, hexSuffix){ const ctx = hexSuffix ? (' (next: '+hexSuffix+')') : ''; throw new SyntaxError(msg + ctx); }

      function parseHeader(){ if(hex.length < 12) err('Too short for header+condcode', hex.slice(0,12)); if(!$.startsWith(hex,'00000000')) err('Are you sure this is a real cond? Header invalid (expected 00000000)'); let consumed; [hex, consumed] = $.consumeBytes(hex,4); const headerBlock = [['HEADER', consumed]]; [hex, consumed] = $.consumeBytes(hex,2); headerBlock.push(['COND_CODE', consumed]); parsedCond.push(['HEADER_BLOCK', headerBlock]); }

      function parseClause(){ 
        if(hex.length < 2) err('Unexpected EOF while expecting READ_MEMORY or READ_LITERAL');
        // add operator check?

        if ( // done past me :P
          !$.startsWith(hex, level5.cond.READ_MEMORY) &&
          !$.startsWith(hex, level5.cond.READ_LITERAL) &&
          !level5.cond.OPERATORS.includes(hex.slice(0, 2))
        ) {
          err('Clause must start with READ_MEMORY, READ_LITERAL, or OPERATOR', hex.slice(0,2));
        }

        // handle OPERATOR as a clause starter
        if (level5.cond.OPERATORS.includes(hex.slice(0, 2))) {
          const clause = [];
          let consumed;
          [hex, consumed] = $.consumeBytes(hex, 1);
          clause.push(['OPERATOR', consumed]);
          
          // optional: operators might be followed by another READ_MEMORY / READ_LITERAL clause
          if ($.startsWith(hex, level5.cond.READ_MEMORY) || $.startsWith(hex, level5.cond.READ_LITERAL)) {
            // Recursively parse the next clause
            parsedCond.push(['CONDITION', clause]);
            parseClause();
            return;
          }
          
          // otherwise just treat it as a standalone operator clause
          parsedCond.push(['CONDITION', clause]);
          return;
        }
        // temp READ_LITERAL logic; might not work in all cases; I should add V2 fallback parsing

        if($.startsWith(hex, level5.cond.READ_LITERAL)){
          const clause = []; let consumed;
          [hex, consumed] = $.consumeBytes(hex,1); clause.push(['READ_LITERAL', consumed]);
          if(hex.length < 8) err('Truncated COMPARISON_VALUE', hex.slice(0,8));
          [hex, consumed] = $.consumeBytes(hex,4); clause.push(['COMPARISON_VALUE', consumed]);
          if(hex.length < 2) err('Unexpected EOF after COMPARISON_VALUE');
        
          if($.startsWith(hex, level5.cond.READ_LITERAL)){
              [hex, consumed] = $.consumeBytes(hex,1); clause.push(['READ_LITERAL', consumed]);
              parsedCond.push(['CONDITION', clause]);  
              return;
          }
        
          if($.startsWith(hex, level5.cond.READ_MEMORY)){
              parsedCond.push(['CONDITION', clause]); 
              parseClause();                          
              return; // A.
          }

          if ($.startsWith(hex, level5.cond.EOCI)) {
            console.warn("c")
            parsedCond.push(['CONDITION', clause]); // this 
             return;
          }

          if(level5.cond.OPERATORS.includes(hex.slice(0,2))){
            [hex, consumed] = $.consumeBytes(hex,1); clause.push(['OPERATOR', consumed]); 
            parsedCond.push(['CONDITION', clause]); return;
          } // e.


          err('Expected READ_LITERAL or READ_MEMORY after COMPARISON_VALUE', hex.slice(0,2));
        }
        if(!$.startsWith(hex, level5.cond.READ_MEMORY)) err('Clause must start with READ_MEMORY', hex.slice(0,2)); 
        const clause = []; let consumed; 
        [hex, consumed] = $.consumeBytes(hex,1); clause.push(['READ_MEMORY', consumed]); 
        if(hex.length < 8) err('Truncated RESOURCE_ID_A', hex.slice(0,8)); 
        [hex, consumed] = $.consumeBytes(hex,4); clause.push(['RESOURCE_ID_A', consumed]); 
        if(hex.length < 6) err('Truncated CTYPE_A', hex.slice(0,6)); 
        [hex, consumed] = $.consumeBytes(hex,3); clause.push(['CTYPE_A', consumed]);
      
        while(hex.length > 0){ 
          const nextByte = hex.slice(0,2);
          if($.startsWith(hex, level5.cond.UPRM)) {
          const clause = []; let consumed;
          [hex, consumed] = $.consumeBytes(hex,1); clause.push(['UPRRM', consumed]);
          }
          if($.startsWith(hex, level5.cond.READ_LITERAL)){
            [hex, consumed] = $.consumeBytes(hex,1); clause.push(['READ_LITERAL', consumed]); 
            if(hex.length < 8) err('Expected COMPARISON_VALUE after READ_LITERAL', hex.slice(0,8));
            [hex, consumed] = $.consumeBytes(hex,4); clause.push(['COMPARISON_VALUE', consumed]); 
if (hex.length === 0) {// no I did not copy this from a different version of my parser - why would you assume that? :P
  // end-of-input: finish condition
  parsedCond.push(['CONDITION', clause]);
  return;
}

if (hex.length < 2) {
  // still an unexpected truncated byte (unlikely because we handled length === 0 above)
  err('After COMPARISON_VALUE found unexpected truncated byte', hex.slice(0,2));
}

const afterComp = hex.slice(0,2);

// Another READ_LITERAL after the comparison indicates another comparison follows.
// do NOT consume the READ_LITERAL here because top-level parsing expects to see READ_LITERAL and will consume it :<
if ($.startsWith(hex, level5.cond.READ_LITERAL)) {
  // allow the parse to loop so the subsequent COMPARISON_VALUE is handled normally (fancy words :0 lol)
  continue;
}

// OPERATOR -> consume it and finish this condition
if (level5.cond.OPERATORS.includes(afterComp)) {
  [hex, consumed] = $.consumeBytes(hex,1);
  clause.push(['OPERATOR', consumed]);
  parsedCond.push(['CONDITION', clause]);
  return;
}
// EOCI -> consume and finish this condition
if ($.startsWith(hex, level5.cond.EOCI)) {
//  [hex, consumed] = $.consumeBytes(hex,1);
//  clause.push(['EOCI', consumed]);
  parsedCond.push(['CONDITION', clause]);
  return;
}

// AEOCI -> consume and finish this condition
if ($.startsWith(hex, level5.cond.AEOCI)) {
  parsedCond.push(['CONDITION', clause]);
  return;
}
if($.startsWith(hex, level5.cond.UPRM)) { // just in case - this has never been proved to actually occur 
  const clause = []; let consumed;
  [hex, consumed] = $.consumeBytes(hex,1); clause.push(['UPRRM', consumed]);
}

// READ_MEMORY -> do NOT consume it here; close this condition and let the outer loop handle the new clause
if ($.startsWith(hex, level5.cond.READ_MEMORY)) {
  parsedCond.push(['CONDITION', clause]);
  return;
}

// Otherwise it's still unexpected
err('After COMPARISON_VALUE expected READ_LITERAL, OPERATOR, EOCI, READ_MEMORY, or end-of-input but found', afterComp);

          }
          else if($.startsWith(hex, level5.cond.EXTENSION_DELIM)){
            [hex, consumed] = $.consumeBytes(hex,1); clause.push(['EXTENSION_DELIM', consumed]); 
            if(hex.length < 6) err('Expected CTYPE_B after EXTENSION_DELIM', hex.slice(0,6)); 
            [hex, consumed] = $.consumeBytes(hex,3); clause.push(['CTYPE_B', consumed]); 
            continue;
          }
          else if($.startsWith(hex, level5.cond.READ_SUBSECTION)){
            [hex, consumed] = $.consumeBytes(hex,1); clause.push(['READ_SUBSECTION', consumed]); 
            if(hex.length < 8) err('Expected RESOURCE_ID_B after READ_SUBSECTION', hex.slice(0,8)); 
            [hex, consumed] = $.consumeBytes(hex,4); clause.push(['RESOURCE_ID_B', consumed]); 
            continue;
          }
          else if(level5.cond.OPERATORS.includes(nextByte)){
            [hex, consumed] = $.consumeBytes(hex,1); clause.push(['OPERATOR', consumed]); 
            parsedCond.push(['CONDITION', clause]); return;
          } else if($.startsWith(hex, level5.cond.EOCI)){
          //  [hex, consumed] = $.consumeBytes(hex,1); clause.push(['EOCI', consumed]); 
            parsedCond.push(['CONDITION', clause]); return;
          } else if($.startsWith(hex, level5.cond.AEOCI)){ 
            parsedCond.push(['CONDITION', clause]);
            return;
          }  else if($.startsWith(hex, level5.cond.READ_MEMORY)){
              parsedCond.push(['CONDITION', clause]); 
              parseClause();                          
              return;
          } else {
            parsedCond.push(['CONDITION', clause]); return;
            err('Unknown byte in CLAUSE (unable to progress parse)', nextByte);
          }
        }

        /*
                  if
              */
        // fallback: push clause even if there isnt a OPERATOR but complain (7 warns if you're debugging this oh and sorry for your loss...)
        console.warn("no OPERATOR :<<<" + clause);
                console.warn("no OPERATOR :<<<" + clause);
                        console.warn("no OPERATOR :<<<" + clause);
                                console.warn("no OPERATOR :<<<" + clause);
                                        console.warn("no OPERATOR :<<<" + clause);
                                                console.warn("no OPERATOR :<<<" + clause);
                                                        console.warn("no OPERATOR :<<<" + clause);

        parsedCond.push(['CONDITION', clause]); 
        return;
      }


      // top-level header - not per condition but per cond; I totally didnt forget about the strict checks here which made me feel so delusional as I kept refreshing an earlier patch but nothing changed lmao
      parseHeader();
while (hex.length > 0) {
  let z;

  // Case 1: starts with AOECI
  if ($.startsWith(hex, level5.cond.AEOCI)) {
    [hex, z] = $.consumeBytes(hex, 1);
    parsedCond.push(['AEOCI', z]);
    continue; // B.
  }

    // Case 1: starts with EoCI
  if ($.startsWith(hex, level5.cond.EOCI)) {
    [hex, z] = $.consumeBytes(hex, 1);
    parsedCond.push(['EOCI', z]);
    continue; // B.
  }

  // Case 2: Expect READ_MEMORY, READ_LITERAL, or OPERATOR at top level
  if (
    !$.startsWith(hex, level5.cond.READ_MEMORY) &&
    !$.startsWith(hex, level5.cond.READ_LITERAL) &&
    !level5.cond.OPERATORS.includes(hex.slice(0, 2))
  ) {
    err('Expected READ_MEMORY, READ_LITERAL, or OPERATOR at top-level but found', hex.slice(0, 8));
  }


  // Parse clause
  parseClause();

  // Case 3: End of clause indicator
  if ($.startsWith(hex, level5.cond.EOCI)) {
    let c;
    [hex, c] = $.consumeBytes(hex, 1);
    parsedCond.push(['EOCI', c]);
    continue;
  }

  // Case 1: starts with AOECI
  if ($.startsWith(hex, level5.cond.AEOCI)) {
    [hex, z] = $.consumeBytes(hex, 1);
    parsedCond.push(['AEOCI', z]);
    continue; // B.
  }
  // Case 4: End or trailing bytes
  if (hex.length === 0) break;
  if (!$.startsWith(hex, level5.cond.READ_MEMORY) && !$.startsWith(hex, level5.cond.READ_LITERAL)) {
    err('Trailing/Unexpected bytes after clause(s)', hex.slice(0, 8));
  }
}
console.log("parsed cond", parsedCond);
      return parsedCond;
    };
 
    function labelForCompVal(hexBytes){ // d.
      const spaced = hexSpaced(hexBytes.toUpperCase().replace(/\s+/g,''));
      return level5.cond.COMPARISON_VALUE_LABELS[spaced] ?? Number("0x" + spaced);
    }
    // ---- render helpers ----
    function labelForResource(hexBytes){ // hexBytes are expected to be formatted as 'AABBCCDD' or 'AA BB CC DD'
      const spaced = hexSpaced(hexBytes.toUpperCase().replace(/\s+/g,''));
      return knownResourceIDs[spaced];
    }
    function descriptionForResource(hexBytes){ // hexBytes are expected to be formatted as 'AABBCCDD' or 'AA BB CC DD'
      const spaced = hexSpaced(hexBytes.toUpperCase().replace(/\s+/g,''));
      return level5.cond._manual[spaced] ?? knownResourceIDs[spaced];
    }


    function labelForOperator(opByte) {
      const ops = Object.fromEntries(level5.cond.OPERATORS.map((op, i) => [op, level5.cond.OPERATOR_LABELS[i]]));
      return ops[opByte.toUpperCase()] || null;
    }

  function labelForCType(ctypeBytes) {
    const ctypes = level5.cond.CTYPES;
    const spaced = hexSpaced(ctypeBytes.toUpperCase().replace(/\s+/g, '')); // normalise input
    return ctypes[spaced] || null;
  }

// Updated renderParsed: generates tree + test C-like pseudo output
function renderParsed(parsed) {
  const tree = document.getElementById('tree');
  tree.innerHTML = '';
  const pseudo = document.getElementById('pseudo');
  pseudo.textContent = '';

  let seenHeader = false; // avoid duplicating header printing

  parsed.forEach(node => {
    const type = node[0];

    // --- HEADER_BLOCK (unchanged for tree) ---
    if (type === 'HEADER_BLOCK') {
      const wrap = document.createElement('div');
      wrap.className = 'node';
      wrap.innerHTML = '<strong>HEADER</strong> <span class="small muted">(header + condcode)</span>';

      const inner = document.createElement('div');
      inner.className = 'small muted';
      node[1].forEach(x => {
        inner.innerHTML += '<div>' + x[0] + ': <span class="label">' + hexSpaced(x[1]) + '</span></div>';
      });
      wrap.appendChild(inner);
      tree.appendChild(wrap);

      // print header/condCode only once (keep as comment in pseudo)
      if (!seenHeader) {
    //    pseudo.textContent += '// #header ' + hexSpaced(node[1][0][1]) + '\n';
     //   pseudo.textContent += '// #condCode ' + hexSpaced(node[1][1][1]) + '\n\n';
        seenHeader = true;
      }
    }

    // --- CONDITION (unchanged for tree) ---
    else if (type === 'CONDITION') {
      const clause = node[1];
      const wrap = document.createElement('div');
      wrap.className = 'node';
      wrap.innerHTML = '<strong>CONDITION</strong>';

      const inner = document.createElement('div');
      inner.className = 'small muted';
      clause.forEach(f => {
        const name = f[0];
        const val = f[1];
        let lbl = null;
        if (name.startsWith('RESOURCE_ID')) lbl = descriptionForResource(val);
        else if (name.startsWith('COMPARISON_VALUE')) lbl = labelForCompVal(val);
        else if (name.startsWith('CTYPE')) lbl = labelForCType(val);
        else if (name === 'OPERATOR') lbl = labelForOperator(val);

        inner.innerHTML +=
          '<div><strong>' + name + '</strong>: <span class="label">' +
          hexSpaced(val) + '</span>' +
          (lbl ? (' <span class="small muted"> — ' + lbl + '</span>') : '') +
          '</div>';
      });

      wrap.appendChild(inner);
      tree.appendChild(wrap);
    }

    // --- EOCI / AEOCI / other types still rendered in tree ---
    else if (type === 'EOCI' || type === 'AEOCI') {
      const wrap = document.createElement('div');
      wrap.className = 'node';
      wrap.innerHTML = `<strong>${type}</strong>: <span class="label">${hexSpaced(node[1])}</span>`;
      tree.appendChild(wrap);
    }

    else {
      // Other node types: show in tree only
      const wrap = document.createElement('div');
      wrap.className = 'node small muted';
      wrap.textContent = type + ' (ignored in pseudo)';
      tree.appendChild(wrap);
    }
  });

  // --- PSEUDO GENERATION ---
  // Use level5.cond.condToC for the entire parsed structure
  try {
    const generatedPseudo = level5.cond.condToC(parsed);
    pseudo.textContent += generatedPseudo + '\n';
  } catch (err) {
    console.error('condToC failed:', err);
    pseudo.textContent += '/* condToC parse error */\n';
  }
}

// basic attempt at cond -> C
level5.cond.condToC = function(parsedArray) { // this was so difficult to finish........ WHY LEVEL5, WH- ok no this is actually an epic, cool system I love this; GBHJKIUHGBNMOI\GRUOWRIPHRSUIZEADSLSFKNM
  const norm = s => String(s || '').replace(/\s+/g, '').toUpperCase();

  const opMap = { // temporarily separated from the main logic until I fix the parser
    '46': '++','47': '--','50': '~','51': '!',
    '5A': '*','5B': '/','5C': '%','5D': '+','5E': '-',
    '64': '<<','65': '>>','6E': '<','6F': '<=','70': '>','71': '>=',
    '78': '==','79': '!=','82': '&','83': '|','84': '^',
    '8F': '&&','90': '||','96': '?:'
  };
  function mapOperator(hexOrSymbol) {
    if (hexOrSymbol === undefined || hexOrSymbol === null) return '??';
    const s = String(hexOrSymbol);
    if (/^[\!\=\&\|\+\-\*\/<>%\^~?:]+$/.test(s)) return s;
    const h = norm(s);
    return opMap[h] || s;
  }

  // render helpers
  function renderValue(node) {
    if (!node) return '/*null*/';
    if (typeof node === 'string') return node;
    if (node.type === 'LITERAL') return node.val;
    if (node.type === 'GROUP' && node.kind === 'ADDITION') return '(' + node.items.map(renderValue).join(' + ') + ')';
    if (node.type === 'FUNCTION') {
      const args = node.params.map(p => p == null ? '/*?*/' : renderValue(p)).join(', ');
      if(level5.cond.CExpressionInternalMappings[node.id.match(/../g).join(" ")]) return level5.cond.CExpressionInternalMappings[node.id.match(/../g).join(" ")] + `(${args})`;
      return `FUNC_${node.id}(${args})`;
    }
    if (node.type === 'EXPR') return node.expr;
    return String(node);
  }

  // parseValue consumes tokens starting at i; returns { node, nextIndex }
  function parseValue(flat, i) {
    const key = String(flat[i][0] || '').toUpperCase();
    const raw = flat[i][1];

    // READ_LITERAL + optional COMPARISON_VALUE
    if (key === 'READ_LITERAL' || key === '32') {
      const next = flat[i + 1];
      if (next) {
        const nk = String(next[0] || '').toUpperCase();
        if (nk.includes('COMPAR')) {
          const hex = norm(next[1] || '0');
          const num = parseInt(hex || '0', 16);
          const val = (num === 1) ? 'true' : (num === 0 ? 'false' : String(num));
          return { node: { type: 'LITERAL', val }, nextIndex: i + 2 };
        }
      }
      const hex = norm(raw || '0');
      const num = parseInt(hex || '0', 16);
      const val = (num === 1) ? 'true' : (num === 0 ? 'false' : String(num));
      return { node: { type: 'LITERAL', val }, nextIndex: i + 1 };
    }

    // direct COMPARISON_VALUE
    if (key.includes('COMPAR')) {
      const hex = norm(raw || '0');
      const num = parseInt(hex || '0', 16);
      const val = (num === 1) ? 'true' : (num === 0 ? 'false' : String(num));
      return { node: { type: 'LITERAL', val }, nextIndex: i + 1 };
    }

    // READ_SUBSECTION: by default may be a nested FUNCTION(resource), but caller can request literal parsing
    if (key === 'READ_SUBSECTION' || key === '34') {
      const next = flat[i + 1];
      if (next && String(next[0] || '').toUpperCase().includes('RESOURCE')) {
        const id = norm(next[1] || '');
        if (/^[0-9A-F]{8,}$/.test(id)) return { node: { type: 'FUNCTION', id, params: [] }, nextIndex: i + 2 };
      }
      return { node: { type: 'LITERAL', val: 'SUBSECTION_UNKNOWN' }, nextIndex: i + 1 };
    }

    // READ_MEMORY: function/resource detection; this was the BIGGEST PAIN EVER TO IMPLEMENTBDFGUIJADFILHFDS\UD\FSIH;IDSFOUOUDSFHUPSDFOUHDSFBSFUAUSDHIADFHOIHFDS
    if (key === 'READ_MEMORY' || key === '35') {
      // locate resource and ctype nearby
      let ridIdx = -1, ctypeIdx = -1;
      for (let j = i + 1; j <= i + 6 && j < flat.length; j++) {
        const kj = String(flat[j][0] || '').toUpperCase();
        if (ridIdx === -1 && kj.includes('RESOURCE')) ridIdx = j;
        if (ctypeIdx === -1 && kj.includes('CTYPE')) ctypeIdx = j;
      }

      if (ridIdx !== -1) {
        const resourceId = norm(flat[ridIdx][1] || '');
        const ctypeRaw = ctypeIdx !== -1 ? norm(flat[ctypeIdx][1] || '') : null;

        // If ctype exists and is NOT a function -> resource as literal hex
        if (ctypeRaw && !level5.cond.isFunction(ctypeRaw)) {
          const lit = { type: 'LITERAL', val: `0x${resourceId}` };
          const nextIndex = Math.max(ridIdx, ctypeIdx) + 1;
          return { node: lit, nextIndex };
        }

        // Otherwise its..... you guessed it! a function
        let paramCount = 0;
        if (ctypeRaw) {
          const lastByte = ctypeRaw.slice(-2) || '00';
          paramCount = Number('0x' + lastByte) || 0;
        }
        const funcNode = { type: 'FUNCTION', id: resourceId, params: new Array(paramCount).fill(null) };
        let cursor = Math.max(ridIdx, ctypeIdx !== -1 ? ctypeIdx : ridIdx) + 1;

        for (let p = 0; p < paramCount; p++) {
          if (cursor >= flat.length) break;

          // detect explicit CTYPE token for this param
          let localCtype = null;
          if (String(flat[cursor][0] || '').toUpperCase().includes('CTYPE')) {
            localCtype = norm(flat[cursor][1] || '');
            cursor++;
          }

          // handle EXTENSION_DELIM if present
          if (cursor < flat.length && (String(flat[cursor][0] || '').toUpperCase() === 'EXTENSION_DELIM' || String(flat[cursor][1]) === '28')) {
            cursor++;
            if (cursor < flat.length && String(flat[cursor][0] || '').toUpperCase().includes('CTYPE')) {
              localCtype = norm(flat[cursor][1] || '');
              cursor++;
            }
          }

          // IMPORTANT: if localCtype indicates non-function, parse next tokens as LITERAL if possible
          if (localCtype && !level5.cond.isFunction(localCtype)) {
            if (cursor < flat.length) {
              const litRes = parseAsLiteralIfPossible(flat, cursor);
              if (litRes) {
                funcNode.params[p] = litRes.node;
                cursor = litRes.nextIndex;
                continue;
              }
              // fallback to parseValue if special-case didn't match
              const res = parseValue(flat, cursor);
              funcNode.params[p] = res.node;
              cursor = res.nextIndex;
              continue;
            } else {
              funcNode.params[p] = { type: 'LITERAL', val: '/*?*/' };
              break;
            }
          } else {
            // localCtype indicates a function (or absent) -> parse normally (may produce FUNCTION node)
            if (cursor < flat.length) {
              const res = parseValue(flat, cursor);
              funcNode.params[p] = res.node;
              cursor = res.nextIndex;
              continue;
            } else {
              funcNode.params[p] = { type: 'LITERAL', val: '/*?*/' };
              break;
            }
          }
        }
        return { node: funcNode, nextIndex: cursor };
      }

      // fallback: next token may be raw hex id
      const nextToken = flat[i + 1];
      const att = nextToken ? norm(nextToken[1] || '') : '';
      if (/^[0-9A-F]{8,}$/.test(att)) return { node: { type: 'FUNCTION', id: att, params: [] }, nextIndex: i + 2 };
      return { node: { type: 'LITERAL', val: 'FUNC_UNKNOWN' }, nextIndex: i + 1 };
    }

    // RESOURCE token alone
    if (key.includes('RESOURCE')) {
      const id = norm(raw || '');
      if (/^[0-9A-F]{8,}$/.test(id)) return { node: { type: 'FUNCTION', id, params: [] }, nextIndex: i + 1 };
    }

    // fallback literal
    return { node: { type: 'LITERAL', val: String(raw) }, nextIndex: i + 1 };
  } // end parseValue

  // helper: try to parse a literal form (resource/subsection/literal) starting at cursor
  // returns { node, nextIndex } or null if it couldn't recognize a simple literal
  function parseAsLiteralIfPossible(flat, cursor) {
    if (cursor >= flat.length) return null;
    const tk = String(flat[cursor][0] || '').toUpperCase();
    const tv = flat[cursor][1];

    // READ_SUBSECTION + RESOURCE -> literal hex
    if (tk === 'READ_SUBSECTION' || tk === '34') {
      const next = flat[cursor + 1];
      if (next && String(next[0] || '').toUpperCase().includes('RESOURCE')) {
        const id = norm(next[1] || '');
        if (/^[0-9A-F]{8,}$/.test(id)) {
          return { node: { type: 'LITERAL', val: `0x${id}` }, nextIndex: cursor + 2 };
        }
      }
    }

    // RESOURCE token directly -> literal hex
    if (tk.includes('RESOURCE')) {
      const id = norm(tv || '');
      if (/^[0-9A-F]{8,}$/.test(id)) {
        return { node: { type: 'LITERAL', val: `0x${id}` }, nextIndex: cursor + 1 };
      }
    }

    // READ_LITERAL + COMPARISON_VALUE -> literal true/false/number
    if (tk === 'READ_LITERAL' || tk === '32') {
      const next = flat[cursor + 1];
      if (next) {
        const nk = String(next[0] || '').toUpperCase();
        if (nk.includes('COMPAR')) {
          const hex = norm(next[1] || '0');
          const num = parseInt(hex || '0', 16);
          const val = (num === 1) ? 'true' : (num === 0 ? 'false' : String(num));
          return { node: { type: 'LITERAL', val }, nextIndex: cursor + 2 };
        }
      }
      // fallback numeric literal from raw
      const hex = norm(tv || '0');
      if (/^[0-9A-F]+$/.test(hex)) {
        const num = parseInt(hex || '0', 16);
        return { node: { type: 'LITERAL', val: String(num) }, nextIndex: cursor + 1 };
      }
    }

    // COMPARISON_VALUE alone
    if (tk.includes('COMPAR')) {
      const hex = norm(tv || '0');
      const num = parseInt(hex || '0', 16);
      const val = (num === 1) ? 'true' : (num === 0 ? 'false' : String(num));
      return { node: { type: 'LITERAL', val }, nextIndex: cursor + 1 };
    }

    // couldn't produce a literal
    return null;
  }

  // helper: consume valueStack for operator (last=right, second-last=left, group for 3+)
  const comparisonOps = new Set(['==','!=','<','<=','>','>=']);
  function consumeForOperator(valueStack, opSymbol) {
    const len = valueStack.length;
    let leftNode, rightNode;

    if (len === 0) {
      leftNode = { type: 'LITERAL', val: '0' };
      rightNode = { type: 'LITERAL', val: '1' };
      valueStack.length = 0;
    } else if (len === 1) {
      leftNode = valueStack.pop();
      rightNode = { type: 'LITERAL', val: '1' };
    } else if (len === 2) {
      rightNode = valueStack.pop();
      leftNode = valueStack.pop();
    } else {
      rightNode = valueStack.pop();
      leftNode = { type: 'GROUP', kind: 'ADDITION', items: valueStack.splice(0) };
    }

    const exprStr = `(${renderValue(leftNode)} ${opSymbol} ${renderValue(rightNode)})`;
    return { type: 'EXPR', expr: exprStr, leftNode, rightNode };
  }

  // Step 1: header comments
  const outLines = [];
  for (const blk of parsedArray) {
    if (String(blk[0] || '').toUpperCase() === 'HEADER_BLOCK') {
     // outLines.push('// Header');
      for (const it of (blk[1] || [])) {
        outLines.push(`// ${it[0]}: ${it[1]}`);
        if(it[0] == 'COND_CODE') outLines.push('\n'); // seperate headers and stuff; im too lazy to implement this properly
      }
    }
  }

  // Step 2: process top-level entries, building clauses and nested structure like v6
  const clauses = [];
  const clauseCombiners = [];
  const valueStack = [];

  for (let topIdx = 0; topIdx < parsedArray.length; topIdx++) {
    const top = parsedArray[topIdx];
    const topKey = String(top[0] || '').toUpperCase();

    if (topKey === 'HEADER_BLOCK') continue;

    if (topKey === 'EOCI' || topKey === 'AEOCI') {
      clauseCombiners.push(mapOperator(top[1]));
      continue;
    }

    if (topKey === 'CONDITION') {
      const inner = top[1] || [];
      let i = 0;
      while (i < inner.length) {
        const key = String(inner[i][0] || '').toUpperCase();
        const val = inner[i][1];

        if (key === 'EXTENSION_DELIM' || String(val) === '28') { i++; continue; }

        if (key === 'OPERATOR' || (/^[0-9A-F]{2}$/.test(key) && opMap[norm(key)])) {
          const opSymbol = mapOperator(val === undefined ? key : val);
          if (comparisonOps.has(opSymbol)) {
            const node = consumeForOperator(valueStack, opSymbol);
            clauses.push(node.expr);
            valueStack.length = 0;
            i++;
            continue;
          } else {
            const node = consumeForOperator(valueStack, opSymbol);
            valueStack.push(node);
            i++;
            continue;
          }
        }

        // otherwise parse a value
        const res = parseValue(inner, i);
        valueStack.push(res.node);
        i = res.nextIndex;
      }
      continue;
    }

    // stray OPERATOR at top
    if (topKey === 'OPERATOR') {
      clauseCombiners.push(mapOperator(top[1]));
      continue;
    }
  }

  // finalize leftover valueStack as a clause if present
  if (valueStack.length > 0) {
    if (valueStack.length === 1) clauses.push(`(${renderValue(valueStack[0])} == 1)`);
    else if (valueStack.length === 2) {
      const r = valueStack.pop(); const l = valueStack.pop();
      clauses.push(`(${renderValue(l)} == ${renderValue(r)})`);
    } else {
      const r = valueStack.pop();
      const leftGroup = { type: 'GROUP', kind: 'ADDITION', items: valueStack };
      clauses.push(`(${renderValue(leftGroup)} == ${renderValue(r)})`);
    }
    valueStack.length = 0;
  }

  // render clauses: nested ifs on && (default)
 // outLines.push('// Condition'); ab.
  if (clauses.length === 0) {
    outLines.push('if (0 == 1) {', '    success();', '}');
    outLines.push('fail();'); // little last minute patch :3
    return outLines.join('\n');
  }

  const allAnd = clauseCombiners.length === 0 || clauseCombiners.every(c => c === '&&');
  if (allAnd) {
    for (let k = 0; k < clauses.length; k++) {
      const ind = '    '.repeat(k);
      outLines.push(`${ind}if ${clauses[k]} {`);
    }
    outLines.push('    '.repeat(clauses.length) + 'success();');
    for (let k = 0; k < clauses.length; k++) {
      const ind = '    '.repeat(clauses.length - 1 - k);
      outLines.push(`${ind}}`);
    }
    outLines.push('fail();'); // little last minute patch :3
    return outLines.join('\n');
  }

  // otherwise combine into single expression
  let expr = clauses[0];
  for (let idx = 0; idx < clauses.length - 1; idx++) {
    const comb = clauseCombiners[idx] || '&&';
    expr = `(${expr} ${comb} ${clauses[idx + 1]})`;
  }
  outLines.push(`if ${expr} {`, '    success();', '}');
  outLines.push('fail();'); // little last minute patch :3
  return outLines.join('\n\n');
}

    level5.cond.samples = [
                      '00 00 00 00 f0 3b 35 77 b4 63 e5 00 0a 01 28 00 06 02 32 00 00 00 01 32 00 00 00 01 78 35 77 b4 63 e5 00 0a 01 28 00 06 02 32 00 00 00 02 32 00 00 00 01 78 8f 35 77 b4 63 e5 00 0a 01 28 00 06 02 32 00 00 00 03 32 00 00 00 01 78 8f', /* random chain cond */
                      '00 00 00 00 0f 05 35 10 b1 40 96 00 01 00 32 00 00 00 01 78', /* main story completed yw2 simple format */
                      '00 00 00 00 18 05 35 2a 3d 45 43 00 0a 01 28 00 06 02 34 00 12 34 56 32 00 00 00 01 78', /* has flag 0x00123456 yw3; basic extended format */
                      '00 00 00 00 12 02 35 69 84 E3 AF 00 0A 01 28 00 06 02 34 96 49 FF 74', /* rare terminatorless and comparison valueless cond */
                      '00 00 00 00 1B 02 35 18 2B 37 5A 00 13 02 28 00 06 02 34 22 61 B7 8A 28 00 06 02 32 00 00 00 01', /* rare terminatorless cond */
                      '00 00 00 00 12 02 35 69 84 E3 AF 00 0A 01 28 00 06 02 34 0E 6B 6F 6B', /* redesign suggesting with resource ID :0 */
                      '00 00 00 00 36 05 35 74 03 A9 CE 00 1C 03 28 00 06 02 34 C1 B2 DA B7 28 00 06 02 34 8E 31 15 F3 28 00 06 02 32 00 00 0E F6 35 69 84 E3 AF 00 0A 01 28 00 06 02 34 42 6F A0 C3 8F', /* 3 resource IDs in the first condition */
                      '00 00 00 00 36 05 35 74 03 A9 CE 00 1C 03 28 00 06 02 34 C1 B2 DA B7 28 00 06 02 34 8E 31 15 F3 28 00 06 02 32 00 00 0E D8 35 69 84 E3 AF 00 0A 01 28 00 06 02 34 94 DE BD 45 8F', /* proper NEST EOCI handling in terminatorless conditions - aka just a random edge case test */
                      '00 00 00 00 48 08 35 74 03 A9 CE 00 1C 03 28 00 06 02 34 0C 24 46 3A 28 00 06 02 34 91 8A 8A 79 28 00 06 02 32 00 00 1A 9A 35 12 09 61 26 00 0A 01 28 00 06 02 32 00 00 1A A4 8F 35 69 84 E3 AF 00 0A 01 28 00 06 02 34 97 14 49 81 8F', /* chaotic best of a cond that has several edge cases for V3 parsing */
                      '00 00 00 00 18 05 35 8D 76 66 D8 00 0A 01 28 00 06 02 34 E5 96 D9 98 32 00 00 00 01 78', /* yw2 jetnayn appearcond (has bell) */
                      '00 00 00 00 09 02 35 7E E8 60 18 00 01 00', /* an extremely simple BATTLE_AI_ACT_CONDITION from yw2 */
                      'AAAAACcONd4X/hgAAQAyAAAD6HE1xlSO4wABADWF476vAAEAXTIAAAAecY8=', /* SV Snaggerjag Psychic Blasters Requirement Cond YW2 */
                      'AAAAAPA7NXe0Y+UACgEoAAYCMgAAAAEyAAAAAXg1d7Rj5QAKASgABgIyAAAAAjIAAAABeI81d7Rj5QAKASgABgIyAAAAAzIAAAABeI81d7Rj5QAKASgABgIyAAAABDIAAAABeI81d7Rj5QAKASgABgIyAAAABTIAAAABeI81d7Rj5QAKASgABgIyAAAABjIAAAABeI81d7Rj5QAKASgABgIyAAAABzIAAAABeI81d7Rj5QAKASgABgIyAAAACDIAAAABeI81d7Rj5QAKASgABgIyAAAACTIAAAABeI81d7Rj5QAKASgABgIyAAAACjIAAAABeI8=', /* hinozalls yw2 psychic blasters cond, demonstrates function calls emulating array access */
                      'AAAAAD8XMgAAAAE12ONpHwABADIAAAABeI8yAAAAAY8yAAAAATWemYSMAAoBKAAGAjQxBWKvMgAAAAJ4jzIAAAABj5A=', /* a yw3 exclusion config cond - you can tell just from the HORRIBLE stack that its from yw3 :<<< */
                      'AAAAADkONd4X/hgAAQAyAAAH0HE1npmEjAAKASgABgI0KzMh6jWemYSMAAoBKAAGAjRW3zFYXTIAAAAecY8=', /* good example of stack merging */
                      'AAAAAAIBcQ==', /* bruh */
                      'AAAAAAcDMgAAAAF4', /* bruh (but a little less) */
                    ];


    // ---- love my UI schenanamimigans ----
    const el = id => document.getElementById(id);

    function log(msg, kind){ const l = el('log'); const pfx = kind==='error'?'Error: ': kind==='warn'?'Warning: ': ''; l.textContent = pfx + msg; }

    function doParseFromInput(text){ try{ const hex = inputToHexString(text); if(!hex) { log('No input', 'warn'); return; } const parsed = level5.cond.parsev3Cond(hex); renderParsed(parsed); log('Parsed OK.'); } catch(e){ log(e.message, 'error'); console.error(e); } }

    el('parseBtn').addEventListener('click', ()=> doParseFromInput(el('input').value));
    el('parseB64Btn').addEventListener('click', ()=>{ try{ const raw = el('input').value.trim(); if(/\s/.test(raw)) throw new Error('Base64 must not contain internal whitespace'); const dec = tryDecodeBase64(raw); const hex = Array.from(dec).map(c => (typeof c==='string' ? c.charCodeAt(0) : c).toString(16).padStart(2,'0')).join('').toUpperCase(); el('input').value = hexSpaced(hex); doParseFromInput(hex); } catch(e){ log('Base64 decode failed: '+e.message,'error'); } });

       el('sampleBtn').addEventListener('click', ()=>{ // random sample list
      let samples = level5.cond.samples;
      el('input').value = samples[Math.round(Math.random() * (samples.length - 1))];
      el('parseBtn').click();
    });
    
    el('clearBtn').addEventListener('click', ()=>{ el('input').value=''; el('tree').innerHTML=''; el('pseudo').textContent=''; el('log').textContent='Ready.'; });

    el('copyPseudoBtn').addEventListener('click', ()=>{ const txt = el('pseudo').textContent; if(!txt){ log('Nothing to copy','warn'); return;} navigator.clipboard?.writeText(txt).then(()=> log('Pseudocode copied to clipboard'), ()=> log('Copy failed','warn')); });

    el('downloadBtn').addEventListener('click', ()=>{ const pseudo = el('pseudo').textContent || ''; const blob = new Blob([pseudo], { type: 'text/plain' }); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = 'cond.txt'; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url); });

    // light mode toggle
    el('lightMode').addEventListener('change', (ev)=>{ document.body.classList.toggle('light', ev.target.checked); });

  </script>
</body>
</html>
