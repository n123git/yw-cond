<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>YW-Cond - Loading Version...</title>
  <style>
    :root{
      --bg:#0f1115; --panel:#0b0d10; --text:#e6eef6; --muted:#9aa6b2; --accent:#6ea8ff; --good:#8bd18b; --bad:#ff7b7b;
    }
    body{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, monospace; margin:12px; color:var(--text); background:var(--bg);}
    .container{max-width:980px;margin:0 auto;padding:12px}
    h2{margin:0 0 8px 0}
    textarea{width:100%;min-height:120px;padding:8px;background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--text);}
    button{background:transparent;border:1px solid rgba(255,255,255,0.08);color:var(--text);padding:6px 8px;margin:4px;border-radius:6px;cursor:pointer}
    .controls{display:flex;flex-wrap:wrap;gap:6px;align-items:center;margin:8px 0}
    #log{white-space:pre-wrap;background:transparent;border:1px dashed rgba(255,255,255,0.03);padding:8px;min-height:36px;color:var(--muted)}
    .tree{background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent);padding:8px;border-radius:6px;margin-top:8px}
    .node{padding:6px;border-radius:4px;margin:2px 0;cursor:pointer}
    /* updated to work on light mode too (eugh) */
    .node:hover {
       background: rgba(255, 255, 255, 0.04);
       border: 1px solid transparent;
    }
  
    /* Light mode stuff :< */
    .light .node:hover {
      background: rgba(0, 0, 0, 0.08);
      border: 1px solid rgba(0, 0, 0, 0.08);
    }
    .light .node:active,
    .light .node.selected {
      background: rgba(0, 0, 0, 0.12);
      border: 1px solid rgba(0, 0, 0, 0.12);
    }


    .label{color:var(--accent);font-weight:600;margin-left:8px}
    .small{font-size:0.85em;color:var(--muted)}
    .muted{color:var(--muted)}
    .danger{color:var(--bad)}
    .ok{color:var(--good)}
    .pseudo{white-space:pre;background:transparent;border:1px solid rgba(255,255,255,0.03);padding:8px;border-radius:6px;margin-top:8px}

/* ====== Light Mode Enhancements ====== */
.light {
  --bg: #f4f6f8;
  --panel: #ffffff;
  --text: #222;
  --muted: #6b7280;
  --accent: #d08b00;
  --good: #16803c;
  --bad: #cc3b3b;
}

/* Give light mode a faint shadowed feel to offset white */
.light body {
  background: linear-gradient(180deg, #fafafa, #f3f4f6);
}

/* Light mode textarea and pseudo blocks pop slightly */
.light textarea,
.light .pseudo {
  background: rgba(0, 0, 0, 0.02);
  border-color: rgba(0, 0, 0, 0.1);
}

/* Buttons and selects look more tactile in light mode */
.light button,
.light select {
  background: rgba(0, 0, 0, 0.02);
  border-color: rgba(0, 0, 0, 0.1);
}

.light button:hover,
.light select:hover {
  background: rgba(0, 0, 0, 0.06);
  border-color: rgba(0, 0, 0, 0.18);
}

    /* modal basics */
    dialog{border:1px solid rgba(0,0,0,0.08);background:var(--panel);color:var(--text);padding:12px;border-radius:8px}
    label{display:inline-block}
    input{padding:6px;border-radius:6px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:var(--text)}

    /* gotta add select/option CSS too */

    select { /* chevron sounds so fancy */
      padding: 6px;
      border-radius: 6px;
      border: 1px solid rgba(255, 255, 255, 0.04);
      background: transparent;
      color: var(--text);
      font-family: inherit;
      font-size: 0.95em;
      cursor: pointer;
      appearance: none; /* remove native arrow (for custom look) */
      background-image: linear-gradient(45deg, transparent 50%, var(--muted) 50%),
                        linear-gradient(135deg, var(--muted) 50%, transparent 50%);
      background-position: calc(100% - 16px) center, calc(100% - 12px) center;
      background-size: 5px 5px, 5px 5px;
      background-repeat: no-repeat;
      padding-right: 28px; /* space for arrow */
      transition: border-color 0.2s, background-color 0.2s;
    }
    
    select:hover, select:focus {
      border-color: rgba(255, 255, 255, 0.12);
      background-color: rgba(255, 255, 255, 0.02);
      outline: none;
    }
    
    option {
      background: var(--panel);
      color: var(--text);
      font-family: inherit;
    }

/* ====== Global smooth transitions ====== */
* {
  transition: background 0.25s ease, border-color 0.25s ease,
              color 0.25s ease, box-shadow 0.25s ease,
              transform 0.2s ease;
}

/* Button hover animation */
button:hover {
  background: rgba(255, 255, 255, 0.05);
  transform: translateY(-1px);
  box-shadow: 0 2px 4px rgba(0,0,0,0.2);
}
button:active {
  transform: translateY(0);
  box-shadow: none;
}

/* In light mode */
.light button:hover {
  background: rgba(0, 0, 0, 0.06);
  transform: translateY(-1px);
  box-shadow: 0 2px 6px rgba(0,0,0,0.15);
}

/* Node hover glow */
.node {
  transition: background 0.25s ease, transform 0.2s ease, border-color 0.25s ease;
}
.node:hover {
  transform: scale(1.01);
  background: rgba(255, 255, 255, 0.05);
}
.light .node:hover {
  background: rgba(0, 0, 0, 0.05);
}

/* Tree entry selection feedback */
.node.selected {
  border: 1px solid var(--accent);
  background: rgba(110, 168, 255, 0.1);
}

.light textarea:focus {
  box-shadow: 0 0 0 3px rgba(208, 139, 0, 0.2);
}

/* Pseudo-code block hover motion */
.pseudo:hover {
  transform: scale(1.01);
  border-color: rgba(255,255,255,0.08);
}
.light .pseudo:hover {
  border-color: rgba(0,0,0,0.1);
}



/*a*/
/* === 1. Accent glow only on labels (not on nodes) === */
@keyframes glow {
  0%, 100% { text-shadow: 0 0 4px var(--accent); }
  50%      { text-shadow: 0 0 10px var(--accent); }
}

.label:hover {
  animation: glow 1.5s ease-in-out infinite alternate;
}

/* Prevent nodes from glowing */
.node:hover, .node.selected {
  text-shadow: none;
}


/* === 2. Modal (dialog) Styling === */
dialog {
  border: 1px solid rgba(255,255,255,0.08);
  background: var(--panel);
  color: var(--text);
  padding: 16px 20px;
  border-radius: 10px;
  box-shadow: 0 12px 24px rgba(0,0,0,0.4);
  transition: transform 0.25s ease, opacity 0.25s ease;
  transform: translateY(-8px);
  opacity: 0;
}

dialog[open] {
  transform: translateY(0);
  opacity: 1;
}

/* Backdrop blur for modern feel */
dialog::backdrop {
  backdrop-filter: blur(4px) brightness(0.9);
  background: rgba(0,0,0,0.4);
}

/* Light mode dialog contrast */
.light dialog {
  border-color: rgba(0,0,0,0.08);
  box-shadow: 0 12px 24px rgba(0,0,0,0.15);
}

.light dialog::backdrop {
  backdrop-filter: blur(4px) brightness(1.05);
  background: rgba(255,255,255,0.45);
}

/* Modal buttons alignment */
dialog button {
  background: var(--panel);
  border-color: rgba(255,255,255,0.08);
}
dialog button:hover {
  background: rgba(255,255,255,0.06);
}
.light dialog button:hover {
  background: rgba(0,0,0,0.05);
}


/* === 3. Remove the bright blue focus ring & unify textarea focus === */
.param-input,
textarea,
select {
  outline: none;
  transition: border-color 0.25s ease, box-shadow 0.25s ease, transform 0.25s ease;
}

.param-input:focus,
textarea:focus,
select:focus {
  border-color: var(--accent);
  box-shadow: 0 0 0 3px color-mix(in srgb, var(--accent) 40%, transparent);
  transform: scale(1.01);
}

.light .param-input:focus,
.light textarea:focus,
.light select:focus {
  box-shadow: 0 0 0 3px color-mix(in srgb, var(--accent) 30%, transparent);
}


  </style>
</head>
<body>
  <div class="container" id="app">
    <h2>Yo-kai Watch Cond Parser <span class="small" id="ver2">Version Loading...</span></h2>
    <div class="small muted">Paste hex (spaced/continuous) or Base64. Parser uses V3 parsing.</div>

    <textarea id="input" placeholder="Paste hex (e.g. '00 0A 01') or base64 here"></textarea>

    <div class="controls">
      <button id="parseBtn">Parse</button>
      <button id="parseB64Btn">Toggle Format</button>
      <button id="sampleBtn">Load Sample</button>
    <!--  <button id="clearBtn">Clear</button> removed to save UI space and in favour of Parse auto clearing if the input is empty -->
      <button id="copyPseudoBtn">Copy Pseudocode</button>
      <button id="downloadBtn">Download Pseudocode</button>
      <button id="generateBtn">Generate Cond Template(s)</button> <!-- rename Generate Known Cond(s) to Generate Cond Template(s)-->
      <button id="configBtn">Config</button>
      <!-- <label class="small muted" style="margin-left:8px"><input type="checkbox" id="lightMode"> Light mode</label> removed to save UI space and in favour of config-->
    </div>

    <div id="log" aria-live="polite">Ready.</div>

    <div style="display:flex;gap:12px;margin-top:12px;align-items:flex-start">
      <div style="flex:1">
        <div class="tree" id="tree" role="region" aria-label="Parsed tree"></div>
      </div>
      <div style="width:46%">
        <div class="pseudo" id="pseudo"></div>
      </div>
    </div>

    <dialog id="generateModal">
      <h3>Generate Cond Template(s)</h3> <!-- rename Generate Known Cond(s) to Generate Cond Template(s)-->
      <label>Condition: <select id="condSelect"></select></label>
      <div id="extraInputs"></div>
      <div style="margin-top:10px"><button id="generateCondBtn">Generate</button> <button id="closeModalBtn">Cancel</button></div>
    </dialog>
  </div>

  <dialog id="configModal">
  <h3>Config!!!</h3>
  <h4 style="margin-top:10px; margin-bottom:6px; color:var(--accent);">QOL Tweaks</h4>

  <div style="margin-top:6px">
    <label style="display:block; margin-bottom:8px;">
      <input type="checkbox" id="showBoolChk"> 
      <strong>Detect Bool-like Values</strong> — display <code>1</code> / <code>0</code> as <code>true</code> / <code>false</code>.
    </label>

    <label style="display:block; margin-bottom:8px;">
      <input type="checkbox" id="showPowChk"> 
      <strong>Show Key Powers of 2</strong> — display power-of-two values (≥16) as hex (<code>0x</code>...).
    </label>

    <label style="display:block; margin-bottom:8px;">
      <input type="checkbox" id="showLimChk"> 
      <strong>Show Special Values</strong> — display max/special values as hex i.e. <code>255</code> = <code>0xFF</code>, <code>65535</code> = <code>0xFFFF</code>, etc.
    </label>
  </div>
  
  <h4 style="margin-top:10px; margin-bottom:6px; color:var(--accent);">Appearence</h4>

  <div style="margin-top:6px">
  <label style="display:block; margin-bottom:8px;">
    <input type="checkbox" id="lightMode"> 
    <strong>Light Mode</strong> — toggle light/dark theme for the UI (trust me; dark mode is better :P).
  </label>
</div>

  <div style="margin-top:12px">
    <button id="configSaveBtn">Confirm</button>
    <button id="configCancelBtn">Cancel</button>
  </div>
</dialog>
<div>
  <noscript>
    This should be obvious but uhh you kinda need JS for this page to work :P Search up "Enable JavaScript in Web Browser" to fix this if you somehow disabled it on accident :3
  </noscript>
</div>
  <script>

    // version
    const ver = 1.3976;
    document.title = `YW-Cond: v${ver}`; // finally auto-updating somewhat :3
    const el = id => document.getElementById(id); // gotta move it all the way up here
    el('ver2').innerText = `v${ver}` // wait no FULLY auto-updating after all this time :000

    if(typeof level5 === 'undefined') level5 = {};
    if(typeof level5.cond === 'undefined') level5.cond = {};
    if(typeof level5.cond._internals === 'undefined') level5.cond._internals = {};

    // manually labelled ones; some were before I decompiled it and some are just not in 1s
    const knownResourceIDs = {
      '2A 3D 45 43': 'GetGlobalBitFlag (FLAG_INFO_0; YW1/YW2/YW3/IEGO)', // output is always a boolean value in the int type (00 06 02); passed param is the FlagID as an int (00 06 02) in BE order
      '10 B1 40 96': 'GameClear (Is Main Story Completed; YW1/YW2)', // can be obtained from several places; one source (the first place this was found in) was Jungle Hunter shop conds, type: 00 01 00
      'DD 77 26 95': 'GetWatchRank (YW1/YW2)', // grabs player watch rank, 0 = E, ..., 5 = S
      '8D 76 66 D8': 'IsHaveItem (YW1/YW2)', // passed param is ItemID as an int (00 06 02) in LE order
      '9E 99 84 8C': 'GetGlobalByteFlag (FLAG_INFO_1; YW1/YW2/YW3)', // output is always an int (00 06 02); passed param is the FlagID as an int (00 06 02) in BE order
      'DE 17 FE 18': 'Lifetime Oni Orbs Collected in Psychic Blasters (YW2)',
      'B6 B8 67 71': 'GetActorHPRate (YW1/YW2)', // during battle; yokai targeted is dependent on the context of the cond executor - NOT the cond itself
      'B9 19 36 DA': 'GetPhase (YW1/YW2)', // now known as GetPhase - this exists in YW1, YW2 most likely YWB, YW3 and YWB2
      '37 90 0A 0D': 'Unique Yo-kai Cam Photos Taken (YW2)', // type: 00 01 00
      'C6 54 8E E3': 'Unique Bug Species Caught? (YW2)', // ? type: 00 01 00
      '85 E3 BE AF': 'Unique Fish Species Caught? (YW2)', // ? type: 00 01 00
      '83 DD D1 64': 'Psychic Blasters Oni Orbs High Score (YW2)',
      'BE 04 A5 98': 'GetQuestPhase (FF = Complete; YW1/YW2)', // FF = Complete
      '77 B4 63 E5': 'Grab Psychic Blasters Boss IsCleared (YW2)', // params: (int: index) 
      '3F FC EE 50': 'GetActorForwardToritukuGoodCountLowerCnt (YW1/YW2)', // if the passed param is 0, returns the amount of ally yokai WITHOUT a positive inspirit. Other param values lead to unknown results -- THIS WAS SLIGHTLY WRONG; actual namespace was GetActorForwardToritukuGoodCountLowerCnt and it takes no params dont know how I missed that :< --
      'EE CA 88 5A': 'YS_IsFind_Yokai (YW1/YW2)', // 2 param func, 2 params are IDs; example in load sample, used to check certain data, used in npc-set
      '48 A8 7F D3': 'YS_IsActive_Yokai (YW1/YW2)', // same but used to check a different state

      '27 32 6D 47': 'Is Trophy Complete? (YW2)', // params: TrophyID, returns bool, some trophies dont use this cond

      '74 03 A9 CE': 'Unk Phase-like Func (YW2)', // 3 params, 2 are usually function outputs and the 3rd/last seems to be phase; not in yw1

      // RESOURCE_ID_Bs (not Functions)

      // FlagIDs;

      // GlobalBitFlag(s)

        // Story Scenes
        '14 E8 5A 57': 'Checks if the story scene ev01_0200/ev01_0250 has been seen. (The Kin/Gin/Bronzlow scene at the start of the game; YW2)',
        'D6 2A 61 AB': 'Checks if the story scene ev01_1600 has been seen. (The scene where Nate/Katie chucks a capsule holding Whisper at the start of the game; YW2)',
        'C0 12 B2 F7': 'Checks if the story scene ev01_2000 has been seen. (The scene where Jibanyan gets run over; YW2)',
        'C6 D9 70 1C': 'Checks if the story scene ev01_2500 has been seen. (The scene where Nate summons Jibanyan against Brushido; YW2)',
        '91 7C ED AA': 'Checks if the story scene ev03_1800 has been seen. (The scene where Gargaros appears in Terror Time; occurs first during the story after Whatta Find is first entered; YW2)',
        '8C 18 79 CB': 'Checks if the story scene ev03_2100 has been seen. (The scripted scene where Gargaros chases the player to the exit; only occurs during the story after Whatta Find is first entered; YW2)',

        // Bonus Scenes
        '4D AC D4 0F': 'Checks if the bonus quest scene mv_photo77/yw2_evec_2100 has been seen. (YW2)',
        '54 B7 E5 4E': 'Checks if the bonus quest scene mv_photo78/yw2_evec_2110 has been seen. (YW2)',
        '7F 9A B6 8D': 'Checks if the bonus quest scene mv_photo79/yw2_evec_2120 has been seen. (YW2)',

        // Misc
        'C5 C2 5E 05': 'Checks if the Infinite Inferno has been cleared. (YW2)',
        '7D 24 ED 7D': 'Has Unlocked Everymart Discount. (YW2)',
        'AA 9C E0 F4': 'Has Jibanyan-S been met. (YW2)',
        'F9 2E B4 EC': 'Has Master Oden\'s Baffle Board been activated. (YW2)',

      // GlobalByteFlag(s)
      '89 20 FF E7': 'Infinite Tunnel Clear Count? (YW2)',
      'A9 38 C2 D5': 'Wanted Criminal Location/Data (YW2)', // Set it to 19-24 to make a Yo-Criminal appear in Shopper’s Row, 1-6 for Uptown Springdale, etc and 0 for None. The specific number changes which Yo-Criminal spawns.
      '3D EB CA B6': 'Leadoni Location/Data (YW2)',
      'C7 54 C3 0E': 'Soba Driver & Misc Location/Data (YW2)', // 1 for soba driver to appear
      '56 DF 31 58': 'Gargaros Defeat Count (Psychic Blasters Data; YW2)',
      'E9 2B 41 BB': 'Travelling Komasan Step/Location Data (YW2)', // for example 08 is at San Fantastico where he gives you the Oh My Swirls! Yo-kai Pad Wallpaper.
      '1B A5 DF 5D': 'Scratch-Off Data (YW2)',
    };
    level5.cond._manual = { ...knownResourceIDs }; // backup NOT reference; I originally tried to use .valueOf(); to fix it but that also returns a reference apparently; screw JS 
    const CExpressionInternalNames = [ // list of CExpression Functions; grouped based on similarities, NOT based on the order they are defined :)
      // ywBattleExpressionFunc
      'GetActorAgility',
      'GetActorAttack',
      'GetActorDefence',
      'GetActorHP',
      'GetActorHPRate',
      'GetActorPartsHP',
      'GetActorPartsHPRate',
      'GetActorMagic',
      'GetActorMode',

      'GetActorForwardCnt',
      'GetActorForwardAtkToritukuCnt',

      'GetActorForwardAverageHPRate',
      'GetActorForwardHighNeedSpSkillPointCnt',
      'GetActorForwardHighSpSkillRankCnt',
      'GetActorForwardHpRateHigherCnt',
      'GetActorForwardHpRateLowerCnt',

      'GetActorPartyAtkToritukuCnt',
      'GetActorPartyAverageHPRate',
      'GetActorPartyCnt',
      'GetActorPartyHpRateHigherCnt',
      'GetActorPartyHpRateLowerCnt',
      'GetActorPartyLastSpecialActionCountLowerCnt',

      'GetActorForwardLowNeedSpSkillPointHpRecoverCnt',
      'GetActorForwardLowSpSkillRankHpRecoverCnt',
      'GetActorForwardToritukuBadCountEqualCnt',
      'GetActorForwardToritukuBadCountHigherCnt',
      'GetActorForwardToritukuBadCountLowerCnt',
      'GetActorForwardToritukuGoodCountEqualCnt',
      'GetActorForwardToritukuGoodCountHigherCnt',
      'GetActorForwardToritukuGoodCountLowerCnt',

      'GetActorSpecialCancelOffset',
    
      'GetActorToritukuBadCnt',
      'GetActorToritukuGoodCnt',
      'GetCommonAtkToritukuCnt',
      'GetCommonAverageHPRate',
      'GetCommonPartyCnt',
      'GetCommonToritukuBadCountOpCnt',
      'GetCommonToritukuGoodCountOpCnt',

      'GetPartyDeadCnt',

      'GetTargetForwardAtkElemDefFactorHigherCnt',
      'GetTargetForwardAtkElemDefFactorLowerCnt',
      'GetTargetForwardAtkToritukuCnt',
      'GetTargetForwardChargeCnt',
      'GetTargetForwardCnt',

      'GetTargetForwardHpRateHigherCnt',
      'GetTargetForwardHpRateLowerCnt',
      'GetTargetForwardAverageHPRate',

      'GetTargetForwardLowestDefence',
      'GetTargetForwardNormalGoodCnt',

      'GetTargetForwardToritukuBadCountEqualCnt',
      'GetTargetForwardToritukuBadCountHigherCnt',
      'GetTargetForwardToritukuBadCountLowerCnt',
      'GetTargetForwardToritukuGoodCountEqualCnt',
      'GetTargetForwardToritukuGoodCountHigherCnt',
      'GetTargetForwardToritukuGoodCountLowerCnt',

      'GetTargetPartyAtkToritukuCnt',
      'GetTargetPartyAverageHPRate',
      'GetTargetPartyChargeCnt',
      'GetTargetPartyCnt',
      'GetTargetPartyHpRateHigherCnt',
      'GetTargetPartyHpRateLowerCnt',
      'GetTargetPartyLowestDefence',
      'GetTargetPartyNormalGoodCnt',

      'IsActorMagicHpRecovery',
      'IsActorRegen',
      'IsActorSpecialHpRecovery',
      'IsActorToritukuBad',
      'IsActorToritukuGood',
      'IsCommandDamageDown',

      'IsTargetForwardMagicDamageDown',
      'IsTargetForwardWazaDamageDown',

      'GetFalse', // ??? not in yw::util::CExpression, but should be?

      // ywGDExpressionFunc
      'GameClear', // returns 1 if the main story has been completed, 0 otherwise
      'GetChapter',
      'GetWatchRank',

      'GetGlobalBitFlag', // grabs the value of a FlagID - you can find them in FLAG_INFO_0; input: BE FlagID in XQ: get_global_bitflag()
      'GetGlobalByteFlag', // grabs the value of a FlagID - you can find them in FLAG_INFO_1; input: BE FlagID, returns 0 if something goes wrong i.e. the flag is null/dosent exist
      'GetTempBitFlag', // grabs the value of a FlagID - you can find them in FLAG_INFO_3; input: BE FlagID, returns 0 if something goes wrong i.e. the flag is null/dosent exist
      'GetTempByteFlag',
      'GetTempMapBitFlag',
      'GetTempMapByteFlag',

      'CheckQuestNecessaryCondition',
      'GetGlobalCharaCompFlagCRC',
      'GetGlobalCharaMetFlag',
      'GetGlobalTBoxFlag', // no-opped?

      'GetItemNum',
      'GetMoney', // in yen so: $\£\€1.23 = 123y and 250W = 100y
      'GetPartyNum',
      'GetPhase', // basically a massive number meaning lots of complex positions and stuff in the story; this WILL be a pain and sadly you WILL see it frequently :/
      'GetPlayerVarID', // no params output of 2 means female??
      'GetQuestCompNum',
      'GetQuestPhase', // FF = Quest Complete

      'GetTimeHour', // returns 0 if game time is null and if not the hour which is derived from (time in ticks) / 0x2A30
      'GetTimeNow', // returns -1 if the world isnt loaded, 3 if the game time is null otherwise either 0, 1, 2 or 3 (the repetition of 3 is intentional - it is the default time)
      'GetWeatherNow', // returns -1 if the world isnt loaded (GameManager::spRPGWorld == 0), 0 if the weather data ptr is null else weather byte as uint

      'InPartyMember', // input: (int: BaseID BE) returns 0 if the players party does not contain this yokai, else 1 (Uses CharaParamInfo)
      'IsApeearMitibiki', // typo is level5s fault not mine :/
      'IsAppearMitibiki', // this is not real, read the above one and then this comment: even though im 100% sure the ID will also include the typo, ill include the fixed version cuz why not :P

      'IsBicycleOn', // remember checks only happen when the condition is evaluated, for NPCs thats when the map loads, for shop items its when the shop is opened - dont expect a check using this function to update 60fps lmao (or 30fps outside of UIs this is the 3DS after all)
      'IsFullParty', // returns 0 (false) if party is null or isnt full, else 1 (true)
      'IsHaveItem', // pass the ItemID as BE, 1 (true) if the player has it, else 0 (false); internally just checks if the quantity is not 0
      'IsNpcUtil', // bruh; The function checks if the NPC with a given ID exists in spNpcCtrl, if a second param is provided and is equal to 1, it queries a specific bit flag on that NPC; Returns 1 or 0 based on these checks.

      'RunTrigger', // always returns 1 (true)
      'SetGlobalBitFlag', // FLAG_INFO_0; always returns 1 (true)
      'SetGlobalByteFlag', // FLAG_INFO_1; always returns 1 (true)
      'SetQuestPhase', // input: QuestID BE and int; sets the Quests phase to the passed int; phase FF = complete; function always returns 1 (true)
      'SetTempBitFlag', // input: FlagID and int; sets the temporary (non-global so not in flag_config) flag to the int; function always returns 1 (true)
      'SetTempByteFlag', // input: FlagID and int; sets the temporary (non-global so not in flag_config) flag to the int; function always returns 1 (true)
      'UpdateQuestPurpose', // updates some NPC stuff, quest stuff im too lazy to document this BUT I will laugh at one of level5s infamous typos: CScnObjRPGWorld::UpdataQuestMiniMapIcon

      'YS_CheckYokaiBaseID', // Input: BaseID; Returns 1 if the BaseID can be found in a Yo-kai Spot, else 0
      'YS_IsActive_Map', // Takes two IDs, one is a MapID and returns 1 or 0
      'YS_IsActive_Yokai', // wrapper for ywYokaispotStatus::IsActive_Yokai; returns 1 or 0
      'YS_IsFind_Map',
      'YS_IsFind_Yokai',
      'YS_IsFindFix',
      'YS_IsFindTmp',
      'YS_SetEnd',
      'YS_SetFind',


      // yw::util::CExpression
      // 100% only used internally but may as well
      'GetFloat',
      'GetLastValue',
      'GetResult',
      'GetS16',
      'GetS32',
      'GetS8',
      'GetStackValue',
      'GetU16',
      'GetU32',
      'GetU8',
        // yw::util::CExpression::CValue
        'GetProperValueType',
        'GetValueF32',
        'GetValueS16',
        'GetValueS32',
        'GetValueS32Direct', // Casts the result directly to a CValue, dosent check type, just grabs the value
        'GetValueS8',
        'GetValueU16',
        'GetValueU32',
        'GetValueU8',
        'IsFalse',
        'IsTrue',
        // I skipped alot because I'm lazy
        'SetValue',
        'SetValueF32',
        'SetValueS16',
        'SetValueS32',
        'SetValueS8',
        'SetValueU16',
        'SetValueU32',
        'SetValueU8',
   ]
   level5.cond.CExpressionInternalNames = CExpressionInternalNames;

   // CRC32 implementation (standard polynomial 0xEDB88320)
  function crc32(str) {
    let crc = 0 ^ (-1);

    for (let i = 0; i < str.length; i++) {
      crc = (crc >>> 8) ^ table[(crc ^ str.charCodeAt(i)) & 0xFF];
    }

    return (crc ^ (-1)) >>> 0;
  }

  // Precompute CRC32 table for speed
  const table = (() => {
    let c;
    const tbl = [];
    for (let n = 0; n < 256; n++) {
      c = n;
      for (let k = 0; k < 8; k++) {
        c = (c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1);
      }
      tbl[n] = c >>> 0;
    }
    return tbl;
  })();
     // got sidetracked optimising C++ code - so I ended up writing this code to free up 
    level5.cond.CExpressionInternalMappings = (() => {
      const temp = {};
      for (const funcName of CExpressionInternalNames) {
        const crc = crc32(funcName);
        const hexStr = crc.toString(16).padStart(8, '0').toUpperCase().match(/../g).join(' ');
        knownResourceIDs[hexStr] = funcName;
        temp[hexStr] = funcName;
      }
      return temp;
    })();

    // cond templates
    level5.cond.condTemplates = {
        mainStory: {
            type: "hex", // I dont even know what this does anymore......
            template: "00 00 00 00 0F 05 35 10 B1 40 96 00 01 00 32 00 00 00 {ACTIVATED} 78", // direct value
            params: [
                {
                    name: "ACTIVATED",
                    label: "State",
                    type: "select", // define a select
                    options: [ // with options
                        { label: "Completed", value: "01" }, 
                        { label: "Incomplete", value: "00" }
                    ]
                }
            ],
            label: "Yo-kai Watch 1/2 – Main Story" // label
            // no UI elements accept generate and cancel
        },
       /* unmainStory: {
            type: "b64",
            value: "AAAAAA8FNRCxQJYAAQAyAAAAAHg=",
            label: "Yo-kai Watch 1/2 – Main Story Not Completed"
        }, */
        rankXX: {
            type: "hex",
            template: "00 00 00 00 0f 05 35 dd 77 26 95 00 01 00 32 00 00 00 {RANK} {MATCH}", // template
            params: [
                {
                    name: "MATCH",
                    label: "Match Type",
                    type: "select", // define a select
                    options: [ // with options
                        { label: "Atleast", value: "71" },
                        { label: "Exactly", value: "78" },
                        { label: "Not", value: "79" },
                        { label: "Under", value: "6E" },
                        { label: "Maximum of", value: "6F" },
                        { label: "Over", value: "70" }
                    ]
                },
                { 
                    name: "RANK", // define rank
                    label: "Rank (00–FF)", // UI label
                    inputType: "hex", // input treated as hex
                    max: 0xFF, // byte cap
                    padding: 0x1, // pad as byte
                    placeholder: "e.g. 5 for S, 0 for E" // UI input placeholder
                }
            ],
            label: "Yo-kai Watch 1/2 – Watch Rank" // label
        },
        hasItem: {
            type: "hex",
            template: "00 00 00 00 18 05 35 8d 76 66 d8 00 0a 01 28 00 06 02 34 {ITEM} 32 00 00 00 {ACTIVATED} 78",
            params: [
                { 
                    name: "ITEM", 
                    label: "Item ID (4-byte big endian)", 
                    inputType: "default",
                    padding: 0x4,
                    max: 0xFFFFFFFF,
                    byteCoerce: 4, // coerce to signed 32-bit integer
                    placeholder: "e.g. 1678239 or 0x638297A" 
                },
                {
                    name: "ACTIVATED",
                    label: "State",
                    type: "select", // define a select
                    options: [ // with options
                        { label: "Has Item", value: "01" }, // label-value, key-value pair except it's not just {'FLAG_INFO_0', '2A 3D 45 43'} for whatever reason.... dont question my very questionable code
                        { label: "Does Not Have Item", value: "00" }
                    ]
                }
            ],
            label: "Yo-kai Watch 1/2 – Items"
        },
        tunnelXX: {
            type: "hex",
            template: "00 00 00 00 18 05 35 9e 99 84 8c 00 0a 01 28 00 06 02 34 89 20 ff e7 32 00 00 00 {COUNT} {MATCH}",
            params: [
                {
                    name: "MATCH",
                    label: "Match Type",
                    type: "select", // define a select
                    options: [ // with options
                        { label: "Atleast", value: "71" },
                        { label: "Exactly", value: "78" },
                        { label: "Not", value: "79" },
                        { label: "Under", value: "6E" },
                        { label: "Maximum of", value: "6F" },
                        { label: "Over", value: "70" }
                    ]
                },
                { 
                    name: "COUNT", 
                    label: "Times Beaten (00–FF)", 
                    inputType: "hex",
                    max: 0xFF,
                    padding: 0x1,
                    placeholder: "e.g. 03" 
                }
            ],
            label: "Yo-kai Watch 2/3 – Beaten Infinite Tunnel/Hazy Lane Count"
        },
        npcFlagYW3: {
            type: "hex",
            template: "00 00 00 00 18 05 35 {FLAG_TYPE} 00 0a 01 28 00 06 02 34 {FLAG} 32 00 00 00 {ACTIVATED} {MATCH}",
            altElements: [ // optional array of alternate param definitions
                {
                    name: "ACTIVATED",
                    label: "State (00-FF)",
                    inputType: "hex",
                    max: 0xFF,
                    padding: 0x1,
                    placeholder: "e.g. 03"
                },
                {
                    name: "MATCH",
                    label: "Match Type",
                    type: "select", // define a select
                    options: [ // with options
                        { label: "Atleast", value: "71" },
                        { label: "Exactly", value: "78" },
                        { label: "Not", value: "79" },
                        { label: "Under", value: "6E" },
                        { label: "Maximum of", value: "6F" },
                        { label: "Over", value: "70" }
                    ]
                },
            ],
            params: [
                {
                    name: "FLAG_TYPE",
                    label: "Flag Type",
                    type: "select",
                    options: [
                        { label: "FLAG_INFO_0", value: "2A 3D 45 43" }, // normal
                        { label: "FLAG_INFO_1", value: "9E 99 84 8C", altElements: [0, 1] } // activates altElements[0] and altElements[1]
                    ]
                },
                {
                    name: "FLAG",
                    label: "Flag ID (4-byte big endian)",
                    inputType: "default",
                    padding: 0x4,
                    max: 0xFFFFFFFF,
                    byteCoerce: 4,
                    placeholder: "e.g. 12345678 or 0x00ABCDEF"
                },
                {
                    name: "MATCH",
                    label: "Match Type",
                    type: "select", // define a select
                    options: [ // with options
                        { label: "Exactly", value: "78" },
                    ]
                },
                {
                    name: "ACTIVATED",
                    label: "State",
                    type: "select",
                    options: [
                        { label: "Activated", value: "01" },
                        { label: "Deactivated", value: "00" }
                    ]
                }
            ],
            label: "Yo-kai Watch 1/2/3 - Flags"
        }
    };

    /* Templates V2.0 (+ a whole lot of suffering to get it to work) */
    level5.cond.TemplateManager = class {
        constructor(templates) {
            if (!templates || typeof templates !== 'object') {
                console.warn('TemplateManager: templates argument missing or invalid. Using empty object.');
                templates = {};
            }
            this.templates = templates;
        }

        get(key) {
            return this.templates[key];
        }

        populateSelect(selectEl) {
            if (!selectEl) throw new Error('populateSelect: selectEl is required');
            selectEl.innerHTML = '';

            const keys = Object.keys(this.templates);
            if (keys.length === 0) {
                const opt = document.createElement('option');
                opt.value = '';
                opt.textContent = 'No templates available';
                selectEl.appendChild(opt);
                return;
            }

            keys.forEach(key => {
                const tpl = this.templates[key] || {};
                const opt = document.createElement('option');
                opt.value = key;
                opt.textContent = tpl.label || key;
                selectEl.appendChild(opt);
            });
        }

        renderInputs(container, key) { // auggyhahkgayihuefoajeaioheafl SO MANY changes and copy pasting from different versions to get altElements to properly work..........
            container.innerHTML = '';
            const tpl = this.get(key);
            if (!tpl || !Array.isArray(tpl.params)) return;

const activeAltElements = {}; // tracks { altName: { replacedInput, originalInput } }

const renderParam = (param) => {
    let label = container.querySelector(`label[for=param_${param.name}]`);
    let input;

    if (!label) {
        label = document.createElement('label');
        label.setAttribute('for', `param_${param.name}`);
        label.textContent = param.label + ': ';
        container.appendChild(label);
        container.appendChild(document.createElement('br'));
    }

    input = label.querySelector(`#param_${param.name}`);
    if (!input) {
        if (param.type === 'select' && Array.isArray(param.options)) {
            input = document.createElement('select');
            param.options.forEach(opt => {
                const o = document.createElement('option');
                o.value = String(opt.value);
                o.textContent = opt.label;
                if (opt.altElements != null) o.dataset.altIndex = JSON.stringify(opt.altElements);
                input.appendChild(o);
            });
        } else {
            input = document.createElement('input');
            input.type = param.inputType === 'hex' ? 'text' : 'text';
            input.placeholder = param.placeholder || '';
            input.dataset.inputType = param.inputType || 'default';
            if (param.max) input.dataset.max = param.max;
            if (param.padding) input.dataset.padding = param.padding;
        }
        input.id = `param_${param.name}`;
        input.dataset.name = param.name;
        input.classList.add('param-input');
        input.style.marginLeft = '6px';
        label.appendChild(input);
    }

    // only attach change handler for selects with altElements
    if (param.type === 'select') {
        input.onchange = () => {
            const selectedOpt = input.selectedOptions[0];
            const idxStr = selectedOpt.dataset.altIndex;
            if (!idxStr || !tpl.altElements) {
                // revert any active alt elements for this param
                Object.entries(activeAltElements).forEach(([altName, data]) => {
                    if (data.replacedByParam === param.name) {
                        data.replacedInput.replaceWith(data.originalInput);
                        delete activeAltElements[altName];
                    }
                });
                return;
            }

            const indices = JSON.parse(idxStr);
            // remove old alt elements for this param first
            Object.entries(activeAltElements).forEach(([altName, data]) => {
                if (data.replacedByParam === param.name && !indices.includes(data.idx)) {
                    data.replacedInput.replaceWith(data.originalInput);
                    delete activeAltElements[altName];
                }
            });

            // add new alt elements
indices.forEach(i => {
    const altParam = tpl.altElements[i];
    const origInput = container.querySelector(`#param_${altParam.name}`);
    if (!origInput || activeAltElements[altParam.name]) return;

    let newInput;

    if (altParam.type === 'select' && Array.isArray(altParam.options)) {
        newInput = document.createElement('select');
        altParam.options.forEach(opt => {
            const o = document.createElement('option');
            o.value = String(opt.value);
            o.textContent = opt.label;
            newInput.appendChild(o);
        });
    } else {
        newInput = document.createElement('input');
        newInput.type = altParam.inputType === 'hex' ? 'text' : 'text';
        newInput.dataset.inputType = altParam.inputType || 'default';
        newInput.placeholder = altParam.placeholder || '';
        if (altParam.max) newInput.dataset.max = altParam.max;
        if (altParam.padding) newInput.dataset.padding = altParam.padding;
    }

    newInput.id = `param_${altParam.name}`;
    newInput.dataset.name = altParam.name;
    newInput.classList.add('param-input');
    newInput.style.marginLeft = '6px';

    origInput.replaceWith(newInput);
    activeAltElements[altParam.name] = { replacedInput: newInput, originalInput: origInput, replacedByParam: param.name, idx: i };
});

        };
    }
};

            
            tpl.params.forEach(renderParam);
        }

        getValues(container) {
            const inputs = container.querySelectorAll('[id^=param_]');
            const result = {};
            // this method single handedly made me want to- :<<<<<
            // so.... so many edge cases
            inputs.forEach(inp => {
                const name = inp.dataset.name;
                let value;

                // handle selects literally...
                if (inp.tagName.toLowerCase() === 'select') {
                    const selectedOpt = inp.options[inp.selectedIndex];
                    value = selectedOpt?.value ?? '';
                    result[name] = value;
                    return;
                }

                // read text
                value = inp.value.trim();
                if (typeof value !== 'string') value = String(value);

                const inputType = inp.dataset.inputType || 'default';
                const padBytes = parseInt(inp.dataset.padding || '0', 10);
                const byteCoerce = parseInt(inp.dataset.byteCoerce || '0', 10); // NEW
                let num;

                // parse numeric value
                if (inputType === 'hex') {
                    value = value.replace(/^0x/i, '').replace(/[^0-9A-Fa-f-]/g, '');
                    num = parseInt(value || '0', 16);
                } else {
                    // "default" — allow 0x prefix for hex
                    if (/^0x/i.test(value)) {
                        num = parseInt(value, 16);
                    } else {
                        num = parseInt(value, 10);
                    }
                }

                if (isNaN(num)) num = 0;

                // apply the max, if there is one
                const maxRaw = inp.dataset.max;
                let max = 0;
                if (maxRaw) {
                    max = /^0x/i.test(maxRaw)
                        ? parseInt(maxRaw, 16)
                        : parseInt(maxRaw, 10);
                }
                if (!isNaN(max) && max > 0 && num > max) num = max;
                
                // apply byteCoerce
                if (byteCoerce > 0) {
                    switch (byteCoerce) {
                        case 1: num = num & 0xFF; break; // unsigned 8-bit integer (uint8)
                        case 2: num = num & 0xFFFF; break; // unsigned 16-bit integer (uint16)
                        case 4: num = num >>> 0; break; // unsigned 32-bit integer (uint32)
                        default: throw new SyntaxError("Invalid byteCoerce value"); // fancy :3
                    }
                } else if (padBytes > 0) { // else use padding
                    if (padBytes === 1) num = num & 0xFF;
                    else if (padBytes === 2) num = num & 0xFFFF;
                    else if (padBytes === 4) num = num >>> 0;
                }
                
                if (padBytes > 0) { // create the output
                    let hex = (num >>> 0).toString(16).toUpperCase(); // ofc always treat as unsigned for padding
                    value = hex.padStart(padBytes * 2, '0')
                        .match(/.{1,2}/g)
                        .join(' ');
                } else {
                    if (inputType === 'hex' || inputType === 'default') {
                        value = num.toString(16).toUpperCase();
                    } else {
                        value = num.toString(10);
                    }
                }

                result[name] = value;
            });
        
            return result;
        }
        
        
        generate(key, params) {
            const tpl = this.get(key);
            if (!tpl) return null;

            let resultStr = tpl.value ?? tpl.template ?? '';

            if (tpl.template && params && typeof params === 'object') {
                Object.entries(params).forEach(([name, value]) => {
                    const token = new RegExp('\\{' + name + '\\}', 'g'); // escape curly braces properly
                    resultStr = resultStr.replace(token, value);
                });
            }

            return {
                type: tpl.type,
                value: resultStr,
                label: tpl.label,
            };
        }

    };
    level5.cond.templateManager = new level5.cond.TemplateManager(level5.cond.condTemplates); // init class

    /* UI schenaniganagaaggagagagagaggagagagaggagags */
    document.addEventListener('DOMContentLoaded', () => {
        const $ = el;

        const tmplMgr = level5.cond.templateManager; // instance of class NOT the actual class
        const generateModal = $('generateModal');
        const condSelect = $('condSelect');
        const extraInputs = $('extraInputs');

        if (!Object.keys(level5.cond.condTemplates).length) {
            console.info('no level5.cond.condTemplates :/ Current object:', level5.cond.condTemplates);
        }

        tmplMgr.populateSelect(condSelect);
        tmplMgr.renderInputs(extraInputs, condSelect.value);

        condSelect.addEventListener('change', () => tmplMgr.renderInputs(extraInputs, condSelect.value));

        $('generateBtn')?.addEventListener('click', () => generateModal.showModal());
        $('closeModalBtn')?.addEventListener('click', () => generateModal.close());

        $('generateCondBtn')?.addEventListener('click', () => {
            const key = condSelect.value;
            const params = tmplMgr.getValues(extraInputs);
            const result = tmplMgr.generate(key, params);
            if (!result) {
                alert('Invalid condition template!');
                return;
            }
            console.log("wow", result)
            el('input').value = result.value; // used innerText earlier lol; that broke some stuff somehow
            el('parseBtn').click();
            generateModal.close();
        });
    });

    // very basic utils
    function normalizeInputRaw(text){ return (text||'').trim(); }

    function tryDecodeBase64(s){
      try { return atob(s); } catch(e){ try { const urlFixed = s.replace(/-/g,'+').replace(/_/g,'/'); const pad = urlFixed.length % 4 === 0 ? urlFixed : urlFixed + '='.repeat(4 - (urlFixed.length % 4)); return atob(pad);} catch(e2){ throw new Error('Not valid base64'); } }
    }

    function inputToHexString(text){
      const t = normalizeInputRaw(text);
      if(!t) return '';
      // try continuous hex first
      const hexCandidate = t.replace(/0x/gi,'').replace(/[:,\-<>]/g,'').replace(/\s+/g,'').trim();
      if(/^[0-9a-fA-F]*$/.test(hexCandidate) && hexCandidate.length % 2 === 0 && hexCandidate.length>0) return hexCandidate.toUpperCase();
      // try base64 (no spaces)
      const looksLikeB64 = /^[A-Za-z0-9+\/=_\-]+$/.test(t) && !/\s/.test(t);
      if(looksLikeB64){
        try{ const dec = tryDecodeBase64(t); return Array.from(dec).map(c => (typeof c==='string' ? c.charCodeAt(0) : c).toString(16).padStart(2,'0')).join('').toUpperCase(); } catch(e){ /* fallthrough */ }
      }
      // fallback: split on spaces/tokens
      const cleaned = t.replace(/0x/gi,'').replace(/[:,\-<>]/g,' ').replace(/\s+/g,' ').trim();
      const parts = cleaned.split(' ');
      return parts.map(p => p.padStart(2,'0')).join('').toUpperCase();
    }

    // helper: format hex string into spaced groups
    function hexSpaced(h){ return (h||'').match(/.{1,2}/g)?.join(' ') || ''; }


level5.cond.settings = { // moved this to the back of the script
  'showBool': true,
  'showPow': true,
  'showLim': true,
}

  level5.cond._internals.numberQOL = function(input) {
    if(input === 1 && level5.cond.settings.showBool) return `true`
    if(input === 0 && level5.cond.settings.showBool) return 'false'
   // if(input === -1) return 'undefined'
    if(input === 0xFF && level5.cond.settings.showLim) return `0xFF` // or -1/undefined?
    if(input === 0xFFFF && level5.cond.settings.showLim) return `0xFFFF` // or -1/undefined?
    if(input === 0xFFFFFF && level5.cond.settings.showLim) return `0xFFFFFF` // or -1/undefined?
    if(input === 0xFFFFFFFF && level5.cond.settings.showLim) return `0xFFFFFF` // or -1/undefined?
    if (input >= 16 && (input & (input - 1)) === 0 && level5.cond.settings.showPow) return '0x' + input.toString(16).toUpperCase(); // for powers of 2 >= 16
    return String(input);
  }

  // config modal.... yay who dosent love programming these :/
  const configBtn = document.getElementById('configBtn');
  const configModal = document.getElementById('configModal');
  const showBoolChk = document.getElementById('showBoolChk');
  const showPowChk = document.getElementById('showPowChk');
  const showLimChk = document.getElementById('showLimChk');
  const configSaveBtn = document.getElementById('configSaveBtn');
  const configCancelBtn = document.getElementById('configCancelBtn');
  
  // Open config modal and sync checkboxes
  configBtn.addEventListener('click', () => {
    showBoolChk.checked = level5.cond.settings.showBool;
    showPowChk.checked  = level5.cond.settings.showPow;
    showLimChk.checked  = level5.cond.settings.showLim;
    configModal.showModal();
  });

  // Confirm button: apply settings
  configSaveBtn.addEventListener('click', () => {
    level5.cond.settings.showBool = showBoolChk.checked;
    level5.cond.settings.showPow  = showPowChk.checked;
    level5.cond.settings.showLim  = showLimChk.checked;
    configModal.close();
  });

  // Cancel button: close without saving
  configCancelBtn.addEventListener('click', () => configModal.close());

  
    // gotta organise this:

    // reads
    level5.cond.READ_MEMORY = "35";
    level5.cond.READ_LITERAL = "32";
    level5.cond.READ_SUBSECTION = "34";

    // extension markers?
    level5.cond.EXTENSION_DELIM = "28"; // not fully a read but helps with structure and is always near a READ_SUBSECTION
    level5.cond.UPRM = "5D"; // just the + operator but since I havent rewritten the parser to be more stack-oriented this is neccessary for now
    // EOCIs
    level5.cond.EOCI = "8F";
    level5.cond.AEOCI = "90"; // this exists....

    level5.cond.temp = {
      "32": "+const",  // push constant (int)  
      "33": "+const‑alt",   // push constant (int) alt ?
      "34": "+const‑float",  // push constant (float?)  
      "35": "call", // call function  
    }

    // Operators
    level5.cond.OPERATORS = [
      "46",  // ++ (increment)  
      "47",  // -- (decrement)  
      "50",  // ~ (bitwise NOT)  
      "51",  // ! (logical NOT)  
      "5A",  // * (multiply)  
      "5B",  // / (divide)  
      "5C",  // % (modulus)  
      "5D",  // + (add)  
      "5E",  // - (subtract)  
      "64",  // << (left shift)  
      "65",  // >> (right shift)  
      "6E",  // < (less than)  
      "6F",  // <= (less or equal)  
      "70",  // > (greater than)  
      "71",  // >= (greater or equal)  
      "78",  // == (equal)  
      "79",  // != (not equal)  
      "82",  // & (bitwise AND)  
      "83",  // | (bitwise OR)  
      "84",  // ^ (bitwise XOR)  
  //  "8F",  // && (logical AND)  
  //  "90",  // || (logical OR)  
      "96"   // TECHNICALLY  not an operator - but we'll consider it as one anyway; ?: (conditional jump/ternary)  
      ];
    level5.cond.OPERATOR_LABELS = [
      "++",          // 0x46  
      "--",          // 0x47  
      "~",           // 0x50  
      "!",           // 0x51  
      "*",           // 0x5A  
      "/",           // 0x5B  
      "%",           // 0x5C  
      "+",           // 0x5D  
      "-",           // 0x5E  
      "<<",          // 0x64  
      ">>",          // 0x65  
      "<",           // 0x6E  
      "<=",          // 0x6F  
      ">",           // 0x70  
      ">=",          // 0x71  
      "==",          // 0x78  
      "!=",          // 0x79  
      "&",           // 0x82  
      "|",           // 0x83  
      "^",           // 0x84  
   // "&&",          // 0x8F  
    //"||",          // 0x90  
      "?:",          // TECHNICALLY  not an operator - but we'll consider it as one anyway; 0x96  
    ] // kept seperated into 2 arrays because I didnt want to risk breaking my old code

    level5.cond.dataTypes = [
      "int8", // 0 (char)
      "uint8", // 1 (uchar)
      "int16", // 2 (short)
      "uint16", // 3 (ushort)
      "int32", // 4 (int)
      "uint32", // 5 (uint)
      "float", // 6 float32 (float)
      // rest are unknown rn
    ]
    level5.cond.DEFAULT_OPERATOR = "=="; // kinda true, kinda wrong

    // CTYPEs
    level5.cond.CTYPES = {
      "00 13 02": "2 Param Function",
      "00 1C 03": "3 Param Function",
      "00 0A 01": "1 Param Function", // since conds dont have an array/list type there will often be functions that are just getData(int: index)
      "00 06 02": "Int",
      "00 01 00": "0 Param Function",
    }
    level5.cond.DEFAULT_CTYPE = "(00 01 00?)"; // unconfirmed
    level5.cond.isFunction = (ctype) => {
      return ctype.toUpperCase().replace(/\s+/g,"") != "000602";
    }
    level5.cond.isFunc = level5.cond.isFunction; // simple alias because I cant make up my mind :P
    // COMPARISON_VALUEs

    level5.cond.DEFAULT_COMPARISON_VALUE  = level5.cond._internals.numberQOL(1); // (0x00000000) maybe??? confirm this
    // level5.cond.COMPARISON_VALUE_LABELS is now deprecated in favour of level5.cond._internals.numberQOL
    level5.cond._internals.consumeBytes = function(hexStr, n){ const take = hexStr.slice(0, n*2); const rest = hexStr.slice(n*2); return [rest, take.toUpperCase()]; };
    level5.cond._internals.startsWith = function(hexStr, prefix){ return hexStr.slice(0, prefix.length).toUpperCase() === prefix.toUpperCase(); };

    level5.cond.parsev3Cond = function(inputHex){
      const $ = level5.cond._internals;
      let hex = (inputHex||'').replace(/\s+/g,'').toUpperCase();
      const parsedCond = [];
      function err(msg, hexSuffix){ const ctx = hexSuffix ? (' (next: '+hexSuffix+')') : ''; throw new SyntaxError(msg + ctx); }

      function parseHeader(){ if(hex.length < 12) err('Too short for header+condcode', hex.slice(0,12)); if(!$.startsWith(hex,'00000000')) err('Are you sure this is a real cond? Header invalid (expected 00000000)'); let consumed; [hex, consumed] = $.consumeBytes(hex,4); const headerBlock = [['HEADER', consumed]]; [hex, consumed] = $.consumeBytes(hex,2); headerBlock.push(['COND_CODE', consumed]); parsedCond.push(['HEADER_BLOCK', headerBlock]); }

      function parseClause(){ 
        if(hex.length < 2) err('Unexpected EOF while expecting READ_MEMORY or READ_LITERAL');
        // add operator check?

        if ( // done past me :P
          !$.startsWith(hex, level5.cond.READ_MEMORY) &&
          !$.startsWith(hex, level5.cond.READ_LITERAL) &&
          !level5.cond.OPERATORS.includes(hex.slice(0, 2))
        ) {
          err('Clause must start with READ_MEMORY, READ_LITERAL, or OPERATOR', hex.slice(0,2));
        }

        // handle OPERATOR as a clause starter
        if (level5.cond.OPERATORS.includes(hex.slice(0, 2))) {
          const clause = [];
          let consumed;
          [hex, consumed] = $.consumeBytes(hex, 1);
          clause.push(['OPERATOR', consumed]);
          
          // optional: operators might be followed by another READ_MEMORY / READ_LITERAL clause
          if ($.startsWith(hex, level5.cond.READ_MEMORY) || $.startsWith(hex, level5.cond.READ_LITERAL)) {
            // Recursively parse the next clause
            parsedCond.push(['CONDITION', clause]);
            parseClause();
            return;
          }
          
          // otherwise just treat it as a standalone operator clause
          parsedCond.push(['CONDITION', clause]);
          return;
        }
        // temp READ_LITERAL logic; might not work in all cases; I should add V2 fallback parsing

        if($.startsWith(hex, level5.cond.READ_LITERAL)){
          const clause = []; let consumed;
          [hex, consumed] = $.consumeBytes(hex,1); clause.push(['READ_LITERAL', consumed]);
          if(hex.length < 8) err('Truncated COMPARISON_VALUE', hex.slice(0,8));
          [hex, consumed] = $.consumeBytes(hex,4); clause.push(['COMPARISON_VALUE', consumed]);
          if(hex.length < 2) err('Unexpected EOF after COMPARISON_VALUE');
        
          if($.startsWith(hex, level5.cond.READ_LITERAL)){
              [hex, consumed] = $.consumeBytes(hex,1); clause.push(['READ_LITERAL', consumed]);
              parsedCond.push(['CONDITION', clause]);  
              return;
          }
        
          if($.startsWith(hex, level5.cond.READ_MEMORY)){
              parsedCond.push(['CONDITION', clause]); 
              parseClause();                          
              return; // A.
          }

          if ($.startsWith(hex, level5.cond.EOCI)) {
            console.warn("c")
            parsedCond.push(['CONDITION', clause]); // this 
             return;
          }

          if(level5.cond.OPERATORS.includes(hex.slice(0,2))){
            [hex, consumed] = $.consumeBytes(hex,1); clause.push(['OPERATOR', consumed]); 
            parsedCond.push(['CONDITION', clause]); return;
          } // e.


          err('Expected READ_LITERAL or READ_MEMORY after COMPARISON_VALUE', hex.slice(0,2));
        }
        if(!$.startsWith(hex, level5.cond.READ_MEMORY)) err('Clause must start with READ_MEMORY', hex.slice(0,2)); 
        const clause = []; let consumed; 
        [hex, consumed] = $.consumeBytes(hex,1); clause.push(['READ_MEMORY', consumed]); 
        if(hex.length < 8) err('Truncated RESOURCE_ID_A', hex.slice(0,8)); 
        [hex, consumed] = $.consumeBytes(hex,4); clause.push(['RESOURCE_ID_A', consumed]); 
        if(hex.length < 6) err('Truncated CTYPE_A', hex.slice(0,6)); 
        [hex, consumed] = $.consumeBytes(hex,3); clause.push(['CTYPE_A', consumed]);
      
        while(hex.length > 0){ 
          const nextByte = hex.slice(0,2);
          if($.startsWith(hex, level5.cond.UPRM)) {
          const clause = []; let consumed;
          [hex, consumed] = $.consumeBytes(hex,1); clause.push(['UPRRM', consumed]);
          }
          if($.startsWith(hex, level5.cond.READ_LITERAL)){
            [hex, consumed] = $.consumeBytes(hex,1); clause.push(['READ_LITERAL', consumed]); 
            if(hex.length < 8) err('Expected COMPARISON_VALUE after READ_LITERAL', hex.slice(0,8));
            [hex, consumed] = $.consumeBytes(hex,4); clause.push(['COMPARISON_VALUE', consumed]); 
if (hex.length === 0) {// no I did not copy this from a different version of my parser - why would you assume that? :P
  // end-of-input: finish condition
  parsedCond.push(['CONDITION', clause]);
  return;
}

if (hex.length < 2) {
  // still an unexpected truncated byte (unlikely because we handled length === 0 above)
  err('After COMPARISON_VALUE found unexpected truncated byte', hex.slice(0,2));
}

const afterComp = hex.slice(0,2);

// Another READ_LITERAL after the comparison indicates another comparison follows.
// do NOT consume the READ_LITERAL here because top-level parsing expects to see READ_LITERAL and will consume it :<
if ($.startsWith(hex, level5.cond.READ_LITERAL)) {
  // allow the parse to loop so the subsequent COMPARISON_VALUE is handled normally (fancy words :0 lol)
  continue;
}

// OPERATOR -> consume it and finish this condition
if (level5.cond.OPERATORS.includes(afterComp)) {
  [hex, consumed] = $.consumeBytes(hex,1);
  clause.push(['OPERATOR', consumed]);
  parsedCond.push(['CONDITION', clause]);
  return;
}
// EOCI -> consume and finish this condition
if ($.startsWith(hex, level5.cond.EOCI)) {
//  [hex, consumed] = $.consumeBytes(hex,1);
//  clause.push(['EOCI', consumed]);
  parsedCond.push(['CONDITION', clause]);
  return;
}

// AEOCI -> consume and finish this condition
if ($.startsWith(hex, level5.cond.AEOCI)) {
  parsedCond.push(['CONDITION', clause]);
  return;
}
if($.startsWith(hex, level5.cond.UPRM)) { // just in case - this has never been proved to actually occur 
  const clause = []; let consumed;
  [hex, consumed] = $.consumeBytes(hex,1); clause.push(['UPRRM', consumed]);
}

// READ_MEMORY -> do NOT consume it here; close this condition and let the outer loop handle the new clause
if ($.startsWith(hex, level5.cond.READ_MEMORY)) {
  parsedCond.push(['CONDITION', clause]);
  return;
}

// Otherwise it's still unexpected
err('After COMPARISON_VALUE expected READ_LITERAL, OPERATOR, EOCI, READ_MEMORY, or end-of-input but found', afterComp);

          }
          else if($.startsWith(hex, level5.cond.EXTENSION_DELIM)){
            [hex, consumed] = $.consumeBytes(hex,1); clause.push(['EXTENSION_DELIM', consumed]); 
            if(hex.length < 6) err('Expected CTYPE_B after EXTENSION_DELIM', hex.slice(0,6)); 
            [hex, consumed] = $.consumeBytes(hex,3); clause.push(['CTYPE_B', consumed]); 
            continue;
          }
          else if($.startsWith(hex, level5.cond.READ_SUBSECTION)){
            [hex, consumed] = $.consumeBytes(hex,1); clause.push(['READ_SUBSECTION', consumed]); 
            if(hex.length < 8) err('Expected RESOURCE_ID_B after READ_SUBSECTION', hex.slice(0,8)); 
            [hex, consumed] = $.consumeBytes(hex,4); clause.push(['RESOURCE_ID_B', consumed]); 
            continue;
          }
          else if(level5.cond.OPERATORS.includes(nextByte)){
            [hex, consumed] = $.consumeBytes(hex,1); clause.push(['OPERATOR', consumed]); 
            parsedCond.push(['CONDITION', clause]); return;
          } else if($.startsWith(hex, level5.cond.EOCI)){
          //  [hex, consumed] = $.consumeBytes(hex,1); clause.push(['EOCI', consumed]); 
            parsedCond.push(['CONDITION', clause]); return;
          } else if($.startsWith(hex, level5.cond.AEOCI)){ 
            parsedCond.push(['CONDITION', clause]);
            return;
          }  else if($.startsWith(hex, level5.cond.READ_MEMORY)){
              parsedCond.push(['CONDITION', clause]); 
              parseClause();                          
              return;
          } else {
            parsedCond.push(['CONDITION', clause]); return;
            err('Unknown byte in CLAUSE (unable to progress parse)', nextByte);
          }
        }

        /*
                  if
              */
        // fallback: push clause even if there isnt a OPERATOR but complain (7 warns if you're debugging this oh and sorry for your loss...)
        console.warn("no OPERATOR :<<<" + clause);
                console.warn("no OPERATOR :<<<" + clause);
                        console.warn("no OPERATOR :<<<" + clause);
                                console.warn("no OPERATOR :<<<" + clause);
                                        console.warn("no OPERATOR :<<<" + clause);
                                                console.warn("no OPERATOR :<<<" + clause);
                                                        console.warn("no OPERATOR :<<<" + clause);

        parsedCond.push(['CONDITION', clause]); 
        return;
      }


      // top-level header - not per condition but per cond; I totally didnt forget about the strict checks here which made me feel so delusional as I kept refreshing an earlier patch but nothing changed lmao
      parseHeader();
while (hex.length > 0) {
  let z;

  // Case 1: starts with AOECI
  if ($.startsWith(hex, level5.cond.AEOCI)) {
    [hex, z] = $.consumeBytes(hex, 1);
    parsedCond.push(['AEOCI', z]);
    continue; // B.
  }

    // Case 1: starts with EoCI
  if ($.startsWith(hex, level5.cond.EOCI)) {
    [hex, z] = $.consumeBytes(hex, 1);
    parsedCond.push(['EOCI', z]);
    continue; // B.
  }

  // Case 2: Expect READ_MEMORY, READ_LITERAL, or OPERATOR at top level
  if (
    !$.startsWith(hex, level5.cond.READ_MEMORY) &&
    !$.startsWith(hex, level5.cond.READ_LITERAL) &&
    !level5.cond.OPERATORS.includes(hex.slice(0, 2))
  ) {
    err('Expected READ_MEMORY, READ_LITERAL, or OPERATOR at top-level but found', hex.slice(0, 8));
  }


  // Parse clause
  parseClause();

  // Case 3: End of clause indicator
  if ($.startsWith(hex, level5.cond.EOCI)) {
    let c;
    [hex, c] = $.consumeBytes(hex, 1);
    parsedCond.push(['EOCI', c]);
    continue;
  }

  // Case 1: starts with AOECI
  if ($.startsWith(hex, level5.cond.AEOCI)) {
    [hex, z] = $.consumeBytes(hex, 1);
    parsedCond.push(['AEOCI', z]);
    continue; // B.
  }
  // Case 4: End or trailing bytes
  if (hex.length === 0) break;
  if (!$.startsWith(hex, level5.cond.READ_MEMORY) && !$.startsWith(hex, level5.cond.READ_LITERAL)) {
    err('Trailing/Unexpected bytes after clause(s)', hex.slice(0, 8));
  }
}
console.log("parsed cond", parsedCond);
      return parsedCond;
    };
 
    function labelForCompVal(hexBytes){ // d.
      console.log("wowaaa", hexSpaced(hexBytes.toUpperCase().replace(/\s+/g,'')))
      console.log("wowwaaee", hexBytes)
      let temp = [level5.cond.settings.showPow, level5.cond.settings.showLim]
      level5.cond.settings.showPow = false;
      level5.cond.settings.showLim = false;
      let out = level5.cond._internals.numberQOL(Number("0x" + hexBytes.toUpperCase().replace(/\s+/g,''))); // now uses the new util
      level5.cond.settings.showPow = temp[0];
      level5.cond.settings.showLim = temp[1];
      return out;
    }
    // ---- render helpers ----
    function labelForResource(hexBytes){ // hexBytes are expected to be formatted as 'AABBCCDD' or 'AA BB CC DD'
      const spaced = hexSpaced(hexBytes.toUpperCase().replace(/\s+/g,''));
      return level5.cond._manual[spaced] ?? knownResourceIDs[spaced];
    }

    function labelForOperator(opByte) {
      const ops = Object.fromEntries(level5.cond.OPERATORS.map((op, i) => [op, level5.cond.OPERATOR_LABELS[i]]));
      return ops[opByte.toUpperCase()] || null;
    }

  function labelForCType(ctypeBytes) {
    const ctypes = level5.cond.CTYPES;
    const spaced = hexSpaced(ctypeBytes.toUpperCase().replace(/\s+/g, '')); // normalise input
    return ctypes[spaced] || null;
  }

// Updated renderParsed: generates tree + test C-like pseudo output
function renderParsed(parsed) {
  const tree = document.getElementById('tree');
  tree.innerHTML = '';
  const pseudo = document.getElementById('pseudo');
  pseudo.textContent = '';

  let seenHeader = false; // avoid duplicating header printing

  parsed.forEach(node => {
    const type = node[0];

    // --- HEADER_BLOCK (unchanged for tree) ---
    if (type === 'HEADER_BLOCK') {
      const wrap = document.createElement('div');
      wrap.className = 'node';
      wrap.innerHTML = '<strong>HEADER</strong> <span class="small muted">(header + condcode)</span>';

      const inner = document.createElement('div');
      inner.className = 'small muted';
      node[1].forEach(x => {
        inner.innerHTML += '<div>' + x[0] + ': <span class="label">' + hexSpaced(x[1]) + '</span></div>';
      });
      wrap.appendChild(inner);
      tree.appendChild(wrap);

      // print header/condCode only once (keep as comment in pseudo)
      if (!seenHeader) {
    //    pseudo.textContent += '// #header ' + hexSpaced(node[1][0][1]) + '\n';
     //   pseudo.textContent += '// #condCode ' + hexSpaced(node[1][1][1]) + '\n\n';
        seenHeader = true;
      }
    }

    // --- CONDITION (unchanged for tree) ---
    else if (type === 'CONDITION') {
      const clause = node[1];
      const wrap = document.createElement('div');
      wrap.className = 'node';
      wrap.innerHTML = '<strong>CONDITION</strong>';

      const inner = document.createElement('div');
      inner.className = 'small muted';
      clause.forEach(f => {
        const name = f[0];
        const val = f[1];
        let lbl = null;
        if (name.startsWith('RESOURCE_ID')) lbl = labelForResource(val);
        else if (name.startsWith('COMPARISON_VALUE')) lbl = labelForCompVal(val);
        else if (name.startsWith('CTYPE')) lbl = labelForCType(val);
        else if (name === 'OPERATOR') lbl = labelForOperator(val);

        inner.innerHTML +=
          '<div><strong>' + name + '</strong>: <span class="label">' +
          hexSpaced(val) + '</span>' +
          (lbl ? (' <span class="small muted"> — ' + lbl + '</span>') : '') +
          '</div>';
      });

      wrap.appendChild(inner);
      tree.appendChild(wrap);
    }

    // --- EOCI / AEOCI / other types still rendered in tree ---
    else if (type === 'EOCI' || type === 'AEOCI') {
      const wrap = document.createElement('div');
      wrap.className = 'node';
      wrap.innerHTML = `<strong>${type}</strong>: <span class="label">${hexSpaced(node[1])}</span>`;
      tree.appendChild(wrap);
    }

    else {
      // Other node types: show in tree only
      const wrap = document.createElement('div');
      wrap.className = 'node small muted';
      wrap.textContent = type + ' (ignored in pseudo)';
      tree.appendChild(wrap);
    }
  });

  // --- PSEUDO GENERATION ---
  // Use level5.cond.condToC for the entire parsed structure
  try {
    const generatedPseudo = level5.cond.condToC(parsed);
    pseudo.textContent += generatedPseudo + '\n';
  } catch (err) {
    console.error('condToC failed:', err);
    pseudo.textContent += '/* condToC parse error */\n';
  }
}

// basic attempt at cond -> C
level5.cond.condToC = function(parsedArray) { // this was so difficult to finish........ WHY LEVEL5, WH- ok no this is actually an epic, cool system I love this; GBHJKIUHGBNMOI\GRUOWRIPHRSUIZEADSLSFKNM
  const norm = s => String(s || '').replace(/\s+/g, '').toUpperCase();

  const opMap = { // temporarily separated from the main logic until I fix the parser
    '46': '++','47': '--','50': '~','51': '!',
    '5A': '*','5B': '/','5C': '%','5D': '+','5E': '-',
    '64': '<<','65': '>>','6E': '<','6F': '<=','70': '>','71': '>=',
    '78': '==','79': '!=','82': '&','83': '|','84': '^',
    '8F': '&&','90': '||','96': '?:'
  };
  function mapOperator(hexOrSymbol) {
    if (hexOrSymbol === undefined || hexOrSymbol === null) return '??';
    const s = String(hexOrSymbol);
    if (/^[\!\=\&\|\+\-\*\/<>%\^~?:]+$/.test(s)) return s;
    const h = norm(s);
    return opMap[h] || s;
  }



  // render helpers
  function renderValue(node) {
    if (!node) return '/*null*/';
    if (typeof node === 'string') return node;
    if (node.type === 'LITERAL') return node.val;
    if (node.type === 'GROUP' && node.kind === 'ADDITION') return '(' + node.items.map(renderValue).join(' + ') + ')';
    if (node.type === 'FUNCTION') {
      const args = node.params.map(p => p == null ? '/*?*/' : renderValue(p)).join(', ');
      if(level5.cond.CExpressionInternalMappings[node.id.match(/../g).join(" ")]) return level5.cond.CExpressionInternalMappings[node.id.match(/../g).join(" ")] + `(${args})`;
      return `FUNC_${node.id}(${args})`;
    }
    if (node.type === 'EXPR') return node.expr;
    return String(node);
  }

  // parseValue consumes tokens starting at i; returns { node, nextIndex }
  function parseValue(flat, i) {
    const key = String(flat[i][0] || '').toUpperCase();
    const raw = flat[i][1];

    // READ_LITERAL + optional COMPARISON_VALUE
    if (key === 'READ_LITERAL' || key === '32') {
      const next = flat[i + 1];
      if (next) {
        const nk = String(next[0] || '').toUpperCase();
        if (nk.includes('COMPAR')) {
          const hex = norm(next[1] || '0');
          const num = parseInt(hex || '0', 16);
          const val = level5.cond._internals.numberQOL(num);
          return { node: { type: 'LITERAL', val }, nextIndex: i + 2 };
        }
      }
      const hex = norm(raw || '0');
      const num = parseInt(hex || '0', 16);
      const val = level5.cond._internals.numberQOL(num)
      return { node: { type: 'LITERAL', val }, nextIndex: i + 1 };
    }

    // direct COMPARISON_VALUE
    if (key.includes('COMPAR')) {
      const hex = norm(raw || '0');
      const num = parseInt(hex || '0', 16);
      const val = level5.cond._internals.numberQOL(num)
      return { node: { type: 'LITERAL', val }, nextIndex: i + 1 };
    }

    // READ_SUBSECTION: by default may be a nested FUNCTION(resource), but caller can request literal parsing
    if (key === 'READ_SUBSECTION' || key === '34') {
      const next = flat[i + 1];
      if (next && String(next[0] || '').toUpperCase().includes('RESOURCE')) {
        const id = norm(next[1] || '');
        if (/^[0-9A-F]{8,}$/.test(id)) return { node: { type: 'FUNCTION', id, params: [] }, nextIndex: i + 2 };
      }
      return { node: { type: 'LITERAL', val: 'SUBSECTION_UNKNOWN' }, nextIndex: i + 1 };
    }

    // READ_MEMORY: function/resource detection; this was the BIGGEST PAIN EVER TO IMPLEMENTBDFGUIJADFILHFDS\UD\FSIH;IDSFOUOUDSFHUPSDFOUHDSFBSFUAUSDHIADFHOIHFDS
    if (key === 'READ_MEMORY' || key === '35') {
      // locate resource and ctype nearby
      let ridIdx = -1, ctypeIdx = -1;
      for (let j = i + 1; j <= i + 6 && j < flat.length; j++) {
        const kj = String(flat[j][0] || '').toUpperCase();
        if (ridIdx === -1 && kj.includes('RESOURCE')) ridIdx = j;
        if (ctypeIdx === -1 && kj.includes('CTYPE')) ctypeIdx = j;
      }

      if (ridIdx !== -1) {
        const resourceId = norm(flat[ridIdx][1] || '');
        const ctypeRaw = ctypeIdx !== -1 ? norm(flat[ctypeIdx][1] || '') : null;

        // If ctype exists and is NOT a function -> resource as literal hex
        if (ctypeRaw && !level5.cond.isFunction(ctypeRaw)) {
          const lit = { type: 'LITERAL', val: `0x${resourceId}` };
          const nextIndex = Math.max(ridIdx, ctypeIdx) + 1;
          return { node: lit, nextIndex };
        }

        // Otherwise its..... you guessed it! a function
        let paramCount = 0;
        if (ctypeRaw) {
          const lastByte = ctypeRaw.slice(-2) || '00';
          paramCount = Number('0x' + lastByte) || 0;
        }
        const funcNode = { type: 'FUNCTION', id: resourceId, params: new Array(paramCount).fill(null) };
        let cursor = Math.max(ridIdx, ctypeIdx !== -1 ? ctypeIdx : ridIdx) + 1;

        for (let p = 0; p < paramCount; p++) {
          if (cursor >= flat.length) break;

          // detect explicit CTYPE token for this param
          let localCtype = null;
          if (String(flat[cursor][0] || '').toUpperCase().includes('CTYPE')) {
            localCtype = norm(flat[cursor][1] || '');
            cursor++;
          }

          // handle EXTENSION_DELIM if present
          if (cursor < flat.length && (String(flat[cursor][0] || '').toUpperCase() === 'EXTENSION_DELIM' || String(flat[cursor][1]) === '28')) {
            cursor++;
            if (cursor < flat.length && String(flat[cursor][0] || '').toUpperCase().includes('CTYPE')) {
              localCtype = norm(flat[cursor][1] || '');
              cursor++;
            }
          }

          // IMPORTANT: if localCtype indicates non-function, parse next tokens as LITERAL if possible
          if (localCtype && !level5.cond.isFunction(localCtype)) {
            if (cursor < flat.length) {
              const litRes = parseAsLiteralIfPossible(flat, cursor);
              if (litRes) {
                funcNode.params[p] = litRes.node;
                cursor = litRes.nextIndex;
                continue;
              }
              // fallback to parseValue if special-case didn't match
              const res = parseValue(flat, cursor);
              funcNode.params[p] = res.node;
              cursor = res.nextIndex;
              continue;
            } else {
              funcNode.params[p] = { type: 'LITERAL', val: '/*?*/' };
              break;
            }
          } else {
            // localCtype indicates a function (or absent) -> parse normally (may produce FUNCTION node)
            if (cursor < flat.length) {
              const res = parseValue(flat, cursor);
              funcNode.params[p] = res.node;
              cursor = res.nextIndex;
              continue;
            } else {
              funcNode.params[p] = { type: 'LITERAL', val: '/*?*/' };
              break;
            }
          }
        }
        return { node: funcNode, nextIndex: cursor };
      }

      // fallback: next token may be raw hex id
      const nextToken = flat[i + 1];
      const att = nextToken ? norm(nextToken[1] || '') : '';
      if (/^[0-9A-F]{8,}$/.test(att)) return { node: { type: 'FUNCTION', id: att, params: [] }, nextIndex: i + 2 };
      return { node: { type: 'LITERAL', val: 'FUNC_UNKNOWN' }, nextIndex: i + 1 };
    }

    // RESOURCE token alone
    if (key.includes('RESOURCE')) {
      const id = norm(raw || '');
      if (/^[0-9A-F]{8,}$/.test(id)) return { node: { type: 'FUNCTION', id, params: [] }, nextIndex: i + 1 };
    }

    // fallback literal
    return { node: { type: 'LITERAL', val: String(raw) }, nextIndex: i + 1 };
  } // end parseValue

  // helper: try to parse a literal form (resource/subsection/literal) starting at cursor
  // returns { node, nextIndex } or null if it couldn't recognize a simple literal
  function parseAsLiteralIfPossible(flat, cursor) {
    if (cursor >= flat.length) return null;
    const tk = String(flat[cursor][0] || '').toUpperCase();
    const tv = flat[cursor][1];

    // READ_SUBSECTION + RESOURCE -> literal hex
    if (tk === 'READ_SUBSECTION' || tk === '34') {
      const next = flat[cursor + 1];
      if (next && String(next[0] || '').toUpperCase().includes('RESOURCE')) {
        const id = norm(next[1] || '');
        if (/^[0-9A-F]{8,}$/.test(id)) {
          return { node: { type: 'LITERAL', val: `0x${id}` }, nextIndex: cursor + 2 };
        }
      }
    }

    // RESOURCE token directly -> literal hex
    if (tk.includes('RESOURCE')) {
      const id = norm(tv || '');
      if (/^[0-9A-F]{8,}$/.test(id)) {
        return { node: { type: 'LITERAL', val: `0x${id}` }, nextIndex: cursor + 1 };
      }
    }

    // READ_LITERAL + COMPARISON_VALUE -> literal true/false/number
    if (tk === 'READ_LITERAL' || tk === '32') {
      const next = flat[cursor + 1];
      if (next) {
        const nk = String(next[0] || '').toUpperCase();
        if (nk.includes('COMPAR')) {
          const hex = norm(next[1] || '0');
          const num = parseInt(hex || '0', 16);
          const val = level5.cond._internals.numberQOL(num)
          return { node: { type: 'LITERAL', val }, nextIndex: cursor + 2 };
        }
      }
      // fallback numeric literal from raw
      const hex = norm(tv || '0');
      if (/^[0-9A-F]+$/.test(hex)) {
        const num = parseInt(hex || '0', 16);
        return { node: { type: 'LITERAL', val: String(num) }, nextIndex: cursor + 1 };
      }
    }

    // COMPARISON_VALUE alone
    if (tk.includes('COMPAR')) {
      const hex = norm(tv || '0');
      const num = parseInt(hex || '0', 16);
      const val = level5.cond._internals.numberQOL(num)
      return { node: { type: 'LITERAL', val }, nextIndex: cursor + 1 };
    }

    // couldn't produce a literal
    return null;
  }

  // helper: consume valueStack for operator (last=right, second-last=left, group for 3+)
  const comparisonOps = new Set(['==','!=','<','<=','>','>=']);
  function consumeForOperator(valueStack, opSymbol) {
    const len = valueStack.length;
    let leftNode, rightNode;

    if (len === 0) {
      leftNode = { type: 'LITERAL', val: '0' };
      rightNode = { type: 'LITERAL', val: '1' };
      valueStack.length = 0;
    } else if (len === 1) {
      leftNode = valueStack.pop();
      rightNode = { type: 'LITERAL', val: '1' };
    } else if (len === 2) {
      rightNode = valueStack.pop();
      leftNode = valueStack.pop();
    } else {
      rightNode = valueStack.pop();
      leftNode = { type: 'GROUP', kind: 'ADDITION', items: valueStack.splice(0) };
    }

    const exprStr = `(${renderValue(leftNode)} ${opSymbol} ${renderValue(rightNode)})`;
    return { type: 'EXPR', expr: exprStr, leftNode, rightNode };
  }

  // Step 1: header comments
  const outLines = [];
  for (const blk of parsedArray) {
    if (String(blk[0] || '').toUpperCase() === 'HEADER_BLOCK') {
     // outLines.push('// Header');
      for (const it of (blk[1] || [])) {
        outLines.push(`// ${it[0]}: ${it[1]}`);
        if(it[0] == 'COND_CODE') outLines.push('\n'); // seperate headers and stuff; im too lazy to implement this properly
      }
    }
  }

  // Step 2: process top-level entries, building clauses and nested structure like v6
  const clauses = [];
  const clauseCombiners = [];
  const valueStack = [];

  for (let topIdx = 0; topIdx < parsedArray.length; topIdx++) {
    const top = parsedArray[topIdx];
    const topKey = String(top[0] || '').toUpperCase();

    if (topKey === 'HEADER_BLOCK') continue;

    if (topKey === 'EOCI' || topKey === 'AEOCI') {
      clauseCombiners.push(mapOperator(top[1]));
      continue;
    }

    if (topKey === 'CONDITION') {
      const inner = top[1] || [];
      let i = 0;
      while (i < inner.length) {
        const key = String(inner[i][0] || '').toUpperCase();
        const val = inner[i][1];

        if (key === 'EXTENSION_DELIM' || String(val) === '28') { i++; continue; }

        if (key === 'OPERATOR' || (/^[0-9A-F]{2}$/.test(key) && opMap[norm(key)])) {
          const opSymbol = mapOperator(val === undefined ? key : val);
          if (comparisonOps.has(opSymbol)) {
            const node = consumeForOperator(valueStack, opSymbol);
            clauses.push(node.expr);
            valueStack.length = 0;
            i++;
            continue;
          } else {
            const node = consumeForOperator(valueStack, opSymbol);
            valueStack.push(node);
            i++;
            continue;
          }
        }

        // otherwise parse a value
        const res = parseValue(inner, i);
        valueStack.push(res.node);
        i = res.nextIndex;
      }
      continue;
    }

    // stray OPERATOR at top
    if (topKey === 'OPERATOR') {
      clauseCombiners.push(mapOperator(top[1]));
      continue;
    }
  }

  // finalize leftover valueStack as a clause if present
  if (valueStack.length > 0) {
    if (valueStack.length === 1) clauses.push(`(${renderValue(valueStack[0])} == 1)`);
    else if (valueStack.length === 2) {
      const r = valueStack.pop(); const l = valueStack.pop();
      clauses.push(`(${renderValue(l)} == ${renderValue(r)})`);
    } else {
      const r = valueStack.pop();
      const leftGroup = { type: 'GROUP', kind: 'ADDITION', items: valueStack };
      clauses.push(`(${renderValue(leftGroup)} == ${renderValue(r)})`);
    }
    valueStack.length = 0;
  }

  // render clauses: nested ifs on && (default)
 // outLines.push('// Condition'); ab.
  if (clauses.length === 0) {
    outLines.push('if (0 == 1) {', '    success();', '}');
    outLines.push('fail();'); // little last minute patch :3
    return outLines.join('\n');
  }

  const allAnd = clauseCombiners.length === 0 || clauseCombiners.every(c => c === '&&');
  if (allAnd) {
    for (let k = 0; k < clauses.length; k++) {
      const ind = '    '.repeat(k);
      outLines.push(`${ind}if ${clauses[k]} {`);
    }
    outLines.push('    '.repeat(clauses.length) + 'success();');
    for (let k = 0; k < clauses.length; k++) {
      const ind = '    '.repeat(clauses.length - 1 - k);
      outLines.push(`${ind}}`);
    }
    outLines.push('fail();'); // little last minute patch :3
    return outLines.join('\n');
  }

  // otherwise combine into single expression
  let expr = clauses[0];
  for (let idx = 0; idx < clauses.length - 1; idx++) {
    const comb = clauseCombiners[idx] || '&&';
    expr = `(${expr} ${comb} ${clauses[idx + 1]})`;
  }
  outLines.push(`if ${expr} {`, '    success();', '}');
  outLines.push('fail();'); // little last minute patch :3
  return outLines.join('\n\n');
}

    level5.cond._internals.hexToBase64 = function(hexString) {
      // Remove all spaces
      const cleanHex = hexString.replace(/\s+/g, '');

      // Validate that it has an even length
      if (cleanHex.length % 2 !== 0) {
        throw new Error("Invalid hex string length");
      }

      // Convert hex to bytes
      const bytes = [];
      for (let i = 0; i < cleanHex.length; i += 2) {
        bytes.push(parseInt(cleanHex.substr(i, 2), 16));
      }

      // Convert bytes to Base64
      const base64String = btoa(String.fromCharCode(...bytes));
      return base64String;
    }

    level5.cond.samples = [
                      '00 00 00 00 0f 05 35 10 b1 40 96 00 01 00 32 00 00 00 01 78', /* main story completed yw2 simple format */
                      '00 00 00 00 18 05 35 2a 3d 45 43 00 0a 01 28 00 06 02 34 00 12 34 56 32 00 00 00 01 78', /* has flag 0x00123456 yw3; basic extended format */
                      '00 00 00 00 12 02 35 69 84 E3 AF 00 0A 01 28 00 06 02 34 96 49 FF 74', /* rare terminatorless and comparison valueless cond */
                      '00 00 00 00 1B 02 35 18 2B 37 5A 00 13 02 28 00 06 02 34 22 61 B7 8A 28 00 06 02 32 00 00 00 01', /* rare terminatorless cond */
                      '00 00 00 00 12 02 35 69 84 E3 AF 00 0A 01 28 00 06 02 34 0E 6B 6F 6B', /* redesign suggesting with resource ID :0 */
                      '00 00 00 00 36 05 35 74 03 A9 CE 00 1C 03 28 00 06 02 34 C1 B2 DA B7 28 00 06 02 34 8E 31 15 F3 28 00 06 02 32 00 00 0E F6 35 69 84 E3 AF 00 0A 01 28 00 06 02 34 42 6F A0 C3 8F', /* 3 resource IDs in the first condition */
                      '00 00 00 00 36 05 35 74 03 A9 CE 00 1C 03 28 00 06 02 34 C1 B2 DA B7 28 00 06 02 34 8E 31 15 F3 28 00 06 02 32 00 00 0E D8 35 69 84 E3 AF 00 0A 01 28 00 06 02 34 94 DE BD 45 8F', /* proper NEST EOCI handling in terminatorless conditions - aka just a random edge case test */
                      '00 00 00 00 48 08 35 74 03 A9 CE 00 1C 03 28 00 06 02 34 0C 24 46 3A 28 00 06 02 34 91 8A 8A 79 28 00 06 02 32 00 00 1A 9A 35 12 09 61 26 00 0A 01 28 00 06 02 32 00 00 1A A4 8F 35 69 84 E3 AF 00 0A 01 28 00 06 02 34 97 14 49 81 8F', /* chaotic best of a cond that has several edge cases for V3 parsing */
                      '00 00 00 00 18 05 35 8D 76 66 D8 00 0A 01 28 00 06 02 34 E5 96 D9 98 32 00 00 00 01 78', /* yw2 jetnayn appearcond (has bell) */
                      '00 00 00 00 09 02 35 7E E8 60 18 00 01 00', /* an extremely simple BATTLE_AI_ACT_CONDITION from yw2 */
                      'AAAAACcONd4X/hgAAQAyAAAD6HE1xlSO4wABADWF476vAAEAXTIAAAAecY8=', /* SV Snaggerjag Psychic Blasters Requirement Cond YW2 */
                      'AAAAAPA7NXe0Y+UACgEoAAYCMgAAAAEyAAAAAXg1d7Rj5QAKASgABgIyAAAAAjIAAAABeI81d7Rj5QAKASgABgIyAAAAAzIAAAABeI81d7Rj5QAKASgABgIyAAAABDIAAAABeI81d7Rj5QAKASgABgIyAAAABTIAAAABeI81d7Rj5QAKASgABgIyAAAABjIAAAABeI81d7Rj5QAKASgABgIyAAAABzIAAAABeI81d7Rj5QAKASgABgIyAAAACDIAAAABeI81d7Rj5QAKASgABgIyAAAACTIAAAABeI81d7Rj5QAKASgABgIyAAAACjIAAAABeI8=', /* hinozalls yw2 psychic blasters cond, demonstrates function calls emulating array access */
                      'AAAAAD8XMgAAAAE12ONpHwABADIAAAABeI8yAAAAAY8yAAAAATWemYSMAAoBKAAGAjQxBWKvMgAAAAJ4jzIAAAABj5A=', /* a yw3 exclusion config cond - you can tell just from the HORRIBLE stack that its from yw3 :<<< */
                      'AAAAADkONd4X/hgAAQAyAAAH0HE1npmEjAAKASgABgI0KzMh6jWemYSMAAoBKAAGAjRW3zFYXTIAAAAecY8=', /* good example of stack merging */
                      'AAAAAAIBcQ==', /* bruh */
                      'AAAAAAcDMgAAAAF4', /* bruh (but a little less) */
                      'AAAAADALNb4EpZgACgEoAAYCNFpFOBwyAAAA/3g1Kj1FQwAKASgABgI0lHk1KzIAAAABeI8=', /* mapo tofu requirement yw2 */
                    ];


    // ---- love my UI schenanamimigans ----

    function log(msg, kind){ const l = el('log'); const pfx = kind==='error'?'Error: ': kind==='warn'?'Warning: ': ''; l.textContent = pfx + msg; }

    function doParseFromInput(text){ try{ const hex = inputToHexString(text); if(!hex) {  el('input').value=''; el('tree').innerHTML=''; el('pseudo').textContent=''; el('log').textContent='Ready.'; return; } const parsed = level5.cond.parsev3Cond(hex); renderParsed(parsed); log('Parsed OK.'); } catch(e){ log(e.message, 'error'); console.error(e); } }


    el('parseBtn').addEventListener('click', ()=> doParseFromInput(el('input').value));
    el('parseB64Btn').addEventListener('click', () => {  // large util update
      try { 
        let raw = el('input').value.trim(); 

        // If input looks like hex (spaces or only hex digits), convert to Base64
        if(/\s/.test(raw) || /^[0-9A-Fa-f]+$/.test(raw)) {
          const b64 = level5.cond._internals.hexToBase64(raw);
          el('input').value = b64; // update input with Base64
          log('Converted hex → Base64: ' + b64, 'info');
          doParseFromInput(b64)
          return; // stahp it
        }

        // Otherwise, decode Base64 to hex for parsing
        const dec = tryDecodeBase64(raw); 
        const hex = Array.from(dec, c => 
          (typeof c === 'string' ? c.charCodeAt(0) : c).toString(16).padStart(2,'0')
        ).join('').toUpperCase(); 

        el('input').value = hexSpaced(hex); 
        doParseFromInput(hex); 

      } catch(e) { 
        log('Base64 decode failed: ' + e.message, 'error'); 
      } 
    });


       el('sampleBtn').addEventListener('click', ()=>{ // random sample list
      let samples = level5.cond.samples;
      el('input').value = samples[Math.round(Math.random() * (samples.length - 1))];
      el('parseBtn').click();
    });
    
   // removed to save UI space and in favour of Parse auto clearing if the input is empty : el('clearBtn').addEventListener('click', ()=>{ el('input').value=''; el('tree').innerHTML=''; el('pseudo').textContent=''; el('log').textContent='Ready.'; });

    el('copyPseudoBtn').addEventListener('click', ()=>{ const txt = el('pseudo').textContent; if(!txt){ log('Nothing to copy','warn'); return;} navigator.clipboard?.writeText(txt).then(()=> log('Pseudocode copied to clipboard'), ()=> log('Copy failed','warn')); });

    el('downloadBtn').addEventListener('click', ()=>{ const pseudo = el('pseudo').textContent || ''; const blob = new Blob([pseudo], { type: 'text/plain' }); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = 'cond.txt'; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url); });

    // light mode toggle; .......disgusting........ :<
    el('lightMode').addEventListener('change', (ev)=>{ document.body.classList.toggle('light', ev.target.checked); });

  </script>
</body>
</html>
