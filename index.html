<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>YW-Cond v1.391</title>
  <style>
    :root{
      --bg:#0f1115; --panel:#0b0d10; --text:#e6eef6; --muted:#9aa6b2; --accent:#6ea8ff; --good:#8bd18b; --bad:#ff7b7b;
    }
    body{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, monospace; margin:12px; color:var(--text); background:var(--bg);}
    .container{max-width:980px;margin:0 auto;padding:12px}
    h2{margin:0 0 8px 0}
    textarea{width:100%;min-height:120px;padding:8px;background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--text);}
    button{background:transparent;border:1px solid rgba(255,255,255,0.08);color:var(--text);padding:6px 8px;margin:4px;border-radius:6px;cursor:pointer}
    .controls{display:flex;flex-wrap:wrap;gap:6px;align-items:center;margin:8px 0}
    #log{white-space:pre-wrap;background:transparent;border:1px dashed rgba(255,255,255,0.03);padding:8px;min-height:36px;color:var(--muted)}
    .tree{background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent);padding:8px;border-radius:6px;margin-top:8px}
    .node{padding:6px;border-radius:4px;margin:2px 0;cursor:pointer}
    /* updated to work on light mode too (eugh) */
    .node:hover {
       background: rgba(255, 255, 255, 0.04);
       border: 1px solid transparent;
    }
  
    /* Light mode stuff :< */
    .light .node:hover {
      background: rgba(0, 0, 0, 0.08);
      border: 1px solid rgba(0, 0, 0, 0.08);
    }
    .light .node:active,
    .light .node.selected {
      background: rgba(0, 0, 0, 0.12);
      border: 1px solid rgba(0, 0, 0, 0.12);
    }


    .label{color:var(--accent);font-weight:600;margin-left:8px}
    .small{font-size:0.85em;color:var(--muted)}
    .muted{color:var(--muted)}
    .danger{color:var(--bad)}
    .ok{color:var(--good)}
    .pseudo{white-space:pre;background:transparent;border:1px solid rgba(255,255,255,0.03);padding:8px;border-radius:6px;margin-top:8px}

    /* dark mode toggle (light is inverse because nobody uses it) */
    .light { --bg:#f6f8fb; --panel:#fff; --text: #243732; --muted: #667085; --accent:#dea200; --good:#0b8f3a; --bad:#c23333; } /* the accent color is shoo good! I ran it through a color inverter to find the exact shade of orange because I was too lazy to hand pick one but it worked out! But yeah light mode is a pain to do */
    .light .pseudo {
       border-color: rgba(0,0,0,0.06);
      background: rgba(0,0,0,0.02);
    }

    /* modal basics */
    dialog{border:1px solid rgba(0,0,0,0.08);background:var(--panel);color:var(--text);padding:12px;border-radius:8px}
    label{display:inline-block}
    input[type=text]{padding:6px;border-radius:6px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:var(--text)}

    /* gotta add select/option CSS too */

    select { /* chevron sounds so fancy */
      padding: 6px;
      border-radius: 6px;
      border: 1px solid rgba(255, 255, 255, 0.04);
      background: transparent;
      color: var(--text);
      font-family: inherit;
      font-size: 0.95em;
      cursor: pointer;
      appearance: none; /* remove native arrow (for custom look) */
      background-image: linear-gradient(45deg, transparent 50%, var(--muted) 50%),
                        linear-gradient(135deg, var(--muted) 50%, transparent 50%);
      background-position: calc(100% - 16px) center, calc(100% - 12px) center;
      background-size: 5px 5px, 5px 5px;
      background-repeat: no-repeat;
      padding-right: 28px; /* space for arrow */
      transition: border-color 0.2s, background-color 0.2s;
    }
    
    select:hover, select:focus {
      border-color: rgba(255, 255, 255, 0.12);
      background-color: rgba(255, 255, 255, 0.02);
      outline: none;
    }
    
    option {
      background: var(--panel);
      color: var(--text);
      font-family: inherit;
    }
  </style>
</head>
<body>
  <div class="container" id="app">
    <h2>Yo-kai Watch Cond Parser <span class="small">v1.391</span></h2>
    <div class="small muted">Paste hex (spaced/continuous) or Base64. Parser uses V3 parsing.</div>

    <textarea id="input" placeholder="Paste hex (e.g. '00 0A 01') or base64 here"></textarea>

    <div class="controls">
      <button id="parseBtn">Parse</button>
      <button id="parseB64Btn">Parse Base64</button>
      <button id="sampleBtn">Load Sample</button>
      <button id="clearBtn">Clear</button>
      <button id="copyPseudoBtn">Copy Pseudocode</button>
      <button id="downloadBtn">Download Pseudocode</button>
      <button id="generateBtn">Generate Known Cond(s)</button>
      <label class="small muted" style="margin-left:8px"><input type="checkbox" id="lightMode"> Light mode</label>
    </div>

    <div id="log" aria-live="polite">Ready.</div>

    <div style="display:flex;gap:12px;margin-top:12px;align-items:flex-start">
      <div style="flex:1">
        <div class="tree" id="tree" role="region" aria-label="Parsed tree"></div>
      </div>
      <div style="width:46%">
        <div class="pseudo" id="pseudo"></div>
      </div>
    </div>

    <dialog id="generateModal">
      <h3>Generate Known Cond(s)</h3>
      <label>Condition: <select id="condSelect"></select></label>
      <div id="extraInputs"></div>
      <div style="margin-top:10px"><button id="generateCondBtn">Generate</button> <button id="closeModalBtn">Cancel</button></div>
    </dialog>
  </div>

  <script>
    // version
    const ver = 1.391;

    // known resource IDs for labeling
    const knownResourceIDs = {
      '2A 3D 45 43': 'Check for FLAG_INFO_0 Flag (YW1/YW2/YW3/IEGO)', // output is always a boolean value in the int type (00 06 02); passed param is the FlagID as an int (00 06 02) in BE order
      '10 B1 40 96': 'Is Main Story Completed (YW1/YW2)', // can be obtained from several places; one source (the first place this was found in) was Jungle Hunter shop conds, type: 00 01 00
      'DD 77 26 95': 'Watch Rank (YW1/YW2)', // grabs player watch rank, 0 = E, ..., 5 = S
      '8D 76 66 D8': 'Check if player has Item (YW1/YW2)', // passed param is ItemID as an int (00 06 02) in LE order
      '9E 99 84 8C': 'Check for FLAG_INFO_1 Flag (YW1/YW2/YW3)', // output is always an int (00 06 02); passed param is the FlagID as an int (00 06 02) in BE order
      'DE 17 FE 18': 'Lifetime Oni Orbs Collected in Psychic Blasters (YW2)',
      'B6 B8 67 71': 'Yo-kai HP% (YW2)', // during battle; yokai targeted is dependent on the context of the cond executor - NOT the cond itself
      'B9 19 36 DA': 'Unk State Bitmask (YW2)', // unk
      '37 90 0A 0D': 'Unique Yo-kai Cam Photos Taken (YW2)', // type: 00 01 00
      'C6 54 8E E3': 'Unique Bug Species Caught? (YW2)', // ? type: 00 01 00
      '85 E3 BE AF': 'Unique Fish Species Caught? (YW2)', // ? type: 00 01 00
      '83 DD D1 64': 'Psychic Blasters Oni Orbs High Score (YW2)',
      'BE 04 A5 98': 'Quest State (YW2)', // FF = Complete
      '77 B4 63 E5': 'Grab Psychic Blasters Boss IsCleared (YW2)', // params: (int: index) 
      '3F FC EE 50': 'Battle State Data (YW2)', // if the passed param is 0, returns the amount of ally yokai WITHOUT a positive inspirit. Other param values lead to unknown results
      'EE CA 88 5A': 'Map Data2 (YW2)', // 2 param func, 2 params are IDs; example in load sample, used to check rank gates in npc-set
      '48 A8 7F D3': 'Map Data1 (YW2)', // same but used to check if its closed


      // RESOURCE_ID_Bs (not Functions)

      // FlagIDs
      '89 20 FF E7': 'Infinite Tunnel Clear Count (YW2)',
    };
    const CExpressionInternalNames = [ // list of CExpression Functions; grouped based on similarities, NOT based on the order they are defined :)
      // ywBattleExpressionFunc
      'GetActorAgility',
      'GetActorAttack',
      'GetActorDefence',
      'GetActorHP',
      'GetActorHPRate',
      'GetActorPartsHP',
      'GetActorPartsHPRate',
      'GetActorMagic',
      'GetActorMode',

      'GetActorForwardCnt',
      'GetActorForwardAtkToritukuCnt',

      'GetActorForwardAverageHPRate',
      'GetActorForwardHighNeedSpSkillPointCnt',
      'GetActorForwardHighSpSkillRankCnt',
      'GetActorForwardHpRateHigherCnt',
      'GetActorForwardHpRateLowerCnt',

      'GetActorPartyAtkToritukuCnt',
      'GetActorPartyAverageHPRate',
      'GetActorPartyCnt',
      'GetActorPartyHpRateHigherCnt',
      'GetActorPartyHpRateLowerCnt',
      'GetActorPartyLastSpecialActionCountLowerCnt',

      'GetActorForwardLowNeedSpSkillPointHpRecoverCnt',
      'GetActorForwardLowSpSkillRankHpRecoverCnt',
      'GetActorForwardToritukuBadCountEqualCnt',
      'GetActorForwardToritukuBadCountHigherCnt',
      'GetActorForwardToritukuBadCountLowerCnt',
      'GetActorForwardToritukuGoodCountEqualCnt',
      'GetActorForwardToritukuGoodCountHigherCnt',
      'GetActorForwardToritukuGoodCountLowerCnt',

      'GetActorSpecialCancelOffset',
    
      'GetActorToritukuBadCnt',
      'GetActorToritukuGoodCnt',
      'GetCommonAtkToritukuCnt',
      'GetCommonAverageHPRate',
      'GetCommonPartyCnt',
      'GetCommonToritukuBadCountOpCnt',
      'GetCommonToritukuGoodCountOpCnt',

      'GetPartyDeadCnt',

      'GetTargetForwardAtkElemDefFactorHigherCnt',
      'GetTargetForwardAtkElemDefFactorLowerCnt',
      'GetTargetForwardAtkToritukuCnt',
      'GetTargetForwardChargeCnt',
      'GetTargetForwardCnt',

      'GetTargetForwardHpRateHigherCnt',
      'GetTargetForwardHpRateLowerCnt',
      'GetTargetForwardAverageHPRate',

      'GetTargetForwardLowestDefence',
      'GetTargetForwardNormalGoodCnt',

      'GetTargetForwardToritukuBadCountEqualCnt',
      'GetTargetForwardToritukuBadCountHigherCnt',
      'GetTargetForwardToritukuBadCountLowerCnt',
      'GetTargetForwardToritukuGoodCountEqualCnt',
      'GetTargetForwardToritukuGoodCountHigherCnt',
      'GetTargetForwardToritukuGoodCountLowerCnt',

      'GetTargetPartyAtkToritukuCnt',
      'GetTargetPartyAverageHPRate',
      'GetTargetPartyChargeCnt',
      'GetTargetPartyCnt',
      'GetTargetPartyHpRateHigherCnt',
      'GetTargetPartyHpRateLowerCnt',
      'GetTargetPartyLowestDefence',
      'GetTargetPartyNormalGoodCnt',

      'IsActorMagicHpRecovery',
      'IsActorRegen',
      'IsActorSpecialHpRecovery',
      'IsActorToritukuBad',
      'IsActorToritukuGood',
      'IsCommandDamageDown',

      'IsTargetForwardMagicDamageDown',
      'IsTargetForwardWazaDamageDown',

      'GetFalse', // ??? not in yw::util::CExpression, but should be?

      // ywGDExpressionFunc
      'GameClear', // returns 1 if the main story has been completed, 0 otherwise
      'GetChapter',
      'GetWatchRank',

      'GetGlobalBitFlag', // FLAG_INFO_0; input: BE FlagID in XQ: get_global_bitflag()
      'GetGlobalByteFlag', // FLAG_INFO_1; input: BE FlagID
      'GetTempBitFlag',
      'GetTempByteFlag',
      'GetTempMapBitFlag',
      'GetTempMapByteFlag',

      'CheckQuestNecessaryCondition',
      'GetGlobalCharaCompFlagCRC',
      'GetGlobalCharaMetFlag',
      'GetGlobalTBoxFlag', // no-opped?

      'GetItemNum',
      'GetMoney', // in yen so: $\£\€1.23 = 123y and 250W = 100y
      'GetPartyNum',
      'GetPhase', // basically a massive number meaning lots of complex positions and stuff in the story; this WILL be a pain and sadly you WILL see it frequently :/
      'GetPlayerVarID',
      'GetQuestCompNum',
      'GetQuestPhase', // FF = Quest Complete

      'GetTimeHour', // returns 0 if game time is null and if not the hour which is derived from (time in ticks) / 0x2A30
      'GetTimeNow', // returns -1 if the world isnt loaded, 3 if the game time is null otherwise either 0, 1, 2 or 3 (the repetition of 3 is intentional - it is the default time)
      'GetWeatherNow', // returns -1 if the world isnt loaded (GameManager::spRPGWorld == 0), 0 if the weather data ptr is null else weather byte as uint

      'InPartyMember', // returns 0 if the players party does not contain this yokai, else 1 (Checks CharaParamInfo so probably ParamID but could be BaseID I'm too lazy to check)
      'IsApeearMitibiki', // typo is level5s fault not mine :/
      'IsAppearMitibiki', // this is not real, read the above one and then this comment: even though im 100% sure the ID will also include the typo, ill include the fixed version cuz why not :P

      'IsBicycleOn', // remember checks only happen when the condition is evaluated, for NPCs thats when the map loads, for shop items its when the shop is opened - dont expect a check using this function to update 60fps lmao (or 30fps outside of UIs this is the 3DS after all)
      'IsFullParty', // returns 0 if party is null or isnt full, else 1
      'IsHaveItem', // pass the ItemID as LE!!, 1 if the player has it, else 0; internally just checks if the quantity is not 0
      'IsNpcUtil', // bruh; The function checks if the NPC with a given ID exists in spNpcCtrl, if a second param is provided and is equal to 1, it queries a specific bit flag on that NPC; Returns 1 or 0 based on these checks.

      'RunTrigger', // always returns 1
      'SetGlobalBitFlag', // FLAG_INFO_0; always returns 1
      'SetGlobalByteFlag', // FLAG_INFO_1; always returns 1
      'SetQuestPhase', // input: QuestID BE and int; sets the Quests phase to the passed int; phase FF = complete; function always returns 1
      'SetTempBitFlag', // input: FlagID and int; sets the temporary (non-global so not in flag_config) flag to the int; function always returns 1
      'SetTempByteFlag', // input: FlagID and int; sets the temporary (non-global so not in flag_config) flag to the int; function always returns 1
      'UpdateQuestPurpose', // updates some NPC stuff, quest stuff im too lazy to document this BUT I will laugh at one of level5s infamous typos: CScnObjRPGWorld::UpdataQuestMiniMapIcon

      'YS_CheckYokaiBaseID', // Input: BaseID; Returns 1 if the BaseID can be found in a Yo-kai Spot, else 0
      'YS_IsActive_Map', // Takes two IDs, one is a MapID and returns 1 or 0
      'YS_IsActive_Yokai', // wrapper for ywYokaispotStatus::IsActive_Yokai; returns 1 or 0
      'YS_IsFind_Map',
      'YS_IsFind_Yokai',
      'YS_IsFindFix',
      'YS_IsFindTmp',
      'YS_SetEnd',
      'YS_SetFind',


      // yw::util::CExpression
      // 100% only used internally but may as well
      'GetFloat',
      'GetLastValue',
      'GetResult',
      'GetS16',
      'GetS32',
      'GetS8',
      'GetStackValue',
      'GetU16',
      'GetU32',
      'GetU8',
        // yw::util::CExpression::CValue
        'GetProperValueType',
        'GetValueF32',
        'GetValueS16',
        'GetValueS32',
        'GetValueS32Direct', // Casts the result directly to a CValue, dosent check type, just grabs the value
        'GetValueS8',
        'GetValueU16',
        'GetValueU32',
        'GetValueU8',
        'IsFalse',
        'IsTrue',
        // I skipped alot because I'm lazy
        'SetValue',
        'SetValueF32',
        'SetValueS16',
        'SetValueS32',
        'SetValueS8',
        'SetValueU16',
        'SetValueU32',
        'SetValueU8',
   ]


   // CRC32 implementation (standard polynomial 0xEDB88320)
function crc32(str) {
  let crc = 0 ^ (-1);

  for (let i = 0; i < str.length; i++) {
    crc = (crc >>> 8) ^ table[(crc ^ str.charCodeAt(i)) & 0xFF];
  }

  return (crc ^ (-1)) >>> 0;
}

// Precompute CRC32 table for speed
const table = (() => {
  let c;
  const tbl = [];
  for (let n = 0; n < 256; n++) {
    c = n;
    for (let k = 0; k < 8; k++) {
      c = (c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1);
    }
    tbl[n] = c >>> 0;
  }
  return tbl;
})();

// Add CRC32 of each CExpression function to knownResourceIDs
for (const funcName of CExpressionInternalNames) {
  const crc = crc32(funcName);
  // Convert CRC32 number to uppercase hex string spaced every 2 chars like 'AA BB CC DD'
  const hexStr = crc.toString(16).padStart(8, '0').toUpperCase().match(/../g).join(' ');
  knownResourceIDs[hexStr] = funcName;
}

    // cond templates
    const condTemplates = {
      mainStory: { type: "b64", value: "AAAAAA8FNRCxQJYAAQAyAAAAAXg=", label: "Yo-kai Watch 2 – Main Story Completed" },
      unmainStory: { type: "b64", value: "AAAAAA8FNRCxQJYAAQAyAAAAAHg=", label: "Yo-kai Watch 2 – Main Story Not Completed" },
      rankXX: { type: "hex", template: "00 00 00 00 0f 05 35 dd 77 26 95 00 01 00 32 00 00 00 {RANK} 71", params: [{ name: "RANK", label: "Rank (00–FF)", placeholder: "e.g. 06" }], label: "Yo-kai Watch 2 – Rank XX or higher" },
      hasItem: { type: "hex", template: "00 00 00 00 18 05 35 8d 76 66 d8 00 0a 01 28 00 06 02 34 {ITEM} 32 00 00 00 01 78", params: [{ name: "ITEM", label: "Item ID (4-byte little endian)", placeholder: "e.g. 1678239 or 0x638297A etc" }], label: "Yo-kai Watch 2 – Has Item" },
      tunnelXX: { type: "hex", template: "00 00 00 00 18 05 35 9e 99 84 8c 00 0a 01 28 00 06 02 34 89 20 ff e7 32 00 00 00 {COUNT} 78", params: [{ name: "COUNT", label: "Times Beaten (00–FF)", placeholder: "e.g. 05" }], label: "Yo-kai Watch 2 – Beaten Infinite Tunnel XX Times" },
      npcFlagYW3: {type: "hex", template: "00 00 00 00 18 05 35 {RESOURCE_ID} 00 0a 01 28 00 06 02 34 {FLAG} 32 00 00 00 01 78", params: [{name: "FLAG_TYPE", label: "Flag Type", type: "select", options: [{ label: "FLAG_INFO_0", value: "2A 3D 45 43" }, { label: "FLAG_INFO_1", value: "9E 99 84 8C" }]},{ name: "FLAG", label: "Flag ID (4-byte big endian)", placeholder: "e.g. 12345678 or 0x00ABCDEF" }], label: "Yo-kai Watch 2/3 - Check for Flag (Activated)"},
      unhasItem: { type: "hex", template: "00 00 00 00 18 05 35 8d 76 66 d8 00 0a 01 28 00 06 02 34 {ITEM} 32 00 00 00 00 78", params: [{ name: "ITEM", label: "Item ID (4-byte little endian)", placeholder: "e.g. 1678239 or 0x638297A etc" }], label: "Yo-kai Watch 2 – Does Not Have Item" },
      unnpcFlagYW3: {type: "hex", template: "00 00 00 00 18 05 35 {RESOURCE_ID} 00 0a 01 28 00 06 02 34 {FLAG} 32 00 00 00 00 78", params: [{name: "FLAG_TYPE", label: "Flag Type", type: "select", options: [{ label: "FLAG_INFO_0", value: "2A 3D 45 43" }, { label: "FLAG_INFO_1", value: "9E 99 84 8C" }]},{ name: "FLAG", label: "Flag ID (4-byte big endian)", placeholder: "e.g. 12345678 or 0x00ABCDEF" }], label: "Yo-kai Watch 2/3 - Check for Flag (Not Activated)"},
    };

    // minimal internals for parsing hex/base64 -> normalized hex string
    function normalizeInputRaw(text){ return (text||'').trim(); }

    function tryDecodeBase64(s){
      try { return atob(s); } catch(e){ try { const urlFixed = s.replace(/-/g,'+').replace(/_/g,'/'); const pad = urlFixed.length % 4 === 0 ? urlFixed : urlFixed + '='.repeat(4 - (urlFixed.length % 4)); return atob(pad);} catch(e2){ throw new Error('Not valid base64'); } }
    }

    function inputToHexString(text){
      const t = normalizeInputRaw(text);
      if(!t) return '';
      // try continuous hex first
      const hexCandidate = t.replace(/0x/gi,'').replace(/[:,\-<>]/g,'').replace(/\s+/g,'').trim();
      if(/^[0-9a-fA-F]*$/.test(hexCandidate) && hexCandidate.length % 2 === 0 && hexCandidate.length>0) return hexCandidate.toUpperCase();
      // try base64 (no spaces)
      const looksLikeB64 = /^[A-Za-z0-9+\/=_\-]+$/.test(t) && !/\s/.test(t);
      if(looksLikeB64){
        try{ const dec = tryDecodeBase64(t); return Array.from(dec).map(c => (typeof c==='string' ? c.charCodeAt(0) : c).toString(16).padStart(2,'0')).join('').toUpperCase(); } catch(e){ /* fallthrough */ }
      }
      // fallback: split on spaces/tokens
      const cleaned = t.replace(/0x/gi,'').replace(/[:,\-<>]/g,' ').replace(/\s+/g,' ').trim();
      const parts = cleaned.split(' ');
      return parts.map(p => p.padStart(2,'0')).join('').toUpperCase();
    }

    // helper: format hex string into spaced groups
    function hexSpaced(h){ return (h||'').match(/.{1,2}/g)?.join(' ') || ''; }

    // ---- V3 parser implementation (strict sizes) ----
    if(typeof level5 === 'undefined') level5 = {};
    if(typeof level5.cond === 'undefined') level5.cond = {};
    if(typeof level5.cond._internals === 'undefined') level5.cond._internals = {};

    // gotta organise this:

    // reads
    level5.cond.READ_MEMORY = "35";
    level5.cond.READ_LITERAL = "32";
    level5.cond.READ_SUBSECTION = "34";

    // extension markers?
    level5.cond.EXTENSION_DELIM = "28"; // not fully a read but helps with structure and is always near a READ_SUBSECTION
    level5.cond.UPRM = "5D";
    // EOCIs
    level5.cond.EOCI = "8F";
    level5.cond.AEOCI = "90"; // this exists....

    level5.cond.temp = {
      "32": "+const",  // push constant (int)  
      "33": "+const‑alt",   // push constant (int) alt ?
      "34": "+const‑float",  // push constant (float?)  
      "35": "call", // call function  
    }

    // Operators
    level5.cond.OPERATORS = [
      "46",  // ++ (increment)  
      "47",  // -- (decrement)  
      "50",  // ~ (bitwise NOT)  
      "51",  // ! (logical NOT)  
      "5A",  // * (multiply)  
      "5B",  // / (divide)  
      "5C",  // % (modulus)  
      "5D",  // + (add)  
      "5E",  // - (subtract)  
      "64",  // << (left shift)  
      "65",  // >> (right shift)  
      "6E",  // < (less than)  
      "6F",  // <= (less or equal)  
      "70",  // > (greater than)  
      "71",  // >= (greater or equal)  
      "78",  // == (equal)  
      "79",  // != (not equal)  
      "82",  // & (bitwise AND)  
      "83",  // | (bitwise OR)  
      "84",  // ^ (bitwise XOR)  
  //  "8F",  // && (logical AND)  
  //  "90",  // || (logical OR)  
      "96"   // TECHNICALLY  not an operator - but we'll consider it as one anyway; ?: (conditional jump/ternary)  
      ];
    level5.cond.OPERATOR_LABELS = [
      "++",          // 0x46  
      "--",          // 0x47  
      "~",           // 0x50  
      "!",           // 0x51  
      "*",           // 0x5A  
      "/",           // 0x5B  
      "%",           // 0x5C  
      "+",           // 0x5D  
      "-",           // 0x5E  
      "<<",          // 0x64  
      ">>",          // 0x65  
      "<",           // 0x6E  
      "<=",          // 0x6F  
      ">",           // 0x70  
      ">=",          // 0x71  
      "==",          // 0x78  
      "!=",          // 0x79  
      "&",           // 0x82  
      "|",           // 0x83  
      "^",           // 0x84  
   // "&&",          // 0x8F  
    //"||",          // 0x90  
      "?:",          // ECHNICALLY  not an operator - but we'll consider it as one anyway; 0x96  
    ] // kept seperated into 2 arrays because I didnt want to risk breaking my old code

    level5.cond.dataTypes = [
      "int8", // 0 (char)
      "uint8", // 1 (uchar)
      "int16", // 2 (short)
      "uint16", // 3 (ushort)
      "int32", // 4 (int)
      "uint32", // 5 (uint)
      "float", // 6 float32 (float)
      // rest are unknown rn
    ]
    level5.cond.DEFAULT_OPERATOR = "(==?)"; // unconfirmed

    // CTYPEs
    level5.cond.CTYPES = {
      "00 13 02": "2 Param Function",
      "00 1C 03": "3 Param Function",
      "00 0A 01": "Function", // since conds dont have an array/list type there will often be functions that are just getData(int: index)
      "00 06 02": "Int",
      "00 01 00": "Const",
    }
    level5.cond.DEFAULT_CTYPE = "(00 01 00?)"; // unconfirmed

    // COMPARISON_VALUEs
    level5.cond.DEFAULT_COMPARISON_VALUE  = true; // (0x00000000) maybe??? confirm this
    level5.cond.COMPARISON_VALUE_LABELS = {
      "00 00 00 01": "true",
      "00 00 00 00": "false",
      "00 00 00 FF": "Special Case!", // sometimes means max, but is too situational to mention
    }
    // misc
    level5.cond._internals.consumeBytes = function(hexStr, n){ const take = hexStr.slice(0, n*2); const rest = hexStr.slice(n*2); return [rest, take.toUpperCase()]; };
    level5.cond._internals.startsWith = function(hexStr, prefix){ return hexStr.slice(0, prefix.length).toUpperCase() === prefix.toUpperCase(); };

    level5.cond.parsev3Cond = function(inputHex){
      const $ = level5.cond._internals;
      let hex = (inputHex||'').replace(/\s+/g,'').toUpperCase();
      const parsedCond = [];
      function err(msg, hexSuffix){ const ctx = hexSuffix ? (' (next: '+hexSuffix+')') : ''; throw new SyntaxError(msg + ctx); }

      function parseHeader(){ if(hex.length < 12) err('Too short for header+condcode', hex.slice(0,12)); if(!$.startsWith(hex,'00000000')) err('Are you sure this is a real cond? Header invalid (expected 00000000)'); let consumed; [hex, consumed] = $.consumeBytes(hex,4); const headerBlock = [['HEADER', consumed]]; [hex, consumed] = $.consumeBytes(hex,2); headerBlock.push(['COND_CODE', consumed]); parsedCond.push(['HEADER_BLOCK', headerBlock]); }

      function parseClause(){ 
        if(hex.length < 2) err('Unexpected EOF while expecting READ_MEMORY or READ_LITERAL');
        // add operator check?
        if(!$.startsWith(hex, level5.cond.READ_MEMORY) && !$.startsWith(hex, level5.cond.READ_LITERAL)) err('Clause must start with READ_MEMORY or READ_LITERAL', hex.slice(0,2));

        // temp READ_LITERAL logic; might not work in all cases; I should add V2 fallback parsing

        if($.startsWith(hex, level5.cond.READ_LITERAL)){
          const clause = []; let consumed;
          [hex, consumed] = $.consumeBytes(hex,1); clause.push(['READ_LITERAL', consumed]);
          if(hex.length < 8) err('Truncated COMPARISON_VALUE', hex.slice(0,8));
          [hex, consumed] = $.consumeBytes(hex,4); clause.push(['COMPARISON_VALUE', consumed]);
          if(hex.length < 2) err('Unexpected EOF after COMPARISON_VALUE');
        
          if($.startsWith(hex, level5.cond.READ_LITERAL)){
              [hex, consumed] = $.consumeBytes(hex,1); clause.push(['READ_LITERAL', consumed]);
              parsedCond.push(['CONDITION', clause]);  
              return;
          }
        
          if($.startsWith(hex, level5.cond.READ_MEMORY)){
              parsedCond.push(['CONDITION', clause]); 
              parseClause();                          
              return; // A.
          }

          if ($.startsWith(hex, level5.cond.EOCI)) {
            console.warn("c")
  parsedCond.push(['CONDITION', clause]); // this 
  return;

}

          if(level5.cond.OPERATORS.includes(hex.slice(0,2))){
            [hex, consumed] = $.consumeBytes(hex,1); clause.push(['OPERATOR', consumed]); 
            parsedCond.push(['CONDITION', clause]); return;
          } // e.


          err('Expected READ_LITERAL or READ_MEMORY after COMPARISON_VALUE', hex.slice(0,2));
        }
        if(!$.startsWith(hex, level5.cond.READ_MEMORY)) err('Clause must start with READ_MEMORY', hex.slice(0,2)); 
        const clause = []; let consumed; 
        [hex, consumed] = $.consumeBytes(hex,1); clause.push(['READ_MEMORY', consumed]); 
        if(hex.length < 8) err('Truncated RESOURCE_ID_A', hex.slice(0,8)); 
        [hex, consumed] = $.consumeBytes(hex,4); clause.push(['RESOURCE_ID_A', consumed]); 
        if(hex.length < 6) err('Truncated CTYPE_A', hex.slice(0,6)); 
        [hex, consumed] = $.consumeBytes(hex,3); clause.push(['CTYPE_A', consumed]);
      
        while(hex.length > 0){ 
          const nextByte = hex.slice(0,2);
          if($.startsWith(hex, level5.cond.UPRM)) {
          const clause = []; let consumed;
          [hex, consumed] = $.consumeBytes(hex,1); clause.push(['UPRRM', consumed]);
          }
          if($.startsWith(hex, level5.cond.READ_LITERAL)){
            [hex, consumed] = $.consumeBytes(hex,1); clause.push(['READ_LITERAL', consumed]); 
            if(hex.length < 8) err('Expected COMPARISON_VALUE after READ_LITERAL', hex.slice(0,8));
            [hex, consumed] = $.consumeBytes(hex,4); clause.push(['COMPARISON_VALUE', consumed]);
if (hex.length === 0) {
  // end-of-input: finish condition
  parsedCond.push(['CONDITION', clause]);
  return;
}

if (hex.length < 2) {
  // still an unexpected truncated byte (unlikely because we handled length === 0 above)
  err('After COMPARISON_VALUE found unexpected truncated byte', hex.slice(0,2));
}

const afterComp = hex.slice(0,2);

// Another READ_LITERAL after the comparison indicates another comparison follows.
// IMPORTANT: do NOT consume the READ_LITERAL here — keep original behavior (top-level parsing
// expects to see READ_LITERAL and will consume it in its normal flow).
if ($.startsWith(hex, level5.cond.READ_LITERAL)) {
  // allow the parse to loop so the subsequent COMPARISON_VALUE is handled normally
  continue;
}

// OPERATOR -> consume it and finish this condition
if (level5.cond.OPERATORS.includes(afterComp)) {
  [hex, consumed] = $.consumeBytes(hex,1);
  clause.push(['OPERATOR', consumed]);
  parsedCond.push(['CONDITION', clause]);
  return;
}
// EOCI -> consume and finish this condition
if ($.startsWith(hex, level5.cond.EOCI)) {
//  [hex, consumed] = $.consumeBytes(hex,1);
//  clause.push(['EOCI', consumed]);
  parsedCond.push(['CONDITION', clause]);
  return;
}

// AEOCI -> consume and finish this condition
if ($.startsWith(hex, level5.cond.AEOCI)) {
  parsedCond.push(['CONDITION', clause]);
  return;
}
if($.startsWith(hex, level5.cond.UPRM)) { // just in case - this has never been proved to actually occur 
  const clause = []; let consumed;
  [hex, consumed] = $.consumeBytes(hex,1); clause.push(['UPRRM', consumed]);
}

// READ_MEMORY -> do NOT consume it here; close this condition and let the outer loop handle the new clause
if ($.startsWith(hex, level5.cond.READ_MEMORY)) {
  parsedCond.push(['CONDITION', clause]);
  return;
}

// Otherwise it's still unexpected
err('After COMPARISON_VALUE expected READ_LITERAL, OPERATOR, EOCI, READ_MEMORY, or end-of-input but found', afterComp);

          }
          else if($.startsWith(hex, level5.cond.EXTENSION_DELIM)){
            [hex, consumed] = $.consumeBytes(hex,1); clause.push(['EXTENSION_DELIM', consumed]); 
            if(hex.length < 6) err('Expected CTYPE_B after EXTENSION_DELIM', hex.slice(0,6)); 
            [hex, consumed] = $.consumeBytes(hex,3); clause.push(['CTYPE_B', consumed]); 
            continue;
          }
          else if($.startsWith(hex, level5.cond.READ_SUBSECTION)){
            [hex, consumed] = $.consumeBytes(hex,1); clause.push(['READ_SUBSECTION', consumed]); 
            if(hex.length < 8) err('Expected RESOURCE_ID_B after READ_SUBSECTION', hex.slice(0,8)); 
            [hex, consumed] = $.consumeBytes(hex,4); clause.push(['RESOURCE_ID_B', consumed]); 
            continue;
          }
          else if(level5.cond.OPERATORS.includes(nextByte)){
            [hex, consumed] = $.consumeBytes(hex,1); clause.push(['OPERATOR', consumed]); 
            parsedCond.push(['CONDITION', clause]); return;
          } else if($.startsWith(hex, level5.cond.EOCI)){
          //  [hex, consumed] = $.consumeBytes(hex,1); clause.push(['EOCI', consumed]); 
            parsedCond.push(['CONDITION', clause]); return;
          } else if($.startsWith(hex, level5.cond.AEOCI)){ 
            parsedCond.push(['CONDITION', clause]);
            return;
          }  else if($.startsWith(hex, level5.cond.READ_MEMORY)){
              parsedCond.push(['CONDITION', clause]); 
              parseClause();                          
              return;
          } else {
            parsedCond.push(['CONDITION', clause]); return;
            err('Unknown byte in CLAUSE (unable to progress parse)', nextByte);
          }
        }

        /*
                  if
              */
        // fallback: push clause even if there isnt a OPERATOR but complain (7 warns if you're debugging this oh and sorry for your loss...)
        console.warn("no OPERATOR :<<<" + clause);
                console.warn("no OPERATOR :<<<" + clause);
                        console.warn("no OPERATOR :<<<" + clause);
                                console.warn("no OPERATOR :<<<" + clause);
                                        console.warn("no OPERATOR :<<<" + clause);
                                                console.warn("no OPERATOR :<<<" + clause);
                                                        console.warn("no OPERATOR :<<<" + clause);

        parsedCond.push(['CONDITION', clause]); 
        return;
      }


      // top-level header - not per condition but per cond; I totally didnt forget about the strict checks here which made me feel so delusional as I kept refreshing an earlier patch but nothing changed lmao
      parseHeader();
while (hex.length > 0) {
  let z;

  // Case 1: starts with AOECI
  if ($.startsWith(hex, level5.cond.AEOCI)) {
    [hex, z] = $.consumeBytes(hex, 1);
    parsedCond.push(['AEOCI', z]);
    continue; // B.
  }

    // Case 1: starts with EoCI
  if ($.startsWith(hex, level5.cond.EOCI)) {
    [hex, z] = $.consumeBytes(hex, 1);
    parsedCond.push(['EOCI', z]);
    continue; // B.
  }
  // Case 2: Expect READ_MEMORY or READ_LITERAL at top level
  if (
    !$.startsWith(hex, level5.cond.READ_MEMORY) &&
    !$.startsWith(hex, level5.cond.READ_LITERAL)
  ) {
    err('Expected READ_MEMORY or READ_LITERAL at top-level but found', hex.slice(0, 8));
  }

  // Parse clause
  parseClause();

  // Case 3: End of clause indicator
  if ($.startsWith(hex, level5.cond.EOCI)) {
    let c;
    [hex, c] = $.consumeBytes(hex, 1);
    parsedCond.push(['EOCI', c]);
    continue;
  }

  // Case 1: starts with AOECI
  if ($.startsWith(hex, level5.cond.AEOCI)) {
    [hex, z] = $.consumeBytes(hex, 1);
    parsedCond.push(['AEOCI', z]);
    continue; // B.
  }
  // Case 4: End or trailing bytes
  if (hex.length === 0) break;
  if (!$.startsWith(hex, level5.cond.READ_MEMORY) && !$.startsWith(hex, level5.cond.READ_LITERAL)) {
    err('Trailing/Unexpected bytes after clause(s)', hex.slice(0, 8));
  }
}

      return parsedCond;
    };
 
    function labelForCompVal(hexBytes){ // d.
      const spaced = hexSpaced(hexBytes.toUpperCase().replace(/\s+/g,''));
      return level5.cond.COMPARISON_VALUE_LABELS[spaced] ?? Number("0x" + spaced);
    }
    // ---- render helpers ----
    function labelForResource(hexBytes){ // hexBytes are expected to be formatted as 'AABBCCDD' or 'AA BB CC DD'
      const spaced = hexSpaced(hexBytes.toUpperCase().replace(/\s+/g,''));
      return knownResourceIDs[spaced];
    }

    function labelForOperator(opByte) {
      const ops = Object.fromEntries(level5.cond.OPERATORS.map((op, i) => [op, level5.cond.OPERATOR_LABELS[i]]));
      return ops[opByte.toUpperCase()] || null;
    }

  function labelForCType(ctypeBytes) {
    const ctypes = level5.cond.CTYPES;
    const spaced = hexSpaced(ctypeBytes.toUpperCase().replace(/\s+/g, '')); // normalise input
    return ctypes[spaced] || null;
  }
// Helper: turn a single CONDITION clause (array of [name, val]) into a C-like expression
function toCExpression(clause) {
  // Collect the relevant pieces (may be missing in many cases)
  let resourceA = null;
  let resourceB = null;
  let ctypeA = null;
  let ctypeB = null;
  let operator = null;
  let comparisonVal = null;

  clause.forEach(([name, val]) => {
    if (name.startsWith('RESOURCE_ID')) {
      if (name.endsWith('_A')) resourceA = hexSpaced(val);
      else if (name.endsWith('_B')) resourceB = hexSpaced(val);
      else if (!resourceA) resourceA = hexSpaced(val); // fallback
    } else if (name.startsWith('CTYPE')) {
      if (name.endsWith('_A')) ctypeA = labelForCType(val) || hexSpaced(val);
      else if (name.endsWith('_B')) ctypeB = labelForCType(val) || hexSpaced(val);
      else if (!ctypeA) ctypeA = labelForCType(val) || hexSpaced(val);
    } else if (name === 'OPERATOR') {
      operator = labelForOperator(val) || ('0x' + val.replace(/\s+/g,''));
    } else if (name === 'COMPARISON_VALUE') {
      // comparisonVal is bytes like "00 00 00 01" — try to parse small ints, otherwise show hex
      const raw = val.replace(/\s+/g,'');
      // parse as little-endian 32-bit if length==8, otherwise hex string
      if (raw.length === 8) {
        // interpret as big-endian? Many comparison values appear as BE in file; try both fallbacks
        const intBE = parseInt(raw, 16);
        comparisonVal = intBE;
      } else {
        comparisonVal = '0x' + raw.toUpperCase();
      }
    }
  });

  // Build a readable resource/function name
  const labelA = resourceA ? labelForResource(resourceA) : null;
  const readableA = labelA ? labelA.replace(/^Check (for|if player has) /i,'').replace(/\s+/g,'') : (resourceA ? 'ReadMemory_' + resourceA.replace(/\s+/g,'') : null);

  // Choose the defaults
  const op = operator || level5.cond.DEFAULT_OPERATOR; // c.
  const cmp = (typeof comparisonVal === 'number') ? comparisonVal : (comparisonVal || level5.cond.DEFAULT_COMPARISON_VALUE);

  // Known semantic patterns
  if (labelA && /Item/i.test(labelA)) {
    let itemId = null;
    if (resourceB) itemId = '0x' + resourceB.replace(/\s+/g,'');

     if (typeof comparisonVal === 'number' && comparisonVal !== 0 && !itemId) itemId = '0x' + comparisonVal.toString(16).toUpperCase();

    if (!itemId) itemId = '?';
    return `HasItem(${"0x" + itemId.slice(2).match(/../g).reverse().join("")}) ${op} ${(typeof comparisonVal === 'number' || typeof comparisonVal === 'boolean' ? ('0x' + comparisonVal.toString(16).toUpperCase()) : level5.cond.DEFAULT_COMPARISON_VALUE)}`;  // endiannes is variable; ItemIDs are LE, Flag IDs are BE
  }

  if (labelA && /Main Story/i.test(labelA)) {
    return `MainStoryCompleted() ${op} ${(typeof comparisonVal === 'number' || typeof comparisonVal === 'boolean' ? ('0x' + comparisonVal.toString(16).toUpperCase()) : level5.cond.DEFAULT_COMPARISON_VALUE)}`;
  }

  if (labelA && /Watch Rank/i.test(labelA)) {
    return `GetWatchRank() ${op} ${(typeof comparisonVal === 'number' || typeof comparisonVal === 'boolean' ? ('0x' + comparisonVal.toString(16).toUpperCase()) : level5.cond.DEFAULT_COMPARISON_VALUE)}`;
  }

  if (labelA && /FLAG_INFO/i.test(labelA)) {
    let x = null;
    if(/FLAG_INFO_1/i.test(labelA)) {
      x = "FLAG_INFO_1"
    }
    if(/FLAG_INFO_0/i.test(labelA)) {
      x = "FLAG_INFO_0"
    }
    if(/FLAG_INFO_2/i.test(labelA)) {
      x = "FLAG_INFO_2"
    }
    if(/FLAG_INFO_3/i.test(labelA)) {
      x = "FLAG_INFO_3"
    }
    if(/FLAG_INFO_4/i.test(labelA)) {
      x = "FLAG_INFO_4"
    }
    if(/FLAG_INFO_5/i.test(labelA)) {
      x = "FLAG_INFO_5"
    }
    if(!x) x = "<unk>"
    // flags: resourceA indicates flag type, resourceB is usually the flag id (big-endian)
    const flagIdDisp = resourceB ? ('0x' + resourceB.replace(/\s+/g,'')) : (typeof comparisonVal === 'number' ? ('0x' + comparisonVal.toString(16).toUpperCase()) : level5.cond.DEFAULT_COMPARISON_VALUE);
    // If CTYPE_B indicated param/int we show a boolean check
    return `CheckFlag(${flagIdDisp}, ${x}) ${op} ${(typeof comparisonVal === 'number' || typeof comparisonVal === 'boolean' ? ('0x' + comparisonVal.toString(16).toUpperCase()) : level5.cond.DEFAULT_COMPARISON_VALUE)}`;
  }

  // Generic fallback that uses ctype names when available
  const ctypeLabel = ctypeA || level5.cond.DEFAULT_CTYPE;
  const resArg = resourceA ? ('0x' + resourceA.replace(/\s+/g,'')) : 'ADDR';
  return `${readableA}(${ctypeLabel}, ${resArg}) ${op} ${cmp}`;
}

// Updated renderParsed: generates tree + test C-like pseudo output
function renderParsed(parsed) {
  const tree = document.getElementById('tree'); tree.innerHTML = '';
  const pseudo = document.getElementById('pseudo'); pseudo.textContent = '';

  let condGroup = []; // expressions for the current logical group
  let seenHeader = false; // avoid duplicating header printing

  parsed.forEach(node => {
    const type = node[0];

    // keep tree rendering the same
    if (type === 'HEADER_BLOCK') {
      const wrap = document.createElement('div'); wrap.className = 'node';
      wrap.innerHTML = '<strong>HEADER</strong> <span class="small muted">(header + condcode)</span>';
      const inner = document.createElement('div'); inner.className='small muted';
      node[1].forEach(x => {
        inner.innerHTML += '<div>' + x[0] + ': <span class="label">' + hexSpaced(x[1]) + '</span></div>';
      });
      wrap.appendChild(inner); tree.appendChild(wrap);

      // print header/condCode only once (keep as comment in pseudo)
      if (!seenHeader) {
        pseudo.textContent += '// #header ' + hexSpaced(node[1][0][1]) + '\n';
        pseudo.textContent += '// #condCode ' + hexSpaced(node[1][1][1]) + '\n\n';
        seenHeader = true;
      }
    }

    else if (type === 'CONDITION') {
      const clause = node[1];
      const wrap = document.createElement('div'); wrap.className = 'node';
      wrap.innerHTML = '<strong>CONDITION</strong>';
      const inner = document.createElement('div'); inner.className = 'small muted';

      // populate tree view with fields
      clause.forEach(f => {
        const name = f[0];
        const val = f[1];
        let lbl = null;
        if (name.startsWith('RESOURCE_ID')) lbl = labelForResource(val);
        else if (name.startsWith('COMPARISON_VALUE')) lbl = labelForCompVal(val);
        else if (name.startsWith('CTYPE')) lbl = labelForCType(val);
        else if (name === 'OPERATOR') lbl = labelForOperator(val);

        inner.innerHTML += '<div><strong>' + name + '</strong>: <span class="label">' +
          hexSpaced(val) + '</span>' + (lbl ? (' <span class="small muted"> — ' + lbl + '</span>') : '') + '</div>';
      });

      wrap.appendChild(inner); tree.appendChild(wrap);

      // generate a single expression from the whole clause and queue it
      try {
        const expr = toCExpression(clause);
        condGroup.push(expr);
      } catch (e) {
        // if conversion fails just push a safe fallback string
        condGroup.push('/* parse_error */ true');
        console.error('toCExpression failed', e);
      }
    }

    else if (type === 'EOCI') {
      // render EOCI in tree
      const wrap = document.createElement('div'); wrap.className = 'node';
      wrap.innerHTML = '<strong>EOCI</strong>: <span class="label">' + hexSpaced(node[1]) + '</span>';
      tree.appendChild(wrap);

      // flush the current condition group as a C-style if-block
      if (condGroup.length > 0) {
        const combined = condGroup.join(' && ');
        pseudo.textContent += `if (${combined}) {\n    // condition satisfied\n}\n\n`;
        condGroup = [];
      }

      // annotate EOCI as comment (keeps output compact)
      pseudo.textContent += `// EOCI ${hexSpaced(node[1])}\n\n`;
    } else if (type === 'AEOCI') {
      // render AEOCI in tree
      const wrap = document.createElement('div'); wrap.className = 'node';
      wrap.innerHTML = '<strong>AEOCI</strong>: <span class="label">' + hexSpaced(node[1]) + '</span>';
      tree.appendChild(wrap);

      // flush the current condition group as a C-style if-block
      if (condGroup.length > 0) {
        const combined = condGroup.join(' && ');
        pseudo.textContent += `if (${combined}) {\n    // condition satisfied\n}\n\n`;
        condGroup = [];
      }

      // annotate AEOCI as comment (keeps output compact)
      pseudo.textContent += `// AEOCI ${hexSpaced(node[1])}\n\n`;
    }

    // any other node types are simply ignored for pseudo (but still present in tree)
    else {
      // noop for pseudo
    }
  });

  // final flush: if parser ended without an EOCI, still emit any pending group
  if (condGroup.length > 0) {
    const combined = condGroup.join(' && ');
    pseudo.textContent += `if (${combined}) {\n    // condition satisfied\n}\n\n`;
    condGroup = [];
  }
}




    // ---- UI actions ----
    const el = id => document.getElementById(id);

    function log(msg, kind){ const l = el('log'); const pfx = kind==='error'?'Error: ': kind==='warn'?'Warning: ': ''; l.textContent = pfx + msg; }

    function doParseFromInput(text){ try{ const hex = inputToHexString(text); if(!hex) { log('No input', 'warn'); return; } const parsed = level5.cond.parsev3Cond(hex); renderParsed(parsed); log('Parsed OK.'); } catch(e){ log(e.message, 'error'); console.error(e); } }

    el('parseBtn').addEventListener('click', ()=> doParseFromInput(el('input').value));
    el('parseB64Btn').addEventListener('click', ()=>{ try{ const raw = el('input').value.trim(); if(/\s/.test(raw)) throw new Error('Base64 must not contain internal whitespace'); const dec = tryDecodeBase64(raw); const hex = Array.from(dec).map(c => (typeof c==='string' ? c.charCodeAt(0) : c).toString(16).padStart(2,'0')).join('').toUpperCase(); el('input').value = hexSpaced(hex); doParseFromInput(hex); } catch(e){ log('Base64 decode failed: '+e.message,'error'); } });

       el('sampleBtn').addEventListener('click', ()=>{ // random sample list
      let samples = [
                      '00 00 00 00 f0 3b 35 77 b4 63 e5 00 0a 01 28 00 06 02 32 00 00 00 01 32 00 00 00 01 78 35 77 b4 63 e5 00 0a 01 28 00 06 02 32 00 00 00 02 32 00 00 00 01 78 8f 35 77 b4 63 e5 00 0a 01 28 00 06 02 32 00 00 00 03 32 00 00 00 01 78 8f', /* random chain cond */
                      '00 00 00 00 0f 05 35 10 b1 40 96 00 01 00 32 00 00 00 01 78', /* main story completed yw2 simple format */
                      '00 00 00 00 18 05 35 2a 3d 45 43 00 0a 01 28 00 06 02 34 00 12 34 56 32 00 00 00 01 78', /* has flag 0x00123456 yw3; basic extended format */
                      '00 00 00 00 12 02 35 69 84 E3 AF 00 0A 01 28 00 06 02 34 96 49 FF 74', /* rare terminatorless and comparison valueless cond */
                      '00 00 00 00 1B 02 35 18 2B 37 5A 00 13 02 28 00 06 02 34 22 61 B7 8A 28 00 06 02 32 00 00 00 01', /* rare terminatorless cond */
                      '00 00 00 00 12 02 35 69 84 E3 AF 00 0A 01 28 00 06 02 34 0E 6B 6F 6B', /* redesign suggesting with resource ID :0 */
                      '00 00 00 00 36 05 35 74 03 A9 CE 00 1C 03 28 00 06 02 34 C1 B2 DA B7 28 00 06 02 34 8E 31 15 F3 28 00 06 02 32 00 00 0E F6 35 69 84 E3 AF 00 0A 01 28 00 06 02 34 42 6F A0 C3 8F', /* 3 resource IDs in the first condition */
                      '00 00 00 00 36 05 35 74 03 A9 CE 00 1C 03 28 00 06 02 34 C1 B2 DA B7 28 00 06 02 34 8E 31 15 F3 28 00 06 02 32 00 00 0E D8 35 69 84 E3 AF 00 0A 01 28 00 06 02 34 94 DE BD 45 8F', /* proper NEST EOCI handling in terminatorless conditions - aka just a random edge case test */
                      '00 00 00 00 48 08 35 74 03 A9 CE 00 1C 03 28 00 06 02 34 0C 24 46 3A 28 00 06 02 34 91 8A 8A 79 28 00 06 02 32 00 00 1A 9A 35 12 09 61 26 00 0A 01 28 00 06 02 32 00 00 1A A4 8F 35 69 84 E3 AF 00 0A 01 28 00 06 02 34 97 14 49 81 8F', /* chaotic best of a cond that has several edge cases for V3 parsing */
                      '00 00 00 00 18 05 35 8D 76 66 D8 00 0A 01 28 00 06 02 34 E5 96 D9 98 32 00 00 00 01 78', /* yw2 jetnayn appearcond (has bell) */
                      '00 00 00 00 09 02 35 7E E8 60 18 00 01 00', /* an extremely simple BATTLE_AI_ACT_CONDITION from yw2 */
                      'AAAAACcONd4X/hgAAQAyAAAD6HE1xlSO4wABADWF476vAAEAXTIAAAAecY8=', /* SV Snaggerjag Psychic Blasters Requirement Cond YW2 */
                      'AAAAAPA7NXe0Y+UACgEoAAYCMgAAAAEyAAAAAXg1d7Rj5QAKASgABgIyAAAAAjIAAAABeI81d7Rj5QAKASgABgIyAAAAAzIAAAABeI81d7Rj5QAKASgABgIyAAAABDIAAAABeI81d7Rj5QAKASgABgIyAAAABTIAAAABeI81d7Rj5QAKASgABgIyAAAABjIAAAABeI81d7Rj5QAKASgABgIyAAAABzIAAAABeI81d7Rj5QAKASgABgIyAAAACDIAAAABeI81d7Rj5QAKASgABgIyAAAACTIAAAABeI81d7Rj5QAKASgABgIyAAAACjIAAAABeI8=', /* hinozalls yw2 psychic blasters cond, demonstrates function calls emulating array access */
                    ];
      el('input').value = samples[Math.round(Math.random() * (samples.length - 1))];
      el('parseBtn').click();
    });
    
    el('clearBtn').addEventListener('click', ()=>{ el('input').value=''; el('tree').innerHTML=''; el('pseudo').textContent=''; el('log').textContent='Ready.'; });

    el('copyPseudoBtn').addEventListener('click', ()=>{ const txt = el('pseudo').textContent; if(!txt){ log('Nothing to copy','warn'); return;} navigator.clipboard?.writeText(txt).then(()=> log('Pseudocode copied to clipboard'), ()=> log('Copy failed','warn')); });

    el('downloadBtn').addEventListener('click', ()=>{ const pseudo = el('pseudo').textContent || ''; const blob = new Blob([pseudo], { type: 'text/plain' }); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = 'cond.txt'; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url); });

    // generate modal
    const generateModal = el('generateModal'); const condSelect = el('condSelect'); const extraInputs = el('extraInputs');
    Object.keys(condTemplates).forEach(key=>{ const opt = document.createElement('option'); opt.value = key; opt.textContent = condTemplates[key].label || key; condSelect.appendChild(opt); });

    function updateExtraInputs(){ // modal UI stuff lol
      extraInputs.innerHTML = ''; 
      const sel = condTemplates[condSelect.value]; 
      if(sel?.params){ 
        sel.params.forEach(p=>{ 
          const label = document.createElement('label'); 
          label.textContent = p.label + ': '; 
          let input;
         
          if (p.type === 'select' && Array.isArray(p.options)) {
            input = document.createElement('select');
            p.options.forEach(opt => {
              const o = document.createElement('option');
              o.value = opt.value;
              o.textContent = opt.label;
              input.appendChild(o);
            });
          } else {
            input = document.createElement('input');
            input.type = 'text';
            input.placeholder = p.placeholder || '';
          }
          
          input.id = 'param_' + p.name;
          input.style = 'margin-left:6px';
          label.appendChild(input);
          extraInputs.appendChild(label);
          extraInputs.appendChild(document.createElement('br'));
        });
      }
    }
    condSelect.addEventListener('change', updateExtraInputs); updateExtraInputs();

    el('generateBtn').addEventListener('click', ()=> generateModal.showModal()); el('closeModalBtn').addEventListener('click', ()=> generateModal.close());

    function intToHexNoPad(n){ const hex = n.toString(16).toUpperCase(); return hex.length % 2 ? '0'+hex : hex; }
    function parseBigEndianId(input){ let num; if(input.startsWith('0x')||input.startsWith('0X')) num = parseInt(input,16); else num = parseInt(input,10); if(isNaN(num)) throw new Error('Invalid flag ID'); num = (num >>> 0); const arr = new Uint8Array(4); const dv = new DataView(arr.buffer); dv.setUint32(0, num, false); return Array.from(arr).map(b=>b.toString(16).padStart(2,'0')).join(' ');
    }
    function parseItemId(input){ let num; if(input.startsWith('0x')||input.startsWith('0X')) num = parseInt(input,16); else num = parseInt(input,10); if(isNaN(num)) throw new Error('Invalid item ID'); num = (num >> 0); const arr = new Uint8Array(4); const dv = new DataView(arr.buffer); dv.setInt32(0, num, true); return Array.from(arr).map(b=>b.toString(16).padStart(2,'0')).join(' ');
    }

    el('generateCondBtn').addEventListener('click', ()=>{
      const selected = condTemplates[condSelect.value]; let finalText = selected.value || selected.template; try{
        if(selected.params){
          selected.params.forEach(p=>{
            let val = el('param_'+p.name).value.trim();
            if(p.name === 'RANK' || p.name === 'COUNT'){ 
              const intVal = parseInt(val,10); 
              if(isNaN(intVal)||intVal<0||intVal>255) throw new Error('Invalid '+p.label); 
              val = intToHexNoPad(intVal); 
            } 
            else if(p.name === 'ITEM'){ 
              val = parseItemId(val); 
            } 
            else if(p.name === 'FLAG'){ 
              val = parseBigEndianId(val); 
            }
            
            // Handle the select for FLAG_TYPE
            if(p.name === 'FLAG_TYPE'){
              finalText = finalText.replace('{RESOURCE_ID}', val);
            } else {
              finalText = finalText.replace('{'+p.name+'}', val);
            }
          });
         }
        el('input').value = finalText; generateModal.close(); el('parseBtn').click();
      } catch(err){ log('Generation failed: '+err.message,'error'); }
    });

    // light mode toggle
    el('lightMode').addEventListener('change', (ev)=>{ document.body.classList.toggle('light', ev.target.checked); });

  </script>
</body>
</html>
