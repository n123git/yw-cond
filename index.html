<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Yo-kai Watch Cond Parser</title>
  <style>
    .warning { color: #c77f00; font-weight: bold; }
    .error { color: #c00; font-weight: bold; }
    .muted { opacity: 0.6; }
    /* more lightly weathered cut copper - I mean light CSS lol */

    #pseudo {
      white-space: pre;
      font-family: monospace;
    }
    #pseudo span[data-off] {
      display: inline;
      padding: 2px 4px;
    }
    #pseudo span[data-off].highlight {
      background-color: yellow;
      transition: background 1s ease;
    }

    .highlight {
      background: yellow;
      transition: background 1s ease;
    }

    /* making a feature I added show that it exists more obviously */

    .tree-line {
      cursor: pointer;
      transition: background 0.2s ease;
      padding: 1px 3px;
      border-radius: 3px;
    }

    .tree-line:hover {
      background-color: rgba(100, 100, 255, 0.1);
      color: #333;
    }

    /* even more CSS magic! :0 */
    .tree-line::before {
      content: '→ ';
      opacity: 0.3;
      transition: opacity 0.2s ease;
    }

    .tree-line:hover::before {
      opacity: 0.7; 
    }

  </style>
</head>
<body style="font-family:monospace;padding:10px;">
  <h2>Yo-kai Watch Cond Parser</h2>

  <label for="input" class="muted">Paste hex (spaced or continuous), or Base64</label>
  <textarea id="input" placeholder="Paste hex (e.g. '00 0A 01') or base64 here" style="width:100%;min-height:140px"></textarea>

  <div id="controls">
    <button id="parseBtn" title="Parse input (Ctrl+Enter)">Parse</button>
    <button id="parseB64Btn" title="Try to decode input as Base64 then parse">Parse Base64</button>
    <button id="sampleBtn">Load Sample</button>
    <button id="clearBtn">Clear</button>
    <button id="copyPseudoBtn">Copy Pseudocode</button>
    <button id="downloadBtn">Download Psuedocode (cond.txt)</button>
    <button id="generateBtn">Generate Known Cond(s)</button>

    <label><input type="checkbox" id="expectTerm78"> Only accept 0x78 terminator</label>
    <label><input type="checkbox" id="strictMode"> Strict mode (stop on first warning)</label>
    <label><input type="checkbox" id="v2Parsing" checked> V2 parsing (More reliable but may fail)</label>
  </div>

  <pre id="log" aria-live="polite"></pre>
  <div id="tree" role="region" aria-label="Parsed tree"></div>

  <h3>Pseudocode Output</h3>
  <pre id="pseudo"></pre>

  <!-- Modal (hidden by default) -->
<dialog id="generateModal">
  <h3>Generate Known Cond(s)</h3>
  <label>
    Condition:
    <select id="condSelect">

    </select>
  </label>
  <div id="extraInputs"></div>
  <div style="margin-top: 10px;">
    <button id="generateCondBtn">Generate</button>
    <button id="closeModalBtn">Cancel</button>
  </div>
</dialog>
  <script>
    /* merged updates into v1.31 */
    const el = id => document.getElementById(id);
    let ver = 1.32;

    const hexChars = /^[0-9a-fA-F]+$/;

    function toHex(b){ return b.toString(16).padStart(2,'0').toUpperCase(); }
    function toHexWord(bytes){ if(!bytes) return '0x'; return '0x' + Array.from(bytes).map(toHex).join(''); }

    function log(msg, kind){
      const container = el('log');
      const prefix = kind === 'error' ? 'Error: ' : kind === 'warn' ? 'Warning: ' : '';
      const line = prefix + msg;
      container.textContent += line + '\n';
      container.scrollTop = container.scrollHeight;
    }
    function clearLog(){ el('log').textContent = ''; }
    normalizeInputRaw = text => (text||'').trim(); 

    function tryDecodeBase64(s){
      // support standard and URL-safe base64;
      try {
        return atob(s);
      } catch(e){
        try {
          const urlFixed = s.replace(/-/g, '+').replace(/_/g, '/');
          const pad = urlFixed.length % 4 === 0 ? urlFixed : urlFixed + '='.repeat(4 - (urlFixed.length % 4));
          return atob(pad);
        } catch(e2){
          throw new Error('Not valid base64');
        }
      }
    }

    function parseInputToBytes(text){
      text = normalizeInputRaw(text);
      if(!text) return new Uint8Array([]);

      // Check if it looks like hex first
      const hexCandidate = text.replace(/0x/gi,'')
                              .replace(/[:,\-<>]/g,'')
                              .replace(/\s+/g,'')
                              .trim();

      const isAllHex = /^[0-9a-fA-F]*$/.test(hexCandidate);
      if (isAllHex && hexCandidate.length % 2 === 0 && hexCandidate.length > 0) {
        // decode as continuous hex
        const arr = new Uint8Array(hexCandidate.length / 2);
        for(let i=0;i<arr.length;i++){
          const h = hexCandidate.substr(i*2,2);
          arr[i] = parseInt(h,16);
        }
        return arr;
      }

      // Otherwise, if it's probably b64, try to decode it
      const looksLikeBase64 = /^[A-Za-z0-9+\/=_\-]+$/.test(text) && !/[ \t\r\n:,\-<>]/.test(text);
      if (looksLikeBase64) {
        try {
          const decoded = tryDecodeBase64(text);
          const arr = new Uint8Array(decoded.length);
          for(let i=0;i<decoded.length;i++) arr[i] = decoded.charCodeAt(i);
          return arr;
        } catch(e){
          log('Base64 detection failed: ' + e.message, 'warn');
        }
      }

      const cleaned = text.replace(/0x/gi,'') 
                          .replace(/[:,\-<>]/g,' ') 
                          .replace(/\s+/g,' ') 
                          .trim();

      const parts = cleaned.split(' ');
      const bytes = new Uint8Array(parts.length);
      for(let i=0;i<parts.length;i++){
        const p = parts[i].trim();
        if(!hexChars.test(p)) throw new Error('Invalid hex token: "'+p+'"');
        if(p.length !== 2) throw new Error('Expected 2-hex-digit tokens when separated by spaces, got "'+p+'"');
        bytes[i]=parseInt(p,16);
      }
      return bytes;
    }


    class Reader{
      constructor(u8){ this.bytes = u8; this.pos = 0; }
      len(){ return this.bytes.length; }
      rem(){ return this.bytes.length - this.pos; }
      eof(){ return this.pos >= this.bytes.length; }
      read(n){ if(this.pos + n > this.bytes.length) throw new Error('Unexpected EOF at offset '+this.pos); const slice = this.bytes.slice(this.pos, this.pos+n); this.pos += n; return slice; }
      readByte(){ return this.read(1)[0]; }
      peekByte(){ return this.pos >= this.bytes.length ? null : this.bytes[this.pos]; }
      offset(){ return this.pos; }
      skip(n){ this.pos += n; }
    }

function parseCondStrict(bytes, opts = { force78: false, strict: false, v2: true }) {
  const r = new Reader(bytes);
  const result = {
    fields: [],
    warnings: [],
    errors: [],
    skipped: [],
    stopped: false
  };

  function addField(name, off, val, label) {
    result.fields.push({ name, off, val, label });
  }
  function warn(msg) {
    result.warnings.push({ msg });
    if (opts.strict) stop(`Strict mode: ${msg}`);
  }
  function error(msg) {
    result.errors.push({ msg });
    stop(msg);
  }
  function stop(reason) {
    result.stopped = true;
    throw new Error(reason);
  }

  const terminators = [0x71, 0x78, 0x6F, 0x79];

  // known resource IDs for labeling
  const knownResourceIDs = {
    '2A 3D 45 43': '- Check for flag (YW3)',
    '10 B1 40 96': '- Is Main Story Completed (YW2)',
    'DD 77 26 95': '- Watch Rank (YW2)',
    '8D 76 66 D8': 'Check if player has Item (YW2)'
  };

  function labelForResource(bytes) {
    if(!bytes) return undefined;
    const key = Array.from(bytes).map(toHex).join(' ');
    return knownResourceIDs[key];
  }

  function parseHeader() {
    const off = r.offset();
    const val = r.read(4);
    addField("HEADER", off, val);
  }

  // Pattern-based parsing helpers used by V2
  function parseSectionPattern() {
    const startOff = r.offset();
    const tag = r.readByte(); // consume 0x35
    addField("SECTION_START", startOff, new Uint8Array([tag]));
    if (r.rem() < 4) { warn("Truncated RESOURCE_ID in section at " + r.offset()); 
      if (r.rem() > 0) addField("TRUNCATED_RESOURCE_ID", r.offset(), r.read(r.rem()));
      return;
    }
    const resAOff = r.offset();
    const resA = r.read(4);
    addField("RESOURCE_ID_A", resAOff, resA, labelForResource(resA));

    if (r.rem() >= 3) {
      addField("CTYPE_A", r.offset(), r.read(3));
    } else {
      warn("Truncated CTYPE_A in section at " + r.offset());
    }

    if (r.peekByte() === 0x28) {
      addField("EXTENSION_DELIMITER", r.offset(), new Uint8Array([r.readByte()]));
      if (r.rem() >= 3) {
        const ctypeB = r.read(3);
        addField("CTYPE_B", r.offset()-3, ctypeB);
      } else warn("Truncated CTYPE_B");
      if (r.peekByte() === 0x34) {
        addField("NEST_DELIMITER_34", r.offset(), new Uint8Array([r.readByte()]));
        if (r.rem() >= 4) {
          const resBOff = r.offset();
          const resB = r.read(4);
          addField("RESOURCE_ID_B", resBOff, resB, labelForResource(resB));
        } else warn("Truncated RESOURCE_ID_B");
      }
    }

    if (r.peekByte() === 0x32) {
      addField("SECTION_END", r.offset(), new Uint8Array([r.readByte()]));
    } else {
      warn("Missing SECTION_END (0x32) after section at " + r.offset());
    }

    // parse comparisons / terminators / EOCI / linked parts
    while (r.rem() > 0) {
      const p = r.peekByte();
      if (p === 0x8F) {
        // Add EOCI but continue parsing (do not break) so linked conds are supported
        addField("EOCI", r.offset(), new Uint8Array([r.readByte()]));
        continue;
      }
      if (p === 0x35) break; // new section start -> return to main loop

      if (p === 0x32) {
        // Always SECTION_END (0x32). Following bytes may be comparison values.
        const off = r.offset();
        r.readByte();
        addField("SECTION_END", off, new Uint8Array([0x32]));
        if (r.rem() >= 4) {
          addField("COMPARISON_VALUE", r.offset(), r.read(4));
        } else {
          warn("Truncated comparison value after SECTION_END at " + r.offset());
          if (r.rem()>0) addField("TRUNCATED_REMAINDER", r.offset(), r.read(r.rem()));
        }
        continue;
      }

      if (terminators.includes(p)) {
        const off = r.offset();
        const b = r.readByte();
        addField("TERMINATOR", off, new Uint8Array([b]));
        if (opts.force78 && b !== 0x78) warn("Terminator not 0x78 while force78 enabled at " + off);
        continue;
      }

      if (r.rem() >= 4) {
        addField("COMPARISON_VALUE", r.offset(), r.read(4));
        continue;
      } else {
        if (r.rem() > 0) {
          addField("UNKNOWN_TRAILING", r.offset(), r.read(r.rem()));
        }
        break;
      }
    }
  }

  function parseCondCodePattern() {
    if (r.rem() < 2) return false;
    const off = r.offset();
    const lenByte = r.readByte();
    const typeByte = r.readByte();
    // label the condCode by the type byte
    let typeLabel;
    if (typeByte === 0x05) typeLabel = 'Normal Comparison';
    else if (typeByte === 0x0B) typeLabel = 'Type B Comparison';
    addField("CONDCODE", off, new Uint8Array([lenByte, typeByte]), typeLabel);

    // warn if unknown type byte
    if (![0x05, 0x0B].includes(typeByte)) {
      warn(`condCode type byte expected 0x05 or 0x0B, got ${toHex(typeByte)} at ${off + 1}`);
    }

    // IMPORTANT: length byte semantics: declared length includes the type byte,
    // so body length after the two header bytes is (lenByte - 1).
    const bodyLen = Math.max(0, lenByte - 1); // <-- length - 1 as requested
    const available = r.rem();
    if (available < bodyLen) {
      warn(`condCode declared ${lenByte} body bytes but only ${available} available at offset ${r.offset()}`);
    }

    const toRead = Math.min(bodyLen, available);
    const bodyBaseOff = r.offset();
    let bodyBytes = new Uint8Array(0);
    if (toRead > 0) bodyBytes = r.read(toRead);

    const tr = new Reader(bodyBytes);
    while (tr.rem() > 0) {
      const p = tr.peekByte();
      const curOff = bodyBaseOff + tr.offset();

      if (p === 0x35) {
        tr.readByte();
        addField("SECTION_START", curOff, new Uint8Array([0x35]));
        if (tr.rem() >= 4) {
          const resOff = curOff + 1;
          const res = tr.read(4);
          addField("RESOURCE_ID_A", resOff, res, labelForResource(res));
        } else { warn("Truncated RESOURCE_ID_A inside cond body at " + (curOff + 1)); if (tr.rem()>0) addField("TRUNCATED_RESOURCE_ID_A", curOff + 1, tr.read(tr.rem())); break; }

        if (tr.rem() >= 3) addField("CTYPE_A", bodyBaseOff + tr.offset(), tr.read(3));
        else warn("Truncated CTYPE_A inside cond body at " + (bodyBaseOff + tr.offset()));

        if (tr.peekByte() === 0x28) { 
          addField("EXTENSION_DELIMITER", bodyBaseOff + tr.offset(), new Uint8Array([tr.readByte()])); 
          if (tr.rem() >= 3) {
            const ctypeB = tr.read(3);
            addField("CTYPE_B", bodyBaseOff + tr.offset()-3, ctypeB);
          } else warn("Truncated CTYPE_B inside cond body at " + (bodyBaseOff + tr.offset()));
          if (tr.peekByte() === 0x34) {
            addField("NEST_DELIMITER_34", bodyBaseOff + tr.offset(), new Uint8Array([tr.readByte()]));
            if (tr.rem() >= 4) {
              const resBOff = bodyBaseOff + tr.offset();
              const resB = tr.read(4);
              addField("RESOURCE_ID_B", resBOff, resB, labelForResource(resB));
            } else warn("Truncated RESOURCE_ID_B inside cond body at " + (bodyBaseOff + tr.offset()));
          }
        }

        if (tr.peekByte() === 0x32) { 
          const seOff = bodyBaseOff + tr.offset();
          tr.readByte();
          addField("SECTION_END", seOff, new Uint8Array([0x32]));
        } else { warn("Missing SECTION_END (0x32) inside cond body at " + (bodyBaseOff + tr.offset())); }

        continue;
      }

      if (p === 0x32) {
        // treat 0x32 consistently as SECTION_END
        const seOff = curOff;
        tr.readByte();
        addField("SECTION_END", seOff, new Uint8Array([0x32]));
        if (tr.rem() >= 4) addField("COMPARISON_VALUE", bodyBaseOff + tr.offset(), tr.read(4));
        else { warn("Truncated comparison inside cond body at " + (bodyBaseOff + tr.offset())); if (tr.rem()>0) addField("TRUNCATED_REMAINDER", bodyBaseOff + tr.offset(), tr.read(tr.rem())); }
        continue;
      }

      if (terminators.includes(p)) {
        addField("TERMINATOR", curOff, new Uint8Array([tr.readByte()]));
        continue;
      }

      if (p === 0x8F) {
        // Add EOCI but DO NOT break — allow linked conds (TERMINATOR + EOCI will continue)
        addField("EOCI", curOff, new Uint8Array([tr.readByte()]));
        continue;
      }

      if (tr.rem() >= 4) {
        addField("COMPARISON_VALUE", bodyBaseOff + tr.offset(), tr.read(4));
        continue;
      } else {
        addField("UNKNOWN_BODY", bodyBaseOff + tr.offset(), tr.read(tr.rem()));
        break;
      }
    }

    if (bodyLen > toRead) {
      warn(`condCode declared ${bodyLen} body bytes but only ${toRead} were read at ${bodyBaseOff}`);
    }

    return true;
  }

  function parseCondBodyFallback() {
    while (r.rem() > 0) {
      const p = r.peekByte();
      if (p === 0x8F) {
        // Add EOCI but continue parsing to allow linked conds
        addField("EOCI", r.offset(), new Uint8Array([r.readByte()]));
        continue;
      }
      if (p === 0x35) return true;

      if (p === 0x32) {
        const off = r.offset();
        r.readByte();
        addField("SECTION_END", off, new Uint8Array([0x32]));
        if (r.rem() >= 4) addField("COMPARISON_VALUE", r.offset(), r.read(4));
        else warn("Truncated comparison");
        continue;
      }

      if (terminators.includes(p)) {
        const off = r.offset();
        const t = r.readByte();
        addField("TERMINATOR", off, new Uint8Array([t]));
        if (opts.force78 && t !== 0x78) warn("Unknown terminator " + toHex(t));
        continue;
      }

      if (r.rem() >= 4) {
        addField("COMPARISON_VALUE", r.offset(), r.read(4));
        continue;
      }

      warn("Unexpected byte " + toHex(p) + " at " + r.offset());
      result.skipped.push(r.offset());
      r.readByte();
      break;
    }
    return true;
  }

  try {
    while (r.rem() > 0 && !result.stopped) {
      if (r.rem() >= 4 && r.bytes.slice(r.pos, r.pos + 4).every(b => b === 0)) {
        parseHeader();
        continue;
      }

      const next = r.peekByte();
      if (next === 0x8F) {
        // Add EOCI and continue (linked conds)
        addField("EOCI", r.offset(), new Uint8Array([r.readByte()]));
        continue;
      }

      if (next === 0x35) {
        parseSectionPattern();
        continue;
      }

      if (opts.v2) {
        if (r.rem() < 2) {
          if (r.rem() > 0) { addField("TRAILING_BYTES", r.offset(), r.read(r.rem())); }
          break;
        }
        if (!parseCondCodePattern()) break;
        continue;
      } else {
        if (r.rem() < 2) break;
        const off = r.offset();
        const lenByte = r.readByte();
        const typeByte = r.readByte();
        let typeLabel;
        if (typeByte === 0x05) typeLabel = 'Normal Comparison';
        else if (typeByte === 0x0B) typeLabel = 'Type B Comparison';
        addField("CONDCODE", off, new Uint8Array([lenByte, typeByte]), typeLabel);
        if (![0x05, 0x0B].includes(typeByte)) warn(`condCode type byte expected 0x05 or 0x0B, got ${toHex(typeByte)} at ${off + 1}`);
        parseCondBodyFallback();
        continue;
      }
    }
  } catch (e) {
    if (!result.stopped) error(e.message);
  }

  return result;
}


    // Renderers
    function renderTree(parsed){
      const div=document.createElement('div');
      const first=document.createElement('div');
      first.textContent="// parsed with yw-cond v"+ver;
      div.appendChild(first);
      parsed.fields.forEach(f=>{
      const hex = Array.from(f.val || []).map(toHex).join(' ');
      const lbl = f.label ? ' ['+f.label+']' : '';
      const line=document.createElement('div');
      line.textContent = `${f.name + lbl} @${f.off}: ${hex}`;
      line.dataset.off = f.off; // <-- store offset for linking
      line.className = "tree-line";
      line.style.cursor = "pointer";
      line.addEventListener("click", () => {
        const target = document.querySelector(`#pseudo span[data-off="${f.off}"]`);
        if (target) {
            target.scrollIntoView({ behavior: "smooth", block: "center" });
            target.classList.add("highlight");
            setTimeout(() => target.classList.remove("highlight"), 1200);
        }
      });
      div.appendChild(line);
    });
    parsed.warnings.forEach(w=>{
      const ln=document.createElement('div');
      ln.className='warning';
      ln.textContent='Warning: '+w.msg;
      div.appendChild(ln);
    });
    parsed.errors.forEach(e=>{
      const ln=document.createElement('div');
      ln.className='error';
      ln.textContent='Error: '+e.msg;
      div.appendChild(ln);
    });
    if(parsed.skipped.length>0){
      const ln=document.createElement('div');
      ln.className='muted';
      ln.textContent='Skipped offsets: '+parsed.skipped.join(', ');
      div.appendChild(ln);
    }
    return div;
  }


function renderPseudo(parsed){ // copy pasted from my dev copy :3
  let out="// parsed using yw-cond v" + ver + "\n";
  const stack=[];
  let lineCount=0;
  function indent(){ return '  '.repeat(stack.length); }
  function maybeComment(){ if(++lineCount % 10 === 0) out += indent() + '// @' + (parsed.fields[lineCount-1]?.off||'?') + '\n'; }
  parsed.fields.forEach(f=>{
    const startTag = `<span data-off="${f.off}">`;
    const endTag = `</span>`;
    switch(f.name){
      case 'HEADER': out+=startTag+'#header '+toHexWord(f.val)+endTag+'\n'; break;
      case 'CONDCODE': out+=startTag+'#condCode '+toHexWord(f.val)+(f.label?' // '+f.label:'')+endTag+'\n'; break;
      case 'SECTION_START': out+=startTag+'start {'+endTag+'\n'; stack.push('start'); break;
      case 'RESOURCE_ID_A': out+=startTag+indent()+'RESOURCE_ID_A = '+toHexWord(f.val)+(f.label?(' // '+f.label):'')+endTag+'\n'; break;
      case 'CTYPE_A': out+=startTag+indent()+'CTYPE_A = '+toHexWord(f.val)+'\n'+indent()+'extendConditional(RESOURCE_ID_A, CTYPE_A)'+endTag+'\n'; break;
      case 'EXTENSION_DELIMITER': if(stack[stack.length-1]==='start'){ stack.pop(); out+='} '; } out+=startTag+'extend {'+endTag+'\n'; stack.push('extend'); break;
      case 'CTYPE_B': out+=startTag+indent()+'CTYPE_B = '+toHexWord(f.val)+endTag+'\n'; break;
      case 'NEST_DELIMITER_34': out+=startTag+indent()+'nest {'+endTag+'\n'; stack.push('nest'); break;
      case 'RESOURCE_ID_B': out+=startTag+indent()+'RESOURCE_ID_B = '+toHexWord(f.val)+(f.label?(' // '+f.label):'')+'\n'+indent()+'extendConditional(RESOURCE_ID_B, CTYPE_B)'+endTag+'\n'; if(stack[stack.length-1]==='nest'){ stack.pop(); out+=indent()+'}\n';} break;
      case 'SECTION_END': if(stack.length>0 && stack[stack.length-1]==='start'){ /* don't pop here; SECTION_END ends a section inside body */ } out+=startTag+'SECTION_END = '+toHexWord(f.val)+endTag+'\n'; break;
      case 'COMPARISON_VALUE': out+=startTag+indent()+'COMPARISON_VALUE = '+toHexWord(f.val)+'\n'+indent()+'compare(COMPARISON_VALUE)'+endTag+'\n'; break;
      case 'TERMINATOR': out+=startTag+indent()+'TERMINATOR = '+toHexWord(f.val)+';\n'+indent()+'terminate(TERMINATOR)'+endTag+'\n'; break;
      case 'EOCI': out+=startTag+indent()+'end-chain; // EOCI (End of Chain Instance)'+endTag+'\n'; break;
      case 'UNKNOWN_TRAILING': out+=startTag+indent()+'// UNKNOWN_TRAILING '+toHexWord(f.val)+endTag+'\n'; break;
      default: out+=startTag+indent()+'// '+f.name+' '+toHexWord(f.val)+endTag+'\n';
    }
    maybeComment();
  });
  return out;
}


    // UI actions
    function doParseFromInput(text, opts){ // why did I name it this way..........
      clearLog();
      el('tree').innerHTML = '';
      el('pseudo').textContent = '';
      try {
        const bytes = parseInputToBytes(text);
        log('Bytes: ' + bytes.length);
        const parsed = parseCondStrict(bytes, { force78: el('expectTerm78').checked, strict: el('strictMode').checked, v2: el('v2Parsing').checked });
        el('tree').appendChild(renderTree(parsed));
        el('pseudo').innerHTML = renderPseudo(parsed); // gotta love XSS risks js aside from being safe input this is all client side anyway - unless devtools console counts as a major security risk lmao :P
      } catch(e){
        log('Fatal: ' + e.message, 'error');
      }
    }

    el('parseBtn').addEventListener('click', ()=> doParseFromInput(el('input').value));

    el('parseB64Btn').addEventListener('click', ()=>{
      clearLog();
      try {
        const raw = el('input').value;
        const trimmed = raw.trim();
        // Strict check: refuse if trimmed contains whitespace or any illegal chars
        if (/\s/.test(trimmed)) { throw new Error('Input contains whitespace (Base64 must have no internal whitespace)'); }
        if (!/^[A-Za-z0-9+\/=_\-]+$/.test(trimmed)) { throw new Error('Input contains illegal Base64 characters'); }
        const decoded = tryDecodeBase64(trimmed);
        const hex = Array.from(decoded).map(c=>c.charCodeAt ? c.charCodeAt(0) : c).map(n=>n.toString(16).padStart(2,'0')).join(' ');
        el('input').value = hex;
        doParseFromInput(hex);
      } catch(e){
        log('Base64 decode failed: ' + e.message, 'error');
      }
    });

    el('sampleBtn').addEventListener('click', ()=>{
      el('input').value = '00 00 00 00 f0 3b 35 77 b4 63 e5 00 0a 01 28 00 06 02 32 00 00 00 01 32 00 00 00 01 78 35 77 b4 63 e5 00 0a 01 28 00 06 02 32 00 00 00 02 32 00 00 00 01 78 8f 35 77 b4 63 e5 00 0a 01 28 00 06 02 32 00 00 00 03 32 00 00 00 01 78 8f';
      el('parseBtn').click();
    });

    el('clearBtn').addEventListener('click', ()=>{
      el('input').value=''; clearLog(); el('tree').innerHTML=''; el('pseudo').textContent='';
    });

    el('copyPseudoBtn').addEventListener('click', ()=>{
      const txt = el('pseudo').textContent;
      if(!txt) { log('Nothing to copy', 'warn'); return; }
      navigator.clipboard?.writeText(txt).then(()=> log('Pseudocode copied to clipboard'), ()=> log('Copy failed', 'warn'));
    });

    el('downloadBtn').addEventListener('click', ()=>{
      const pseudo = el('pseudo').textContent || '';
      const blob = new Blob([pseudo], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'cond.txt';
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    });

    // keyboard shortcut: Ctrl+Enter to parse
    el('input').addEventListener('keydown', (ev)=>{
      if((ev.ctrlKey || ev.metaKey) && ev.key === 'Enter'){
        ev.preventDefault();
        el('parseBtn').click();
      }
    });

    // small check catch uncaught errors so they appear in log
    window.addEventListener('error', (ev)=> {
      log('Uncaught error: ' + (ev.error?.message || ev.message || ev), 'error');
    });
    let x = document.createElement("footer");
    document.body.appendChild(x) // archiving my stupidity again - I almost released this with: document.getElementsByTagName("body")[0].appendChild(x)
    x.outerHTML = `<footer style="font-size: large;">yw-cond. Version: <span id="vdisplay">${ver}</span></footer>`;

   const generateModal = el('generateModal');
  const condSelect = el('condSelect');
  const extraInputs = el('extraInputs');

const condTemplates = {
  mainStory: { 
    type: "b64",
    value: "AAAAAA8FNRCxQJYAAQAyAAAAAXg=",
    label: "Yo-kai Watch 2 – Main Story Completed"
  },
  rankXX: {
    type: "hex",
    template: "00 00 00 00 0f 05 35 dd 77 26 95 00 01 00 32 00 00 00 {RANK} 71",
    params: [{ name: "RANK", label: "Rank (00–FF)", placeholder: "e.g. 06" }],
    label: "Yo-kai Watch 2 – Rank XX or higher"
  },
  hasItem: {
    type: "hex",
    template: "00 00 00 00 18 05 35 8d 76 66 d8 00 0a 01 28 00 06 02 34 {ITEM} 32 00 00 00 01 78",
    params: [{ name: "ITEM", label: "Item ID (4-byte little endian)", placeholder: "e.g. 1678239 or 0x638297A etc" }],
    label: "Yo-kai Watch 2 – Has Item"
  },
  tunnelXX: {
    type: "hex",
    template: "00 00 00 00 18 05 35 9e 99 84 8c 00 0a 01 28 00 06 02 34 89 20 ff e7 32 00 00 00 {COUNT} 78",
    params: [{ name: "COUNT", label: "Times Beaten (00–FF)", placeholder: "e.g. 05" }],
    label: "Yo-kai Watch 2 – Beaten Infinite Tunnel XX Times"
  },
  npcFlagYW3: {
    type: "hex",
    template: "00 00 00 00 18 05 35 2a 3d 45 43 00 0a 01 28 00 06 02 34 {FLAG} 32 00 00 00 01 78",
    params: [
      { name: "FLAG", label: "Flag ID (4-byte big endian)", placeholder: "e.g. 12345678 or 0x00ABCDEF" }
    ],
    label: "Yo-kai Watch 3 - NPC Requires Flag"
  }
};


    condSelect.innerHTML = '';
Object.keys(condTemplates).forEach(key => {
  const opt = document.createElement('option');
  opt.value = key; // internal key still used for logic
  opt.textContent = condTemplates[key].label || key; // user-friendly name
  condSelect.appendChild(opt);
});

// update inputs for initial selection
updateExtraInputs();


  function updateExtraInputs() {
    extraInputs.innerHTML = "";
    const selected = condTemplates[condSelect.value];
    if (selected?.params) {
      selected.params.forEach(p => {
        const input = document.createElement("input");
        input.type = "text";
        input.placeholder = p.placeholder;
        input.id = "param_" + p.name;
        input.style = "margin-left:5px;";
        const label = document.createElement("label");
        label.textContent = p.label + ": ";
        label.appendChild(input);
        extraInputs.appendChild(label);
        extraInputs.appendChild(document.createElement("br"));
      });
    }
  }

  condSelect.addEventListener("change", updateExtraInputs);
  updateExtraInputs();

  el('generateBtn').addEventListener('click', () => generateModal.showModal());
  el('closeModalBtn').addEventListener('click', () => generateModal.close());

  // --- Helper Functions ---
  function intToHexNoPad(n) {
    const hex = n.toString(16).toUpperCase();
    return hex.length % 2 ? '0' + hex : hex; // ensure even number of digits
  }
function parseBigEndianId(input) {
  let num;
  if (input.startsWith("0x") || input.startsWith("0X")) {
    num = parseInt(input, 16);
  } else {
    num = parseInt(input, 10);
  }
  if (isNaN(num)) throw new Error("Invalid flag ID");
  num = (num >>> 0); // ensure unsigned 32-bit
  const arr = new Uint8Array(4);
  const dv = new DataView(arr.buffer);
  dv.setUint32(0, num, false); // false = big-endian
  return Array.from(arr).map(b => b.toString(16).padStart(2, "0")).join(" ");
}

  function parseItemId(input) {
    let num;
    if (input.startsWith("0x") || input.startsWith("0X")) {
      num = parseInt(input, 16);
    } else {
      num = parseInt(input, 10);
    }
    if (isNaN(num)) throw new Error("Invalid item ID");
    num = (num >> 0); // force to 32-bit signed
    const arr = new Uint8Array(4);
    const dv = new DataView(arr.buffer);
    dv.setInt32(0, num, true); // little endian
    return Array.from(arr).map(b => b.toString(16).padStart(2, "0")).join(" ");
  }

  el('generateCondBtn').addEventListener('click', () => {
    const selected = condTemplates[condSelect.value];
    let finalText = selected.value || selected.template;

    try {
      if (selected.params) {
selected.params.forEach(p => {
  let val = el("param_" + p.name).value.trim();
  if (p.name === "RANK" || p.name === "COUNT") {
    const intVal = parseInt(val, 10);
    if (isNaN(intVal) || intVal < 0 || intVal > 255) throw new Error("Invalid " + p.label);
    val = intToHexNoPad(intVal); // unpadded hex
  } else if (p.name === "ITEM") {
    val = parseItemId(val); // little-endian
  } else if (p.name === "FLAG") {
    val = parseBigEndianId(val); // big-endian
  }
  finalText = finalText.replace("{" + p.name + "}", val);
});

      }
      el('input').value = finalText;
      generateModal.close();
      doParseFromInput(finalText);
    } catch (err) {
      log("Generation failed: " + err.message, "error");
    }
  });
  </script>
</body>
</html>
