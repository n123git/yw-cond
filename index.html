<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>YW-Cond - Loading Version...</title>
  <style>
    :root{
      --bg:#0f1115; --panel:#0b0d10; --text:#e6eef6; --muted:#9aa6b2; --accent:#6ea8ff; --contaccent: #d08b00; --good:#8bd18b; --bad:#ff7b7b; --accent2: #5fb3ff; --funcaccent: #ffae54;  --true: #8bd18b; --false: #ff7b7b;
    }

/* Boolean highlighting :0 (How did I forget this.....) */
.true {
  color: var(--true);
}

.false {
  color: var(--false); /* lets ignore that this is the same color as a certain other one.... */
}

    .accent2 { color: var(--accent2); }
    .funcaccent { color: var(--funcaccent); }

    .contaccent { color: var(--contaccent); }
    body{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, monospace; margin:12px; color:var(--text); background:var(--bg);}
    .container{max-width:980px;margin:0 auto;padding:12px}
    h2{margin:0 0 8px 0}
    textarea{width:100%;min-height:120px;padding:8px;background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--text);}
    button{background:transparent;border:1px solid rgba(255,255,255,0.08);color:var(--text);padding:6px 8px;margin:4px;border-radius:6px;cursor:pointer}
    .controls{display:flex;flex-wrap:wrap;gap:6px;align-items:center;margin:8px 0}
    #log{white-space:pre-wrap;background:transparent;border:1px dashed rgba(255,255,255,0.03);padding:8px;min-height:36px;color:var(--muted)}
    .tree{background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent);padding:8px;border-radius:6px;margin-top:8px}
    .node{padding:6px;border-radius:4px;margin:2px 0;cursor:pointer}
    /* updated to work on light mode too (eugh) */
    .node:hover {
       background: rgba(255, 255, 255, 0.04);
       border: 1px solid transparent;
    }
  
    /* Light mode stuff :< */
    .light .node:hover {
      background: rgba(0, 0, 0, 0.08);
      border: 1px solid rgba(0, 0, 0, 0.08);
    }
    .light .node:active,
    .light .node.selected {
      background: rgba(0, 0, 0, 0.12);
      border: 1px solid rgba(0, 0, 0, 0.12);
    }


    .label{color:var(--accent);font-weight:600;margin-left:8px}
    .small{font-size:0.85em;color:var(--muted)}
    .muted{color:var(--muted)}
    .danger{color:var(--bad)}
    .ok{color:var(--good)}
    .pseudo{white-space:pre;background:transparent;border:1px solid rgba(255,255,255,0.03);padding:8px;border-radius:6px;margin-top:8px}

/* ====== Light Mode Enhancements ====== */
.light {
  --bg: #f4f6f8;
  --panel: #ffffff;
  --text: #222;
  --muted: #6b7280;
  --accent: #d08b00;
  --contaccent:#6ea8ff; /* --contaccent: #b07cff; */
  --good: #16803c;
  --bad: #cc3b3b;
}

/* Give light mode a faint shadowed feel to offset white */
.light body {
  background: linear-gradient(180deg, #fafafa, #f3f4f6);
}

/* Light mode textarea and pseudo blocks pop slightly */
.light textarea,
.light .pseudo {
  background: rgba(0, 0, 0, 0.02);
  border-color: rgba(0, 0, 0, 0.1);
}

/* Buttons and selects look more tactile in light mode */
.light button,
.light select {
  background: rgba(0, 0, 0, 0.02);
  border-color: rgba(0, 0, 0, 0.1);
}

.light button:hover,
.light select:hover {
  background: rgba(0, 0, 0, 0.06);
  border-color: rgba(0, 0, 0, 0.18);
}

    /* modal basics */
    dialog{border:1px solid rgba(0,0,0,0.08);background:var(--panel);color:var(--text);padding:12px;border-radius:8px}
    label{display:inline-block}
    input{padding:6px;border-radius:6px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:var(--text)}

    /* gotta add select/option CSS too */

    select { /* chevron sounds so fancy */
      padding: 6px;
      border-radius: 6px;
      border: 1px solid rgba(255, 255, 255, 0.04);
      background: transparent;
      color: var(--text);
      font-family: inherit;
      font-size: 0.95em;
      cursor: pointer;
      appearance: none; /* remove native arrow (for custom look) */
      background-image: linear-gradient(45deg, transparent 50%, var(--muted) 50%),
                        linear-gradient(135deg, var(--muted) 50%, transparent 50%);
      background-position: calc(100% - 16px) center, calc(100% - 12px) center;
      background-size: 5px 5px, 5px 5px;
      background-repeat: no-repeat;
      padding-right: 28px; /* space for arrow */
      transition: border-color 0.2s, background-color 0.2s;
    }
    
    select:hover, select:focus {
      border-color: rgba(255, 255, 255, 0.12);
      background-color: rgba(255, 255, 255, 0.02);
      outline: none;
    }
    
    option {
      background: var(--panel);
      color: var(--text);
      font-family: inherit;
    }

/* ====== Global smooth transitions ====== */
* {
  transition: background 0.25s ease, border-color 0.25s ease,
              color 0.25s ease, box-shadow 0.25s ease,
              transform 0.2s ease;
}

/* Button hover animation */
button:hover {
  background: rgba(255, 255, 255, 0.05);
  transform: translateY(-1px);
  box-shadow: 0 2px 4px rgba(0,0,0,0.2);
}
button:active {
  transform: translateY(0);
  box-shadow: none;
}

/* In light mode */
.light button:hover {
  background: rgba(0, 0, 0, 0.06);
  transform: translateY(-1px);
  box-shadow: 0 2px 6px rgba(0,0,0,0.15);
}

/* Node hover glow */
.node {
  transition: background 0.25s ease, transform 0.2s ease, border-color 0.25s ease;
}
.node:hover {
  transform: scale(1.01);
  background: rgba(255, 255, 255, 0.05);
}
.light .node:hover {
  background: rgba(0, 0, 0, 0.05);
}

/* Tree entry selection feedback */
.node.selected {
  border: 1px solid var(--accent);
  background: rgba(110, 168, 255, 0.1);
}

.light textarea:focus {
  box-shadow: 0 0 0 3px rgba(208, 139, 0, 0.2);
}

/* Pseudo-code block hover motion */
.pseudo:hover {
  transform: scale(1.01);
  border-color: rgba(255,255,255,0.08);
}
.light .pseudo:hover {
  border-color: rgba(0,0,0,0.1);
}



/*a*/
/* === 1. Accent glow only on labels (not on nodes) === */
@keyframes glow {
  0%, 100% { text-shadow: 0 0 4px var(--accent); }
  50%      { text-shadow: 0 0 10px var(--accent); }
}

.label:hover {
  animation: glow 1.5s ease-in-out infinite alternate;
}

/* Prevent nodes from glowing */
.node:hover, .node.selected {
  text-shadow: none;
}


/* === 2. Modal (dialog) Styling === */
dialog {
  border: 1px solid rgba(255,255,255,0.08);
  background: var(--panel);
  color: var(--text);
  padding: 16px 20px;
  border-radius: 10px;
  box-shadow: 0 12px 24px rgba(0,0,0,0.4);
  transition: transform 0.25s ease, opacity 0.25s ease;
  transform: translateY(-8px);
  opacity: 0;
}

dialog[open] {
  transform: translateY(0);
  opacity: 1;
}

/* Backdrop blur for modern feel */
dialog::backdrop {
  backdrop-filter: blur(4px) brightness(0.9);
  background: rgba(0,0,0,0.4);
}

/* Light mode dialog contrast */
.light dialog {
  border-color: rgba(0,0,0,0.08);
  box-shadow: 0 12px 24px rgba(0,0,0,0.15);
}

.light dialog::backdrop {
  backdrop-filter: blur(4px) brightness(1.05);
  background: rgba(255,255,255,0.45);
}

/* Modal buttons alignment */
dialog button {
  background: var(--panel);
  border-color: rgba(255,255,255,0.08);
}
dialog button:hover {
  background: rgba(255,255,255,0.06);
}
.light dialog button:hover {
  background: rgba(0,0,0,0.05);
}


/* === 3. Remove the bright blue focus ring & unify textarea focus === */
.param-input,
textarea,
select {
  outline: none;
  transition: border-color 0.25s ease, box-shadow 0.25s ease, transform 0.25s ease;
}

.param-input:focus,
textarea:focus,
select:focus {
  border-color: var(--accent);
  box-shadow: 0 0 0 3px color-mix(in srgb, var(--accent) 40%, transparent);
  transform: scale(1.01);
}

.light .param-input:focus,
.light textarea:focus,
.light select:focus {
  box-shadow: 0 0 0 3px color-mix(in srgb, var(--accent) 30%, transparent);
}


  </style>
</head>
<body>
  <div class="container" id="app">
    <h2>Yo-kai Watch Cond Parser <span class="small" id="ver2">Version Loading...</span></h2>
    <div class="small muted">Paste Hex or Base64; V3.2 Parsing, V2 Templates, V3 Psuedo</div>

    <textarea id="input" placeholder="Paste hex (e.g. '00 0A 01') or base64 here"></textarea>

    <div class="controls">
      <button id="parseBtn">Parse</button>
      <button id="parseB64Btn">Toggle Format</button>
      <button id="sampleBtn">Load Sample</button>
    <!--  <button id="clearBtn">Clear</button> removed to save UI space and in favour of Parse auto clearing if the input is empty -->
      <button id="copyPseudoBtn">Copy Pseudocode</button>
    <!--  <button id="downloadBtn">Download Pseudocode</button> removed because 1. save UI space 2. nobody's using it lol-->
      <button id="generateBtn">Generate Cond Template(s)</button> <!-- rename Generate Known Cond(s) to Generate Cond Template(s)-->
      <button id="configBtn">Config</button>
      <button id="mergeBtn">Merge Conds (BETA)</button> <!-- beta -->
      <!-- <label class="small muted" style="margin-left:8px"><input type="checkbox" id="lightMode"> Light mode</label> removed to save UI space and in favour of config-->
    </div>

    <div id="log" aria-live="polite">Ready.</div>
    <div id="base_warn" class="false"></div>
    <div style="display:flex;gap:12px;margin-top:12px;align-items:flex-start">
      <div style="flex:1">
        <div class="tree" id="tree" role="region" aria-label="Parsed tree"></div>
      </div>
      <div id="len3" style="width:46%">
        <div class="pseudo" id="pseudo"></div>
       <!-- <div class="funcaccent">Currently the psuedo-C implementation is bugged for certain conds; I have been ignoring this for a while but next update should fix it; for now I'm making it safer (It will show ?? in the cond when it's wrong)</div> -->
      </div>
    </div>

    <dialog id="generateModal">
      <h3>Generate Cond Template(s)</h3> <!-- rename Generate Known Cond(s) to Generate Cond Template(s)-->
      <label>Condition: <select id="condSelect"></select></label>
      <div id="extraInputs"></div>
      <div style="margin-top:10px"><button id="generateCondBtn">Generate</button> <button id="closeModalBtn">Cancel</button></div>
    </dialog>
  </div>

  <dialog id="configModal">
  <h3>Config!!!</h3>
  <h4 style="margin-top:10px; margin-bottom:6px; color:var(--accent);">QOL Tweaks</h4>

  <div style="margin-top:6px">
    <label style="display:block; margin-bottom:8px;">
      <input type="checkbox" id="showBoolChk"> 
      <strong>Detect Bool-like Values</strong> — display <code>1</code> / <code>0</code> as <code>true</code> / <code>false</code>.
    </label>

    <label style="display:block; margin-bottom:8px;">
      <input type="checkbox" id="showPowChk"> 
      <strong>Show Key Powers of 2</strong> — display power-of-two values (≥16) as hex (<code>0x</code>...).
    </label>

    <label style="display:block; margin-bottom:8px;">
      <input type="checkbox" id="showLimChk"> 
      <strong>Show Special Values</strong> — display max/special values as hex i.e. <code>255</code> = <code>0xFF</code>, <code>65535</code> = <code>0xFFFF</code>, etc.
    </label>

  <label style="display:block; margin-bottom:8px;">
    <input type="checkbox" id="shortenIfBlocksChk"> 
    <strong>Shorten If Blocks</strong> — insert "\n&nbsp;&nbsp;" after every || or && for if conditions > 65 chars.
  </label>
  </div> <!-- yeah it ws originaly in Appearence Tweaks which is why the codebase does this; also for modularity reasons my apperence section was programmed a bit better -->

  <label style="display:block; margin-bottom:8px;">
    <input type="checkbox" id="debugModeChk"> 
    <strong>Debug Mode</strong> — don't enable this unless something isnt working (in which case also DM me, @n123original on discord!)
  </label>

  <label style="display:block; margin-bottom:8px;">
    <input type="checkbox" id="simplifyCompilerArtifiactsChk"> 
    <strong>Simplify Operator Precedence Compiler Artifacts</strong> — turns 1 && artifacts produced by the compiler to introduce operator precedence into a more human readable form
  </label>

  <h4 style="margin-top:10px; margin-bottom:6px; color:var(--accent);">Appearence Tweaks</h4>

  <div style="margin-top:6px">
  <label style="display:block; margin-bottom:8px;">
    <input type="checkbox" id="lightMode"> 
    <strong>Light Mode</strong> — toggle light/dark theme for the UI (trust me; dark mode is better :P).
  </label>

  <label style="display:block; margin-bottom:8px;">
  <input type="checkbox" id="widePsuedoChk"> 
  <strong>Wide Psuedo</strong> — wider display for the Psuedo section.
</label>

  <label style="display:block; margin-bottom:8px;">
  <input type="checkbox" id="highlightPseudoChk"> 
  <strong>Syntax-Highlight Psuedo</strong> — very coolz :3
</label>

</div>

  <div style="margin-top:12px">
    <button id="configSaveBtn">Confirm</button>
    <button id="configCancelBtn">Cancel</button>
  </div>
</dialog>
<dialog id="mergeModal">
  <h3>Merge Conds</h3>

  <p class="small muted">
    Cond A = the main cond input.
  </p>

  <label>Cond B:<br>
    <textarea id="mergeInputB" style="width:100%;height:80px"></textarea>
  </label>

  <br/>

  <label>Combination Mode:<br>
    <select id="mergeMode" style="margin-bottom:8px">
      <option value="AND">AND</option>
      <option value="OR">OR</option>
      <option value="XNOR">XNOR/EQV</option>
      <option value="NAND">NAND</option>
    </select>
  </label>

  <div style="margin-top:12px">
    <button id="mergeDoBtn">Merge</button>
    <button id="mergeCancelBtn">Cancel</button>
  </div>
</dialog>

<div>
  <noscript>
    This should be obvious but uhh you kinda need JS for this page to work :P Search up "Enable JavaScript in Web Browser" to fix this if you somehow disabled it on accident :3
  </noscript>
</div>
  <script>

    if(typeof level5 === 'undefined') level5 = {};
    if(typeof level5.cond === 'undefined') level5.cond = {};

    // version
    level5.cond.ver = 1.398;
    document.title = `YW-Cond: v${level5.cond.ver}`; // finally auto-updating somewhat :3
    const el = id => document.getElementById(id); // gotta move it all the way up here
    el('ver2').innerText = `v${level5.cond.ver}` // wait no FULLY auto-updating after all this time :000

    if(typeof level5.cond._internals === 'undefined') level5.cond._internals = {};

    // manually labelled ones; some were before I decompiled it and some are just not in 1s
    const knownResourceIDs = {
      '2A 3D 45 43': 'GetGlobalBitFlag (FLAG_INFO_0; YW1/YW2/YW3/IEGO)', // output is always a boolean value in the int type (00 06 02); passed param is the FlagID as an int (00 06 02) in BE order
      '10 B1 40 96': 'GameClear (Is Main Story Completed; YW1/YW2)', // can be obtained from several places; one source (the first place this was found in) was Jungle Hunter shop conds, type: 00 01 00
      'DD 77 26 95': 'GetWatchRank (YW1/YW2)', // grabs player watch rank, 0 = E, ..., 5 = S
      '8D 76 66 D8': 'IsHaveItem (YW1/YW2)', // passed param is ItemID as an int (00 06 02) in LE order
      '9E 99 84 8C': 'GetGlobalByteFlag (FLAG_INFO_1; YW1/YW2/YW3)', // output is always an int (00 06 02); passed param is the FlagID as an int (00 06 02) in BE order
      'DE 17 FE 18': 'Lifetime Oni Orbs Collected in Psychic Blasters (YW2)',
      'B6 B8 67 71': 'GetActorHPRate (YW1/YW2)', // during battle; yokai targeted is dependent on the context of the cond executor - NOT the cond itself
      'B9 19 36 DA': 'GetPhase (YW1/YW2)', // now known as GetPhase - this exists in YW1, YW2 most likely YWB, YW3 and YWB2
      '37 90 0A 0D': 'Unique Yo-kai Cam Photos Taken (YW2)', // type: 00 01 00
      'C6 54 8E E3': 'Unique Bug Species Caught? (YW2)', // ? type: 00 01 00
      '85 E3 BE AF': 'Unique Fish Species Caught? (YW2)', // ? type: 00 01 00
      '83 DD D1 64': 'Psychic Blasters Oni Orbs High Score (YW2)',
      'BE 04 A5 98': 'GetQuestPhase (FF = Complete; YW1/YW2)', // FF = Complete
      '77 B4 63 E5': 'Grab Psychic Blasters Boss IsCleared (YW2)', // params: (int: index) 
      '3F FC EE 50': 'GetActorForwardToritukuGoodCountLowerCnt (YW1/YW2)', // if the passed param is 0, returns the amount of ally yokai WITHOUT a positive inspirit. Other param values lead to unknown results -- THIS WAS SLIGHTLY WRONG; actual namespace was GetActorForwardToritukuGoodCountLowerCnt and it takes no params dont know how I missed that :< --
      'EE CA 88 5A': 'YS_IsFind_Yokai (YW1/YW2)', // 2 param func, 2 params are IDs; example in load sample, used to check certain data, used in npc-set
      '48 A8 7F D3': 'YS_IsActive_Yokai (YW1/YW2)', // same but used to check a different state

      '27 32 6D 47': 'Is Trophy Complete? (YW2)', // params: TrophyID, returns bool, some trophies dont use this cond

      '74 03 A9 CE': 'Unk Func (YW2)', // 3 params, the first is a GlobalBitFlag, the 2nd is an unkID and the 3rd is a number i.e. 3830 (too small to be a phase); not in yw1

      'EC 2D FC E6': 'DroppedRareDrop? ParamID (YW2)', // param: ParamID; output: boolean int i.e. 0 or 1; // plug in kyryn to see if the bun of oness has been dropped
      '9E 6F 9F 21': 'Unk; related to Det.Holdit/Yo-Criminals (YW2)', // no params; returns a number

      // RESOURCE_ID_Bs (not Functions)

      // FlagIDs;

      // GlobalBitFlag(s)

        // Story Scenes
        '14 E8 5A 57': 'Checks if the story scene ev01_0200/ev01_0250 has been seen. (The Kin/Gin/Bronzlow scene at the start of the game; YW2)',
        'D6 2A 61 AB': 'Checks if the story scene ev01_1600 has been seen. (The scene where Nate/Katie chucks a capsule holding Whisper at the start of the game; YW2)',
        'C0 12 B2 F7': 'Checks if the story scene ev01_2000 has been seen. (The scene where Jibanyan gets run over; YW2)',
        'C6 D9 70 1C': 'Checks if the story scene ev01_2500 has been seen. (The scene where Nate summons Jibanyan against Brushido; YW2)',
        '91 7C ED AA': 'Checks if the story scene ev03_1800 has been seen. (The scene where Gargaros appears in Terror Time; occurs first during the story after Whatta Find is first entered; YW2)',
        '8C 18 79 CB': 'Checks if the story scene ev03_2100 has been seen. (The scripted scene where Gargaros chases the player to the exit; only occurs during the story after Whatta Find is first entered; YW2)',

        // Bonus Scenes
        '4D AC D4 0F': 'Checks if the bonus quest scene mv_photo77/yw2_evec_2100 has been seen. (YW2)',
        '54 B7 E5 4E': 'Checks if the bonus quest scene mv_photo78/yw2_evec_2110 has been seen. (YW2)',
        '7F 9A B6 8D': 'Checks if the bonus quest scene mv_photo79/yw2_evec_2120 has been seen. (YW2)',

        // Misc
        'C5 C2 5E 05': 'Checks if the Infinite Inferno has been cleared. (YW2)',
        '7D 24 ED 7D': 'Has Unlocked Everymart Discount. (YW2)',
        'AA 9C E0 F4': 'Has Jibanyan-S been met. (YW2)',
        'F9 2E B4 EC': 'Has Master Oden\'s Baffle Board been activated. (YW2)',

      // GlobalByteFlag(s)
      '89 20 FF E7': 'Infinite Tunnel Clear Count? (YW2)',
      'A9 38 C2 D5': 'Wanted Criminal Location/Data (YW2)', // Set it to 19-24 to make a Yo-Criminal appear in Shopper’s Row, 1-6 for Uptown Springdale, etc and 0 for None. The specific number changes which Yo-Criminal spawns.
      '3D EB CA B6': 'Leadoni Location/Data (YW2)',
      'C7 54 C3 0E': 'Soba Driver & Misc Location/Data (YW2)', // 1 for soba driver to appear
      '56 DF 31 58': 'Gargaros Defeat Count (Psychic Blasters Data; YW2)',
      'E9 2B 41 BB': 'Travelling Komasan Step/Location Data (YW2)', // for example 08 is at San Fantastico where he gives you the Oh My Swirls! Yo-kai Pad Wallpaper.
      '1B A5 DF 5D': 'Scratch-Off Data (YW2)',
    };
    level5.cond._manual = { ...knownResourceIDs }; // backup NOT reference; I originally tried to use .valueOf(); to fix it but that also returns a reference apparently; screw JS 
    const CExpressionInternalNames = [ // list of CExpression Functions; grouped based on similarities, NOT based on the order they are defined :)
      // yw::btl::ywBattleExpressionFunc
      'GetActorAgility',
      'GetActorAttack',
      'GetActorDefence',
      'GetActorHP', // does nothing if not in the right btl context; otherwise loops through all 12 actors; finds the one the context points to; grabs the HP of the selected yokai's part if it has parts otherwise grabs the HP of the yokai
      'GetActorHPRate', // same as GetActorHP but this one returns percentage int
      'GetActorPartsHP', // param: partIndex; does the same as 'GetActorHP' (still works for yokai without parts) but lets you specify what part to pick; if no params is passed and the yokai has parts; it picks the first part
      'GetActorPartsHPRate', // same as GetActorPartsHP but this one returns percentage int
      'GetActorMagic',
      'GetActorMode',

      'GetActorForwardCnt', // like all btl conds does nothing without right context; otherwise gets the amount of "forward" actorss
      'GetActorForwardAtkToritukuCnt',

      'GetActorForwardAverageHPRate',
      'GetActorForwardHighNeedSpSkillPointCnt',
      'GetActorForwardHighSpSkillRankCnt',
      'GetActorForwardHpRateHigherCnt',
      'GetActorForwardHpRateLowerCnt',

      'GetActorPartyAtkToritukuCnt',
      'GetActorPartyAverageHPRate',
      'GetActorPartyCnt',
      'GetActorPartyHpRateHigherCnt',
      'GetActorPartyHpRateLowerCnt',
      'GetActorPartyLastSpecialActionCountLowerCnt',

      'GetActorForwardLowNeedSpSkillPointHpRecoverCnt',
      'GetActorForwardLowSpSkillRankHpRecoverCnt',
      'GetActorForwardToritukuBadCountEqualCnt',
      'GetActorForwardToritukuBadCountHigherCnt',
      'GetActorForwardToritukuBadCountLowerCnt',
      'GetActorForwardToritukuGoodCountEqualCnt',
      'GetActorForwardToritukuGoodCountHigherCnt',
      'GetActorForwardToritukuGoodCountLowerCnt',

      'GetActorSpecialCancelOffset', // Looks up the actor’s current command in the battle command table (handles multi-part actors), fetches its special cancel offset, and writes it to CValue; returns 0 if no valid actor, part, or command exists.
    
      'GetActorToritukuBadCnt',
      'GetActorToritukuGoodCnt',
      'GetCommonAtkToritukuCnt',
      'GetCommonAverageHPRate',
      'GetCommonPartyCnt',
      'GetCommonToritukuBadCountOpCnt',
      'GetCommonToritukuGoodCountOpCnt',

      'GetPartyDeadCnt', // Counts dead party yokai (max 6), handles multi-part actors, loops over slots checking battle flags for alive/dead, writes total dead count to CValue

      'GetTargetForwardAtkElemDefFactorHigherCnt', // Counts forward enemy yokai whose elemental defense vs actor's current attack is <= threshold (default 100%), skipping dead, using part[0] if multi-part, writes count to outVar. TLDR; the amount of yokai weaker to the element than the current threshold 
      'GetTargetForwardAtkElemDefFactorLowerCnt',  // Counts forward enemy yokai whose elemental defense vs actor's current attack is >= threshold (default 100%), skipping dead, using part[0] if multi-part, writes count to outVar. TLDR; the amount of yokai less weak to the element than the current threshold 
      'GetTargetForwardAtkToritukuCnt',
      'GetTargetForwardChargeCnt',
      'GetTargetForwardCnt',

      'GetTargetForwardHpRateHigherCnt',  // params: (int: HPPercent) similar to GetActorHPRate; Counts the number of units (yokai/actors) on the relevant team whose current HP / max HP is greater than or equal to the specified percentage (int).
      'GetTargetForwardHpRateLowerCnt',   // params: (int: HPPercent) similar to GetActorHPRate; Counts the number of units (yokai/actors) on the relevant team whose current HP / max HP is less than or equal to the specified percentage (int).
      'GetTargetForwardAverageHPRate',

      'GetTargetForwardLowestDefence',
      'GetTargetForwardNormalGoodCnt',

      'GetTargetForwardToritukuBadCountEqualCnt',
      'GetTargetForwardToritukuBadCountHigherCnt',
      'GetTargetForwardToritukuBadCountLowerCnt',
      'GetTargetForwardToritukuGoodCountEqualCnt',
      'GetTargetForwardToritukuGoodCountHigherCnt', // small wrapper around GetCommonToritukuGoodCountOpCnt; returns amount of character that match the condition
      'GetTargetForwardToritukuGoodCountLowerCnt',

      'GetTargetPartyAtkToritukuCnt',
      'GetTargetPartyAverageHPRate',
      'GetTargetPartyChargeCnt',
      'GetTargetPartyCnt',
      'GetTargetPartyHpRateHigherCnt',
      'GetTargetPartyHpRateLowerCnt',
      'GetTargetPartyLowestDefence',
      'GetTargetPartyNormalGoodCnt',

      'IsActorMagicHpRecovery',
      'IsActorRegen',
      'IsActorSpecialHpRecovery',
      'IsActorToritukuBad',
      'IsActorToritukuGood',
      'IsCommandDamageDown',

      'IsTargetForwardMagicDamageDown',
      'IsTargetForwardWazaDamageDown',

      'DebugPrint', // safely no-opped; always returns 1 (true) in published games
      'GetFalse', // ??? not in yw::util::CExpression, but should be?

      // yw::ywGDExpressionFunc
      'GameClear', // returns 1 if the main story has been completed, 0 otherwise
      'GetChapter',
      'GetWatchRank',

      'GetGlobalBitFlag', // grabs the value of a FlagID - you can find them in FLAG_INFO_0; input: BE FlagID in XQ: get_global_bitflag()
      'GetGlobalByteFlag', // grabs the value of a FlagID - you can find them in FLAG_INFO_1; input: BE FlagID, returns 0 if something goes wrong i.e. the flag is null/dosent exist
      'GetTempBitFlag', // grabs the value of a FlagID - you can find them in FLAG_INFO_3; input: BE FlagID, returns 0 if something goes wrong i.e. the flag is null/dosent exist
      'GetTempByteFlag',
      'GetTempMapBitFlag', // depends on execution context; each map (that has Map flags) has it's own cfg.bin for these; sandboxed from the game-scoped one (data/res/sys/flag_config_0.01.cfg.bin)
      'GetTempMapByteFlag',

      'CheckQuestNecessaryCondition',
      'GetGlobalCharaCompFlagCRC',
      'GetGlobalCharaMetFlag',
      'GetGlobalTBoxFlag', // completely no-opped; dosent even return a value (atleast in yw1smartphone)

      'GetItemNum',
      'GetMoney', // in yen so: $\£\€1.23 = 123¥ which is also equal to 123₩
      'GetPartyNum',
      'GetPhase', // basically a massive number meaning lots of complex positions and stuff in the story; this WILL be a pain and sadly you WILL see it frequently :/
      'GetPlayerVarID', // no params; output of 2 = female; otherwise = male
      'GetQuestCompNum',
      'GetQuestPhase', // FF = Quest Complete; other phase nums are quest-dependant

      'GetTimeHour', // returns 0 if game time is null and if not the hour which is derived from (time in seconds) / 0x2A30; most likely returns 0-23
      'GetTimeNow', // returns -1 if the world isnt loaded, 3 if the game time is null otherwise either 0, 1, 2 or 3 (the repetition of 3 is intentional - it is the default time)
      'GetWeatherNow', // returns -1 if the world isnt loaded (GameManager::spRPGWorld == 0), 0 if the weather data ptr is null else weather byte as uint

      'InPartyMember', // input: (int: BaseID BE) returns 0 if the players party does not contain this yokai, else 1 (Uses CharaParamInfo)
      'IsApeearMitibiki', // typo is level5s fault not mine :/
         'IsAppearMitibiki', // this is not real, read the above one and then this comment: even though im 100% sure the ID will also include the typo, ill include the fixed version cuz why not :P

      'IsBicycleOn', // remember checks only happen when the condition is evaluated, for NPCs thats when the map loads, for shop items its when the shop is opened - dont expect a check using this function to update 60fps lmao (or 30fps outside of UIs this is the 3DS after all)
      'IsFullParty', // returns 0 (false) if party is null or isnt full, else 1 (true)
      'IsHaveItem', // pass the ItemID as BE, 1 (true) if the player has it, else 0 (false); internally just checks if the quantity is not 0
      'IsNpcUtil', // bruh; The function checks if the NPC with a given ID exists in spNpcCtrl, if a second param is provided and is equal to 1, it queries a specific bit flag on that NPC; Returns 1 or 0 based on these checks.

      'RunTrigger', // executes a trigger by it's ID (execution context dependant?) always returns 1 (true)
      'SetGlobalBitFlag', // FLAG_INFO_0; always returns 1 (true)
      'SetGlobalByteFlag', // FLAG_INFO_1; always returns 1 (true)
      'SetQuestPhase', // input: QuestID BE and int; sets the Quests phase to the passed int; phase FF = complete; function always returns 1 (true)
      'SetTempBitFlag', // input: FlagID and int; sets the temporary (non-global so not in flag_config) flag to the int; function always returns 1 (true)
      'SetTempByteFlag', // input: FlagID and int; sets the temporary (non-global so not in flag_config) flag to the int; function always returns 1 (true)
      'UpdateQuestPurpose', // updates some NPC stuff, quest stuff im too lazy to document this BUT I will laugh at one of level5s infamous typos: CScnObjRPGWorld::UpdataQuestMiniMapIcon

      'YS_CheckYokaiBaseID', // Input: BaseID; Returns 1 if the BaseID can be found in a Yo-kai Spot, else 0
      'YS_IsActive_Map', // Takes two IDs, one is a MapID and returns 1 or 0
      'YS_IsActive_Yokai', // wrapper for ywYokaispotStatus::IsActive_Yokai; returns 1 or 0
      'YS_IsFind_Map',
      'YS_IsFind_Yokai',
      'YS_IsFindFix',
      'YS_IsFindTmp',
      'YS_SetEnd',
      'YS_SetFind',


      // yw::util::CExpression
      // 100% only used internally but may as well
      'GetFloat',
      'GetLastValue',
      'GetResult',
      'GetS16',
      'GetS32',
      'GetS8',
      'GetStackValue',
      'GetU16',
      'GetU32',
      'GetU8',
        // yw::util::CExpression::CValue
        'GetProperValueType',
        'GetValueF32',
        'GetValueS16',
        'GetValueS32',
        'GetValueS32Direct', // Casts the result directly to a CValue, dosent check type, just grabs the value
        'GetValueS8',
        'GetValueU16',
        'GetValueU32',
        'GetValueU8',
        'IsFalse',
        'IsTrue',
        // I skipped alot because I'm lazy
        'SetValue',
        'SetValueF32',
        'SetValueS16',
        'SetValueS32',
        'SetValueS8',
        'SetValueU16',
        'SetValueU32',
        'SetValueU8',
   ]
   level5.cond.CExpressionInternalNames = CExpressionInternalNames;

   // CRC32 implementation (standard polynomial 0xEDB88320)
  function crc32(str) {
    let crc = 0 ^ (-1);

    for (let i = 0; i < str.length; i++) {
      crc = (crc >>> 8) ^ table[(crc ^ str.charCodeAt(i)) & 0xFF];
    }

    return (crc ^ (-1)) >>> 0;
  }

  // Precompute CRC32 table for speed
  const table = (() => {
    let c;
    const tbl = [];
    for (let n = 0; n < 256; n++) {
      c = n;
      for (let k = 0; k < 8; k++) {
        c = (c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1);
      }
      tbl[n] = c >>> 0;
    }
    return tbl;
  })();
     // got sidetracked optimising C++ code - so I ended up writing this code to free up 
    level5.cond.CExpressionInternalMappings = (() => {
      const temp = {};
      for (const funcName of CExpressionInternalNames) {
        const crc = crc32(funcName);
        const hexStr = crc.toString(16).padStart(8, '0').toUpperCase().match(/../g).join(' ');
        knownResourceIDs[hexStr] = funcName;
        temp[hexStr] = funcName;
      }
      return temp;
    })();

    level5.cond._internals.invert = function(obj) {
  const inverted = {};
  for (const key in obj) {
    if (obj.hasOwnProperty(key)) {
      inverted[obj[key]] = key;
    }
  }
  return inverted;
}
level5.cond.CExpressionInternalMappingsRev = level5.cond._internals.invert(level5.cond.CExpressionInternalMappings);

    // cond templates
    level5.cond.condTemplates = {
        mainStory: {
            type: "hex", // I dont even know what this does anymore......
            template: "00 00 00 00 0F 05 35 10 B1 40 96 00 01 00 32 00 00 00 {ACTIVATED} 78", // direct value
            params: [
                {
                    name: "ACTIVATED",
                    label: "State",
                    type: "select", // define a select
                    options: [ // with options
                        { label: "Completed", value: "01" }, 
                        { label: "Incomplete", value: "00" }
                    ]
                }
            ],
            label: "Yo-kai Watch 1/2 – Main Story" // label
            // no UI elements accept generate and cancel
        },
        gender: {
            type: "hex", // I dont even know what this does anymore......
            template: "00 00 00 00 0F 05 35 26 EF 79 C8 00 01 00 32 00 00 00 02 {GENCHECKOP}", // direct value
            params: [
                {
                    name: "GENCHECKOP",
                    label: "State",
                    type: "select", // define a select
                    options: [ // with options
                        { label: "Male", value: "79" }, // !=
                        { label: "Female", value: "78" } // ==
                    ]
                }
            ],
            label: "Yo-kai Watch 1/2/3 – Gender" // label
            // no UI elements accept generate and cancel
        },
       /* unmainStory: {
            type: "b64",
            value: "AAAAAA8FNRCxQJYAAQAyAAAAAHg=",
            label: "Yo-kai Watch 1/2 – Main Story Not Completed"
        }, */
        rankXX: {
            type: "hex",
            template: "00 00 00 00 0f 05 35 dd 77 26 95 00 01 00 32 00 00 00 {RANK} {MATCH}", // template
            params: [
                {
                    name: "MATCH",
                    label: "Match Type",
                    type: "select", // define a select
                    options: [ // with options
                        { label: "Atleast", value: "71" },
                        { label: "Exactly", value: "78" },
                        { label: "Not", value: "79" },
                        { label: "Under", value: "6E" },
                        { label: "Maximum of", value: "6F" },
                        { label: "Over", value: "70" }
                    ]
                },
                { 
                    name: "RANK", // define rank
                    label: "Rank (00–FF)", // UI label
                    inputType: "hex", // input treated as hex
                    max: 0xFF, // byte cap
                    padding: 0x1, // pad as byte
                    placeholder: "e.g. 5 for S, 0 for E" // UI input placeholder
                }
            ],
            label: "Yo-kai Watch 1/2 – Watch Rank" // label
        }, 
        photosTaken: {
            type: "hex",
            template: "00 00 00 00 0f 05 35 37 90 0A 0D 00 01 00 32 00 00 00 {PHOTOS} {MATCH}", // template
            params: [
                {
                    name: "MATCH",
                    label: "Match Type",
                    type: "select", // define a select
                    options: [ // with options
                        { label: "Atleast", value: "71" },
                        { label: "Exactly", value: "78" },
                        { label: "Not", value: "79" },
                        { label: "Under", value: "6E" },
                        { label: "Maximum of", value: "6F" },
                        { label: "Over", value: "70" }
                    ]
                },
                { 
                    name: "PHOTOS", // define rank
                    label: "Photos Taken (00–FF)", // UI label
                    inputType: "hex", // input treated as hex
                    max: 0xFF, // byte cap
                    padding: 0x1, // pad as byte
                    placeholder: "e.g. 5, 0, 112 etc" // UI input placeholder
                }
            ],
            label: "Yo-kai Watch 2 – Yo-kai Cam Photos Taken" // label
        },
        // 37 90 0A 0D
        chapterXX: {
            type: "hex",
            template: "00 00 00 00 0f 05 35 0A 52 7C E2 00 01 00 32 00 00 00 {CHAPTER} {MATCH}", // template
            params: [
                {
                    name: "MATCH",
                    label: "Match Type",
                    type: "select", // define a select
                    options: [ // with options
                        { label: "Atleast", value: "71" },
                        { label: "Exactly", value: "78" },
                        { label: "Not", value: "79" },
                        { label: "Under", value: "6E" },
                        { label: "Maximum of", value: "6F" },
                        { label: "Over", value: "70" }
                    ]
                },
                { 
                    name: "CHAPTER", // define rank
                    label: "Chapter (0-255)", // UI label
                    inputType: "default", // input NOT treated as hex by default
                    max: 0xFF, // byte cap
                    padding: 0x1, // pad as byte
                    placeholder: "e.g. 5, 7, 0x3 etc." // UI input placeholder
                }
            ],
            label: "Yo-kai Watch 1 - Chapter" // label
        },
        phase: {
            type: "hex",
            template: "00 00 00 00 0f 05 35 B9 19 36 DA 00 01 00 32 {PHASE} {MATCH}", // template
            params: [
                {
                    name: "MATCH",
                    label: "Match Type",
                    type: "select", // define a select
                    options: [ // with options
                        { label: "Atleast", value: "71" },
                        { label: "Exactly", value: "78" },
                        { label: "Not", value: "79" },
                        { label: "Under", value: "6E" },
                        { label: "Maximum of", value: "6F" },
                        { label: "Over", value: "70" }
                    ]
                },
                { 
                    name: "PHASE", // define rank
                    label: "Phase", // UI label
                    inputType: "default", // input NOT treated as hex by default
                    max: 0xFFFFFFFF, // byte cap
                    padding: 0x4, // pad as 4 bytes
                    byteCoerce: 0x4, // coerce to int32
                    placeholder: "e.g. 10010, 40135, 0xEA6A etc." // UI input placeholder
                }
            ],
            label: "Yo-kai Watch 1/2/4 - Phase" // label
        },
        hasItem: {
            type: "hex",
            template: "00 00 00 00 18 05 35 8d 76 66 d8 00 0a 01 28 00 06 02 34 {ITEM} 32 00 00 00 {ACTIVATED} 78",
            params: [
                { 
                    name: "ITEM", 
                    label: "Item ID (4-byte big endian)", 
                    inputType: "default",
                    padding: 0x4,
                    max: 0xFFFFFFFF,
                    byteCoerce: 4, // coerce to signed 32-bit integer
                    placeholder: "e.g. 1678239 or 0x638297A" 
                },
                {
                    name: "ACTIVATED",
                    label: "State",
                    type: "select", // define a select
                    options: [ // with options
                        { label: "Has Item", value: "01" }, // label-value, key-value pair except it's not just {'FLAG_INFO_0', '2A 3D 45 43'} for whatever reason.... dont question my very questionable code
                        { label: "Does Not Have Item", value: "00" }
                    ]
                }
            ],
            label: "Yo-kai Watch 1/2 – Items"
        },
        runTrigger: {
            type: "hex",
            template: "00 00 00 00 12 02 35 69 84 E3 AF 00 0A 01 28 00 06 02 34 {TRIGGER}",
            params: [
                { 
                    name: "TRIGGER", 
                    label: "Trigger ID (4-byte big endian)", 
                    inputType: "default",
                    padding: 0x4,
                    max: 0xFFFFFFFF,
                    byteCoerce: 4, // coerce to signed 32-bit integer
                    placeholder: "e.g. 1678239 or 0x638297A" 
                },
            ],
            label: "Yo-kai Watch 1/2/3 – Run Trigger"
        },
        tunnelXX: {
            type: "hex",
            template: "00 00 00 00 18 05 35 9e 99 84 8c 00 0a 01 28 00 06 02 34 89 20 ff e7 32 00 00 00 {COUNT} {MATCH}",
            params: [
                {
                    name: "MATCH",
                    label: "Match Type",
                    type: "select", // define a select
                    options: [ // with options
                        { label: "Atleast", value: "71" },
                        { label: "Exactly", value: "78" },
                        { label: "Not", value: "79" },
                        { label: "Under", value: "6E" },
                        { label: "Maximum of", value: "6F" },
                        { label: "Over", value: "70" }
                    ]
                },
                { 
                    name: "COUNT", 
                    label: "Times Beaten (00–FF)", 
                    inputType: "hex",
                    max: 0xFF,
                    padding: 0x1,
                    placeholder: "e.g. 03" 
                }
            ],
            label: "Yo-kai Watch 2/3 – Beaten Infinite Tunnel/Hazy Lane Count"
        },
        npcFlagYW3: {
            type: "hex",
            template: "00 00 00 00 18 05 35 {FLAG_TYPE} 00 0a 01 28 00 06 02 34 {FLAG} 32 00 00 00 {ACTIVATED} {MATCH}",
            altElements: [ // optional array of alternate param definitions
                {
                    name: "ACTIVATED",
                    label: "State (00-FF)",
                    inputType: "hex",
                    max: 0xFF,
                    padding: 0x1,
                    placeholder: "e.g. 03"
                },
                {
                    name: "MATCH",
                    label: "Match Type",
                    type: "select", // define a select
                    options: [ // with options
                        { label: "Atleast", value: "71" },
                        { label: "Exactly", value: "78" },
                        { label: "Not", value: "79" },
                        { label: "Under", value: "6E" },
                        { label: "Maximum of", value: "6F" },
                        { label: "Over", value: "70" }
                    ]
                },
            ],
            params: [
                {
                    name: "FLAG_TYPE",
                    label: "Flag Type",
                    type: "select",
                    options: [
                        { label: "FLAG_INFO_0 (GlobalBitFlag)", value: "2A 3D 45 43" }, // normal
                        { label: "FLAG_INFO_1 (GlobalByteFlag)", value: "9E 99 84 8C", altElements: [0, 1] }, // activates altElements[0] and altElements[1]
                        /* the func for FLAG_INFO_2 is no-opped atleast in 1s */
                        { label: "FLAG_INFO_3 (TempBitFlag)", value: "9F 35 86 B4" }, // normal 
                        { label: "FLAG_INFO_4 (TempByteFlag)", value: "BD F5 EB F0" }, // normal
                        { label: "MAP.FLAG_INFO_0 (TempMapBitFlag)", value: "32 14 7A 90"}, // normal
                        { label: "MAP.FLAG_INFO_1 (TempMapByteFlag)", value: "81 5B 2E DD"}, // normal
                    ]
                },
                {
                    name: "FLAG",
                    label: "Flag ID (4-byte big endian)",
                    inputType: "default",
                    padding: 0x4,
                    max: 0xFFFFFFFF,
                    byteCoerce: 4,
                    placeholder: "e.g. 12345678 or 0x00ABCDEF"
                },
                {
                    name: "MATCH",
                    label: "Match Type",
                    type: "select", // define a select
                    options: [ // with options
                        { label: "Exactly", value: "78" },
                    ]
                },
                {
                    name: "ACTIVATED",
                    label: "State",
                    type: "select",
                    options: [
                        { label: "Activated", value: "01" },
                        { label: "Deactivated", value: "00" }
                    ]
                }
            ],
            label: "Yo-kai Watch 1/2/3/4 - Flags"
        }
    };

    /* Templates V2.0 (+ a whole lot of suffering to get it to work) */
    level5.cond.TemplateManager = class {
        constructor(templates) {
            if (!templates || typeof templates !== 'object') {
                console.warn('TemplateManager: templates argument missing or invalid. Using empty object.');
                templates = {};
            }
            this.templates = templates;
        }

        get(key) {
            return this.templates[key];
        }

        populateSelect(selectEl) {
            if (!selectEl) throw new Error('populateSelect: selectEl is required');
            selectEl.innerHTML = '';

            const keys = Object.keys(this.templates);
            if (keys.length === 0) {
                const opt = document.createElement('option');
                opt.value = '';
                opt.textContent = 'No templates available';
                selectEl.appendChild(opt);
                return;
            }

            keys.forEach(key => {
                const tpl = this.templates[key] || {};
                const opt = document.createElement('option');
                opt.value = key;
                opt.textContent = tpl.label || key;
                selectEl.appendChild(opt);
            });
        }

        renderInputs(container, key) { // auggyhahkgayihuefoajeaioheafl SO MANY changes and copy pasting from different versions to get altElements to properly work..........
            container.innerHTML = '';
            const tpl = this.get(key);
            if (!tpl || !Array.isArray(tpl.params)) return;

const activeAltElements = {}; // tracks { altName: { replacedInput, originalInput } }

const renderParam = (param) => {
    let label = container.querySelector(`label[for=param_${param.name}]`);
    let input;

    if (!label) {
        label = document.createElement('label');
        label.setAttribute('for', `param_${param.name}`);
        label.textContent = param.label + ': ';
        container.appendChild(label);
        container.appendChild(document.createElement('br'));
    }

    input = label.querySelector(`#param_${param.name}`);
    if (!input) {
        if (param.type === 'select' && Array.isArray(param.options)) {
            input = document.createElement('select');
            param.options.forEach(opt => {
                const o = document.createElement('option');
                o.value = String(opt.value);
                o.textContent = opt.label;
                if (opt.altElements != null) o.dataset.altIndex = JSON.stringify(opt.altElements);
                input.appendChild(o);
            });
        } else {
            input = document.createElement('input');
            input.type = param.inputType === 'hex' ? 'text' : 'text';
            input.placeholder = param.placeholder || '';
            input.dataset.inputType = param.inputType || 'default';
            if (param.max) input.dataset.max = param.max;
            if (param.padding) input.dataset.padding = param.padding;
        }
        input.id = `param_${param.name}`;
        input.dataset.name = param.name;
        input.classList.add('param-input');
        input.style.marginLeft = '6px';
        label.appendChild(input);
    }

    // only attach change handler for selects with altElements
    if (param.type === 'select') {
        input.onchange = () => {
            const selectedOpt = input.selectedOptions[0];
            const idxStr = selectedOpt.dataset.altIndex;
            if (!idxStr || !tpl.altElements) {
                // revert any active alt elements for this param
                Object.entries(activeAltElements).forEach(([altName, data]) => {
                    if (data.replacedByParam === param.name) {
                        data.replacedInput.replaceWith(data.originalInput);
                        delete activeAltElements[altName];
                    }
                });
                return;
            }

            const indices = JSON.parse(idxStr);
            // remove old alt elements for this param first
            Object.entries(activeAltElements).forEach(([altName, data]) => {
                if (data.replacedByParam === param.name && !indices.includes(data.idx)) {
                    data.replacedInput.replaceWith(data.originalInput);
                    delete activeAltElements[altName];
                }
            });

            // add new alt elements
indices.forEach(i => {
    const altParam = tpl.altElements[i];
    const origInput = container.querySelector(`#param_${altParam.name}`);
    if (!origInput || activeAltElements[altParam.name]) return;

    let newInput;

    if (altParam.type === 'select' && Array.isArray(altParam.options)) {
        newInput = document.createElement('select');
        altParam.options.forEach(opt => {
            const o = document.createElement('option');
            o.value = String(opt.value);
            o.textContent = opt.label;
            newInput.appendChild(o);
        });
    } else {
        newInput = document.createElement('input');
        newInput.type = altParam.inputType === 'hex' ? 'text' : 'text';
        newInput.dataset.inputType = altParam.inputType || 'default';
        newInput.placeholder = altParam.placeholder || '';
        if (altParam.max) newInput.dataset.max = altParam.max;
        if (altParam.padding) newInput.dataset.padding = altParam.padding;
    }

    newInput.id = `param_${altParam.name}`;
    newInput.dataset.name = altParam.name;
    newInput.classList.add('param-input');
    newInput.style.marginLeft = '6px';

    origInput.replaceWith(newInput);
    activeAltElements[altParam.name] = { replacedInput: newInput, originalInput: origInput, replacedByParam: param.name, idx: i };
});

        };
    }
};

            
            tpl.params.forEach(renderParam);
        }

        getValues(container) {
            const inputs = container.querySelectorAll('[id^=param_]');
            const result = {};
            // this method single handedly made me want to- :<<<<<
            // so.... so many edge cases
            inputs.forEach(inp => {
                const name = inp.dataset.name;
                let value;

                // handle selects literally...
                if (inp.tagName.toLowerCase() === 'select') {
                    const selectedOpt = inp.options[inp.selectedIndex];
                    value = selectedOpt?.value ?? '';
                    result[name] = value;
                    return;
                }

                // read text
                value = inp.value.trim();
                if (typeof value !== 'string') value = String(value);

                const inputType = inp.dataset.inputType || 'default';
                const padBytes = parseInt(inp.dataset.padding || '0', 10);
                const byteCoerce = parseInt(inp.dataset.byteCoerce || '0', 10); // NEW
                let num;

                // parse numeric value
                if (inputType === 'hex') {
                    value = value.replace(/^0x/i, '').replace(/[^0-9A-Fa-f-]/g, '');
                    num = parseInt(value || '0', 16);
                } else {
                    // "default" — allow 0x prefix for hex
                    if (/^0x/i.test(value)) {
                        num = parseInt(value, 16);
                    } else {
                        num = parseInt(value, 10);
                    }
                }

                if (isNaN(num)) num = 0;

                // apply the max, if there is one
                const maxRaw = inp.dataset.max;
                let max = 0;
                if (maxRaw) {
                    max = /^0x/i.test(maxRaw)
                        ? parseInt(maxRaw, 16)
                        : parseInt(maxRaw, 10);
                }
                if (!isNaN(max) && max > 0 && num > max) num = max;
                
                // apply byteCoerce
                if (byteCoerce > 0) {
                    switch (byteCoerce) {
                        case 1: num = num & 0xFF; break; // unsigned 8-bit integer (uint8)
                        case 2: num = num & 0xFFFF; break; // unsigned 16-bit integer (uint16)
                        case 4: num = num >>> 0; break; // unsigned 32-bit integer (uint32)
                        default: throw new SyntaxError("Invalid byteCoerce value"); // fancy :3
                    }
                } else if (padBytes > 0) { // else use padding
                    if (padBytes === 1) num = num & 0xFF;
                    else if (padBytes === 2) num = num & 0xFFFF;
                    else if (padBytes === 4) num = num >>> 0;
                }
                
                if (padBytes > 0) { // create the output
                    let hex = (num >>> 0).toString(16).toUpperCase(); // ofc always treat as unsigned for padding
                    value = hex.padStart(padBytes * 2, '0')
                        .match(/.{1,2}/g)
                        .join(' ');
                } else {
                    if (inputType === 'hex' || inputType === 'default') {
                        value = num.toString(16).toUpperCase();
                    } else {
                        value = num.toString(10);
                    }
                }

                result[name] = value;
            });
        
            return result;
        }
        
        
        generate(key, params) {
            const tpl = this.get(key);
            if (!tpl) return null;

            let resultStr = tpl.value ?? tpl.template ?? '';

            if (tpl.template && params && typeof params === 'object') {
                Object.entries(params).forEach(([name, value]) => {
                    const token = new RegExp('\\{' + name + '\\}', 'g'); // escape curly braces properly
                    resultStr = resultStr.replace(token, value);
                });
            }

            return {
                type: tpl.type,
                value: resultStr,
                label: tpl.label,
            };
        }

    };
    level5.cond.templateManager = new level5.cond.TemplateManager(level5.cond.condTemplates); // init class

    /* UI schenaniganagaaggagagagagaggagagagaggagags */
    document.addEventListener('DOMContentLoaded', () => {
        const $ = el;

        const tmplMgr = level5.cond.templateManager; // instance of class NOT the actual class
        const generateModal = $('generateModal');
        const condSelect = $('condSelect');
        const extraInputs = $('extraInputs');

        if (!Object.keys(level5.cond.condTemplates).length) {
            console.info('no level5.cond.condTemplates :/ Current object:', level5.cond.condTemplates);
        }

        tmplMgr.populateSelect(condSelect);
        tmplMgr.renderInputs(extraInputs, condSelect.value);

        condSelect.addEventListener('change', () => tmplMgr.renderInputs(extraInputs, condSelect.value));

        $('generateBtn')?.addEventListener('click', () => generateModal.showModal());
        $('closeModalBtn')?.addEventListener('click', () => generateModal.close());

        $('generateCondBtn')?.addEventListener('click', () => {
            const key = condSelect.value;
            const params = tmplMgr.getValues(extraInputs);
            const result = tmplMgr.generate(key, params);
            if (!result) {
                alert('Invalid condition template!');
                return;
            }
            console.log("wow", result)
            el('input').value = result.value; // used innerText earlier lol; that broke some stuff somehow
            el('parseBtn').click();
            generateModal.close();
        });
    });

    // very basic utils
    function normalizeInputRaw(text){ return (text||'').trim(); }

    function tryDecodeBase64(s){
      try { return atob(s); } catch(e){ try { const urlFixed = s.replace(/-/g,'+').replace(/_/g,'/'); const pad = urlFixed.length % 4 === 0 ? urlFixed : urlFixed + '='.repeat(4 - (urlFixed.length % 4)); return atob(pad);} catch(e2){ throw new Error('Not valid base64'); } }
    }

    function inputToHexString(text){
      const t = normalizeInputRaw(text);
      if(!t) return '';
      // try continuous hex first
      const hexCandidate = t.replace(/0x/gi,'').replace(/[:,\-<>]/g,'').replace(/\s+/g,'').trim();
      if(/^[0-9a-fA-F]*$/.test(hexCandidate) && hexCandidate.length % 2 === 0 && hexCandidate.length>0) return hexCandidate.toUpperCase();
      // try base64 (no spaces)
      const looksLikeB64 = /^[A-Za-z0-9+\/=_\-]+$/.test(t) && !/\s/.test(t);
      if(looksLikeB64){
        try{ const dec = tryDecodeBase64(t); return Array.from(dec).map(c => (typeof c==='string' ? c.charCodeAt(0) : c).toString(16).padStart(2,'0')).join('').toUpperCase(); } catch(e){ /* fallthrough */ }
      }
      // fallback: split on spaces/tokens
      const cleaned = t.replace(/0x/gi,'').replace(/[:,\-<>]/g,' ').replace(/\s+/g,' ').trim();
      const parts = cleaned.split(' ');
      return parts.map(p => p.padStart(2,'0')).join('').toUpperCase();
    }

    // helper: format hex string into spaced groups
    function hexSpaced(h){ return (h||'').match(/.{1,2}/g)?.join(' ') || ''; }


level5.cond.settings = { // moved this to the back of the script
  showBool: true,
  showPow: true,
  showLim: true,
  /* even more new ones for config! */
  widePsuedo: false, // default off

   lightMode: false, // this was actually added first, but just now got reworked into settings for localStorage persistence, consistency and compactness
   shortenIfBlocks: true,
   shouldHighlightPsuedo: true, // why wouldn't you want this; it took a good 5 minutes to make how wasteful :P
   debugMode: false,
   simplifyCompilerArtifiacts: true, // still cant decide if this should be true or false by default
}

// Load settings from localStorage if available
const loadSettings = () => {
  const saved = localStorage.getItem('level5_cond_settings');
  if (saved) {
    try {
      const parsed = JSON.parse(saved);
      Object.assign(level5.cond.settings, parsed);
    } catch(e) {
      console.warn("Failed to parse settings from localStorage:", e);
    }
  }
};

// Save current settings to localStorage
const saveSettings = () => {
  localStorage.setItem('level5_cond_settings', JSON.stringify(level5.cond.settings));
};

// Initialize
loadSettings();

  level5.cond._internals.numberQOL = function(input) {
    if(input === 1 && level5.cond.settings.showBool) return `true`
    if(input === 0 && level5.cond.settings.showBool) return 'false'
   // if(input === -1) return 'undefined'
    if(input === 0xFF && level5.cond.settings.showLim) return `0xFF` // or -1?
    if(input === 0xFFFF && level5.cond.settings.showLim) return `0xFFFF` // or -1?
    if(input === 0xFFFFFF && level5.cond.settings.showLim) return `0xFFFFFF` // or -1?
    if(input === 0xFFFFFFFF && level5.cond.settings.showLim) return `0xFFFFFF` // or -1?
    if (input >= 16 && (input & (input - 1)) === 0 && level5.cond.settings.showPow) return '0x' + input.toString(16).toUpperCase(); // for powers of 2 >= 16
    return String(input);
  }

  // config modal.... yay who dosent love programming these :/
  const configBtn = document.getElementById('configBtn');
  const configModal = document.getElementById('configModal');
  const showBoolChk = document.getElementById('showBoolChk');
  const showPowChk = document.getElementById('showPowChk');
  const showLimChk = document.getElementById('showLimChk');
  const configSaveBtn = document.getElementById('configSaveBtn');
  const configCancelBtn = document.getElementById('configCancelBtn');
  
  const widePsuedoChk = document.getElementById('widePsuedoChk');
  const highlightPseudoChk = document.getElementById('highlightPseudoChk');
  let prevWidePsuedo = level5.cond.settings.widePsuedo;
  const debugModeChk = document.getElementById('debugModeChk');
  const simplifyCompilerArtifiactsChk = document.getElementById('simplifyCompilerArtifiactsChk');

// Map of appearance toggles
const appearanceToggles = [
  {
    checkbox: lightMode,
    settingKey: 'lightMode',
    apply: (checked) => document.body.classList.toggle('light', checked)
  },
  {
    checkbox: widePsuedoChk,
    settingKey: 'widePsuedo',
    apply: (checked) => {
      const elLen3 = el('len3');
      if (elLen3) elLen3.style.width = checked ? '65%' : '46%';
    }
  },
  {
    checkbox: shortenIfBlocksChk,
    settingKey: 'shortenIfBlocks',
    apply: (checked) => {} // it being applied is enough; no extra action is needed lol
  },
  {
    checkbox: highlightPseudoChk,
    settingKey: 'shouldHighlightPsuedo',
    apply: (checked) => {} // it being applied is enough; no extra action is needed lol
  },
  {
    checkbox: debugModeChk,
    settingKey: 'debugMode',
    apply: (checked) => {} // it being applied is enough; no click callback is needed (can't keep the comments consistnet for too long :P)
  },
  {
    checkbox: simplifyCompilerArtifiactsChk,
    settingKey: 'simplifyCompilerArtifiacts',
    apply: (checked) => {} // it being applied is enough; no click callback is needed (can't keep the comments consistnet for too long :P) (x2)
  },
];



// Open modal: sync checkboxes with current settings
configBtn.addEventListener('click', () => {
  prevWidePsuedo = level5.cond.settings.widePsuedo;

  // QOL checkboxes
  showBoolChk.checked = level5.cond.settings.showBool;
  showPowChk.checked  = level5.cond.settings.showPow;
  showLimChk.checked  = level5.cond.settings.showLim;

  // Appearance toggles
  appearanceToggles.forEach(toggle => {
    toggle.checkbox.checked = !!level5.cond.settings[toggle.settingKey];
    toggle.apply(toggle.checkbox.checked);

    // live preview while modal is open
    toggle.checkbox.onchange = (ev) => toggle.apply(ev.target.checked);
  });

  configModal.showModal();
});

// Confirm: save all settings
configSaveBtn.addEventListener('click', () => {
  // QOL
  level5.cond.settings.showBool = showBoolChk.checked;
  level5.cond.settings.showPow  = showPowChk.checked;
  level5.cond.settings.showLim  = showLimChk.checked;

  // Appearance
  appearanceToggles.forEach(toggle => {
    level5.cond.settings[toggle.settingKey] = toggle.checkbox.checked;
  });

  saveSettings();
  configModal.close();
});

// Cancel: revert changes
configCancelBtn.addEventListener('click', () => {
  appearanceToggles.forEach(toggle => {
    const value = level5.cond.settings[toggle.settingKey];
    toggle.checkbox.checked = !!value;
    toggle.apply(value);
  });
  configModal.close();
});

// Apply saved appearance settings immediately on load
appearanceToggles.forEach(toggle => toggle.apply(level5.cond.settings[toggle.settingKey]));


    // gotta organise this:

    // reads
    level5.cond.READ_MEMORY = "35";
    level5.cond.READ_LITERAL = "32";
    level5.cond.READ_HASH = "34";

    // extension markers?
    level5.cond.EXTENSION_DELIM = "28"; // not fully a read but helps with structure and is always near a READ_HASH
    // finally retired... level5.cond.UPRM = "5D"; // just the + operator but since I havent rewritten the parser to be more stack-oriented this is neccessary for now
    // EOCIs
    level5.cond.EOCI = "8F";
    level5.cond.AEOCI = "90"; // this exists....

    level5.cond.temp = {
      "32": "+const",  // push constant (int)  
      "33": "+const‑alt",   // push constant (int) alt ?
      "34": "+const‑float",  // push constant (float?)  
      "35": "call", // call function  
    }

    // Operators
    level5.cond.OPERATORS = [
      "46",  // ++ (increment)  
      "47",  // -- (decrement)  
      "50",  // ~ (bitwise NOT)  
      "51",  // ! (logical NOT)  
      "5A",  // * (multiply)  
      "5B",  // / (divide)  
      "5C",  // % (modulus)  
      "5D",  // + (add)  
      "5E",  // - (subtract)  
      "64",  // << (left shift)  
      "65",  // >> (right shift)  
      "6E",  // < (less than)  
      "6F",  // <= (less or equal)  
      "70",  // > (greater than)  
      "71",  // >= (greater or equal)  
      "78",  // == (equal)  
      "79",  // != (not equal)  
      "82",  // & (bitwise AND)  
      "83",  // | (bitwise OR)  
      "84",  // ^ (bitwise XOR)  
      "8F",  // && (logical AND)  
      "90",  // || (logical OR)  
      "96",   // TECHNICALLY  not an operator - but we'll consider it as one anyway; ?-> (conditional jump/ternary)  
      "97", // uncoditional jump (->)
      ];
    level5.cond.OPERATOR_LABELS = [
      "++",          // 0x46  
      "--",          // 0x47  
      "~",           // 0x50  
      "!",           // 0x51  
      "*",           // 0x5A  
      "/",           // 0x5B  
      "%",           // 0x5C  
      "+",           // 0x5D  
      "-",           // 0x5E  
      "<<",          // 0x64  
      ">>",          // 0x65  
      "<",           // 0x6E  
      "<=",          // 0x6F  
      ">",           // 0x70  
      ">=",          // 0x71  
      "==",          // 0x78  
      "!=",          // 0x79  
      "&",           // 0x82  
      "|",           // 0x83  
      "^",           // 0x84  
      "&&",          // 0x8F  
      "||",          // 0x90  
      "?->",          // TECHNICALLY  not an operator - but we'll consider it as one anyway; 0x96  
      "->", // 0x97
    ] // kept seperated into 2 arrays because I didnt want to risk breaking my old code

    level5.cond.L_OPERATORS = {
      "8F": "&&",
      "90": "||"
    }
    level5.cond.L_OPERATORS2 = [
      "&&",
      "||"
  ]

    level5.cond.OP_OPERAND_COUNT = {
      "++": 1,
      "--": 1,
      "~": 1,
      "!": 1,
      "*": 2,
      "/": 2,
      "%": 2,
      "+": 2,
      "-": 2,
      "<<": 2,
      ">>": 2,
      "<": 2,
      "<=": 2,
      ">": 2,
      ">=": 2,
      "==": 2,
      "!=": 2,
      "&": 2,
      "|": 2,
      "^": 2,
      "&&": 2,
      "||": 2,
      "?->": 1, // considered 1 for now due to technical reasons; this'll be changed later for now though its considered 1
      "->": 0 // same for this but 0
    }

    level5.cond.dataTypes = [
      "int8", // 0 (char)
      "uint8", // 1 (uchar)
      "int16", // 2 (short)
      "uint16", // 3 (ushort)
      "int32", // 4 (int)
      "uint32", // 5 (uint)
      "float", // 6 float32 (float)
      // rest are unknown rn
    ]
    level5.cond.DEFAULT_OPERATOR = "??"; // kinda true, kinda wrong

    // CTYPEs
    level5.cond.CTYPES = {
      "00 13 02": "2 Param Function",
      "00 1C 03": "3 Param Function",
      "00 0A 01": "1 Param Function", // since conds dont have an array/list type there will often be functions that are just getData(int: index)
      "00 06 02": "Int",
      "00 01 00": "0 Param Function",
    }
    level5.cond.DEFAULT_CTYPE = "(00 01 00?)"; // unconfirmed
    level5.cond.isFunction = (ctype) => {
      return ctype.toUpperCase().replace(/\s+/g,"") != "000602";
    }
    level5.cond.isFunc = level5.cond.isFunction; // simple alias because I cant make up my mind :P
    // LITERAL_VALUEs

    level5.cond.DEFAULT_LITERAL_VALUE  = level5.cond._internals.numberQOL(1); // (0x00000000) maybe??? confirm this
    // level5.cond.LITERAL_VALUE_LABELS is now deprecated in favour of level5.cond._internals.numberQOL
    level5.cond._internals.consumeBytes = function(hexStr, n){ const take = hexStr.slice(0, n*2); const rest = hexStr.slice(n*2); return [rest, take.toUpperCase()]; };
    level5.cond._internals.startsWith = function(hexStr, prefix){ return hexStr.slice(0, prefix.length).toUpperCase() === prefix.toUpperCase(); };

    level5.cond.parsev3Cond = function(inputHex){
      const $ = level5.cond._internals;
      let hex = (inputHex||'').replace(/\s+/g,'').toUpperCase();
      const parsedCond = [];
      function err(msg, hexSuffix){ const ctx = hexSuffix ? (' (next: '+hexSuffix+')') : ''; throw new SyntaxError(msg + ctx); }

      function parseHeader(){ if(hex.length < 12) err('Too short for header dat', hex.slice(0,9)); if(!$.startsWith(hex,'000000') && !$.startsWith(hex,'000000')) err('Are you sure this is a real cond? Header invalid (expected 000000)'); let consumed; [hex, consumed] = $.consumeBytes(hex,3); const headerBlock = [['HEADER', consumed]]; [hex, consumed] = $.consumeBytes(hex,2); headerBlock.push(['COND_LENGTH', consumed]); [hex, consumed] = $.consumeBytes(hex,1); headerBlock.push(['STACK_PRM', consumed]); parsedCond.push(['HEADER_BLOCK', headerBlock]); }

      function parseClause(){ 
        if(hex.length < 2) err('Unexpected EOF while expecting READ_MEMORY or READ_LITERAL');
        // add operator check?

        if ( // done past me :P
          !$.startsWith(hex, level5.cond.READ_MEMORY) &&
          !$.startsWith(hex, level5.cond.READ_LITERAL) &&
          !level5.cond.OPERATORS.includes(hex.slice(0, 2))
        ) {
          err('Clause must start with READ_MEMORY, READ_LITERAL, or OPERATOR', hex.slice(0,2));
        }

        if (level5.cond.L_OPERATORS[hex.slice(0, 2)]) {
          // stop clause parsing immediately; let top-level consume it
          return;
        }


        // handle OPERATOR as a clause starter
      /*  if (level5.cond.OPERATORS.includes(hex.slice(0, 2))) {
          const clause = [];
          let consumed;
          [hex, consumed] = $.consumeBytes(hex, 1);
          clause.push(['OPERATOR', consumed]);
          
          // optional: operators might be followed by another READ_MEMORY / READ_LITERAL clause
          if ($.startsWith(hex, level5.cond.READ_MEMORY) || $.startsWith(hex, level5.cond.READ_LITERAL)) {
            // Recursively parse the next clause
            parsedCond.push(['CONDITION', clause]);
            parseClause();
            return;
          }
          
          // otherwise just treat it as a standalone operator clause
          parsedCond.push(['CONDITION', clause]);
          return;
        }*/ // sunset technique

if (level5.cond.OPERATORS.includes(hex.slice(0, 2))) {
  const clause = [];
  let consumed;

// Loop through all consecutive operators
while (level5.cond.OPERATORS.includes(hex.slice(0, 2))) {
  const nextOp = hex.slice(0, 2);

  // If we hit an L_OPERATOR, stop clause and leave it for top-level
  if (level5.cond.L_OPERATORS[nextOp]) {
    parsedCond.push(['CONDITION', clause]);
    return;
  }

  // Otherwise, consume and add
  [hex, consumed] = $.consumeBytes(hex, 1);
  clause.push(['OPERATOR', consumed]);
}

  // After all operators, optionally parse next READ_MEMORY/READ_LITERAL
  if ($.startsWith(hex, level5.cond.READ_MEMORY) || $.startsWith(hex, level5.cond.READ_LITERAL)) {
    parsedCond.push(['CONDITION', clause]);
    parseClause(); // recursive call handles the next clause
    return;
  }

  // If nothing follows, close the condition
  parsedCond.push(['CONDITION', clause]);
  return;
}


        // temp READ_LITERAL logic; might not work in all cases; I should add V2 fallback parsing

        if($.startsWith(hex, level5.cond.READ_LITERAL)){
          const clause = []; let consumed;
          [hex, consumed] = $.consumeBytes(hex,1); clause.push(['READ_LITERAL', consumed]);
          if(hex.length < 8) err('Truncated LITERAL_VALUE', hex.slice(0,8));
          [hex, consumed] = $.consumeBytes(hex,4); clause.push(['LITERAL_VALUE', consumed]);

          if(hex.length < 2) {
            parsedCond.push(['CONDITION', clause]);
            return;
          } //  err('Unexpected EOF after LITERAL_VALUE');
        
          if ($.startsWith(hex, level5.cond.READ_LITERAL)) {
            // Do NOT consume it here; let outer logic handle it
            parsedCond.push(['CONDITION', clause]);
            return;
          }

        
          if($.startsWith(hex, level5.cond.READ_MEMORY)){
              parsedCond.push(['CONDITION', clause]); 
              parseClause();                          
              return; // A.
          }


       /*   if(level5.cond.OPERATORS.includes(hex.slice(0,2))){
            [hex, consumed] = $.consumeBytes(hex,1); clause.push(['OPERATOR', consumed]); 
            parsedCond.push(['CONDITION', clause]); return;
          } // e.
*/
if (level5.cond.OPERATORS.includes(hex.slice(0,2))) {
  let consumed;

  // Consume operators one by one, but stop if we hit an L_OPERATOR
  while (level5.cond.OPERATORS.includes(hex.slice(0,2))) {
    const nextOp = hex.slice(0,2);

    // L_OPERATOR → stop clause, leave it for top-level
    if (level5.cond.L_OPERATORS[nextOp]) {
      parsedCond.push(['CONDITION', clause]);
      return;
    }

    // Normal operator → consume and attach
    [hex, consumed] = $.consumeBytes(hex,1);
    clause.push(['OPERATOR', consumed]);
  }

  // Push the completed clause
  parsedCond.push(['CONDITION', clause]);
  return;
}
 // e. // sunset technique

          err('Expected READ_LITERAL or READ_MEMORY after LITERAL_VALUE', hex.slice(0,2));
        }
        if(!$.startsWith(hex, level5.cond.READ_MEMORY)) err('Clause must start with READ_MEMORY', hex.slice(0,2)); 
        const clause = []; let consumed; 
        [hex, consumed] = $.consumeBytes(hex,1); clause.push(['READ_MEMORY', consumed]); 
        if(hex.length < 8) err('Truncated RESOURCE_ID_A', hex.slice(0,8)); 
        [hex, consumed] = $.consumeBytes(hex,4); clause.push(['RESOURCE_ID_A', consumed]); 
        if(hex.length < 6) err('Truncated CTYPE_A', hex.slice(0,6)); 
        [hex, consumed] = $.consumeBytes(hex,3); clause.push(['CTYPE_A', consumed]);
      
        while(hex.length > 0){ 
          const nextByte = hex.slice(0,2);
        /*  if($.startsWith(hex, level5.cond.UPRM)) {
          let consumed;
          [hex, consumed] = $.consumeBytes(hex,1); clause.push(['URRM', consumed]);
          } */ // finally retired
          if($.startsWith(hex, level5.cond.READ_LITERAL)){
            [hex, consumed] = $.consumeBytes(hex,1); clause.push(['READ_LITERAL', consumed]); 
            if(hex.length < 8) err('Expected LITERAL_VALUE after READ_LITERAL', hex.slice(0,8));
            [hex, consumed] = $.consumeBytes(hex,4); clause.push(['LITERAL_VALUE', consumed]); 
if (hex.length === 0) {// no I did not copy this from a different version of my parser - why would you assume that? :P
  // end-of-input: finish condition
  parsedCond.push(['CONDITION', clause]);
  return;
}

if (hex.length < 2) {
  // still an unexpected truncated byte (unlikely because we handled length === 0 above)
  err('After LITERAL_VALUE found unexpected truncated byte', hex.slice(0,2));
}

const afterComp = hex.slice(0,2);

// Another READ_LITERAL after the comparison indicates another comparison follows.
// do NOT consume the READ_LITERAL here because top-level parsing expects to see READ_LITERAL and will consume it :<
if ($.startsWith(hex, level5.cond.READ_LITERAL)) {
  // allow the parse to loop so the subsequent LITERAL_VALUE is handled normally (fancy words :0 lol)
  continue;
}

/*// OPERATOR -> consume it and finish this condition
if (level5.cond.OPERATORS.includes(afterComp)) {
  [hex, consumed] = $.consumeBytes(hex,1);
  clause.push(['OPERATOR', consumed]);
  parsedCond.push(['CONDITION', clause]);
  return;
}*/
// OPERATOR -> consume all consecutive operators and finish this condition
while (level5.cond.OPERATORS.includes(hex.slice(0,2))) {
  const nextOp = hex.slice(0,2);

  // Treat L_OPERATOR as global op: push and return without consuming
  if (level5.cond.L_OPERATORS[nextOp]) {
    parsedCond.push(['CONDITION', clause]);
    return;
  }

  // Normal operator: consume and add to clause
  [hex, consumed] = $.consumeBytes(hex,1);
  clause.push(['OPERATOR', consumed]);
}

// Push the clause once, as in original
parsedCond.push(['CONDITION', clause]);
return; // sunset technique
/*
// EOCI -> consume and finish this condition
if ($.startsWith(hex, level5.cond.EOCI)) {
//  [hex, consumed] = $.consumeBytes(hex,1);
//  clause.push(['EOCI', consumed]);
  parsedCond.push(['CONDITION', clause]);
  return;
}

// AEOCI -> consume and finish this condition
if ($.startsWith(hex, level5.cond.AEOCI)) {
  parsedCond.push(['CONDITION', clause]);
  return;
}*/ // finally retired
/*if($.startsWith(hex, level5.cond.UPRM)) { // just in case - this has never been proved to actually occur 
  let consumed;
  [hex, consumed] = $.consumeBytes(hex,1); clause.push(['UPRM', consumed]);
}*/ // finally retired

// READ_MEMORY -> do NOT consume it here; close this condition and let the outer loop handle the new clause
if ($.startsWith(hex, level5.cond.READ_MEMORY)) {
  parsedCond.push(['CONDITION', clause]);
  return;
}

// Otherwise it's still unexpected
err('After LITERAL_VALUE expected READ_LITERAL, OPERATOR, EOCI, READ_MEMORY, or end-of-input but found', afterComp);

          }
          else if($.startsWith(hex, level5.cond.EXTENSION_DELIM)){
            [hex, consumed] = $.consumeBytes(hex,1); clause.push(['EXTENSION_DELIM', consumed]); 
            if(hex.length < 6) err('Expected CTYPE_B after EXTENSION_DELIM', hex.slice(0,6)); 
            [hex, consumed] = $.consumeBytes(hex,3); clause.push(['CTYPE_B', consumed]); 
            continue;
          }
          else if($.startsWith(hex, level5.cond.READ_HASH)){
            [hex, consumed] = $.consumeBytes(hex,1); clause.push(['READ_HASH', consumed]); 
            if(hex.length < 8) err('Expected RESOURCE_ID_B after READ_HASH', hex.slice(0,8)); 
            [hex, consumed] = $.consumeBytes(hex,4); clause.push(['RESOURCE_ID_B', consumed]); 
            continue;
          }
        /*  else if(level5.cond.OPERATORS.includes(nextByte)){
            [hex, consumed] = $.consumeBytes(hex,1); clause.push(['OPERATOR', consumed]); 
            parsedCond.push(['CONDITION', clause]); return; */
else if (level5.cond.OPERATORS.includes(nextByte)) {
  let consumed;

  // Consume operators one at a time, but stop if an L_OPERATOR appears
  while (level5.cond.OPERATORS.includes(hex.slice(0, 2))) {
    const opByte = hex.slice(0, 2);

    // L_OPERATOR -> stop here (:000), don't consume it
    if (level5.cond.L_OPERATORS[opByte]) {
      parsedCond.push(['CONDITION', clause]);
      return;
    }

    // Normal operator -> consume and attach
    [hex, consumed] = $.consumeBytes(hex, 1);
    clause.push(['OPERATOR', consumed]);
  }

  parsedCond.push(['CONDITION', clause]);
  return;
}  else {
            parsedCond.push(['CONDITION', clause]); return;
            err('Unknown byte in CLAUSE (unable to progress parse)', nextByte);
          }
        }

        /*
                  if
              */
        // fallback: push clause even if there isnt a OPERATOR but complain (7 warns if you're debugging this oh and sorry for your loss...)
        console.warn("no OPERATOR :<<<" + clause);
                console.warn("no OPERATOR :<<<" + clause);
                        console.warn("no OPERATOR :<<<" + clause);
                                console.warn("no OPERATOR :<<<" + clause);
                                        console.warn("no OPERATOR :<<<" + clause);
                                                console.warn("no OPERATOR :<<<" + clause);
                                                        console.warn("no OPERATOR :<<<" + clause);

        parsedCond.push(['CONDITION', clause]); 
        return;
      }


      // top-level header - not per condition but per cond; I totally didnt forget about the strict checks here which made me feel so delusional as I kept refreshing an earlier patch but nothing changed lmao
      parseHeader();
while (hex.length > 0) {
  let z;

// Case 1: consecutive OPERATORS at top-level
let consumedAny = false;
while (level5.cond.OPERATORS.includes(hex.slice(0, 2))) {
  [hex, z] = $.consumeBytes(hex, 1);
  parsedCond.push(['OPERATOR', z]);
  consumedAny = true;
}

if (consumedAny) {
  continue; // only skip to next iteration if we actually consumed operators
}

// go to next iteration of top-level parsing loop


  /*  // Case 1: starts with EoCI
  if ($.startsWith(hex, level5.cond.EOCI)) {
    [hex, z] = $.consumeBytes(hex, 1);
    parsedCond.push(['EOCI', z]);
    continue; // B.
  }*/

  // Case 2: Expect READ_MEMORY, READ_LITERAL, or OPERATOR at top level
  if (
    !$.startsWith(hex, level5.cond.READ_MEMORY) &&
    !$.startsWith(hex, level5.cond.READ_LITERAL) &&
    !level5.cond.OPERATORS.includes(hex.slice(0, 2))
  ) {
    err('Expected READ_MEMORY, READ_LITERAL, or OPERATOR at top-level but found', hex.slice(0, 8));
  }


  // Parse clause
  parseClause();

  console.log(hex)
  console.warn("bruh")
// Case 1: consecutive OPERATORS at top-level
consumedAny = false;
while (level5.cond.OPERATORS.includes(hex.slice(0, 2))) {
  let c;
  [hex, c] = $.consumeBytes(hex, 1);
  parsedCond.push(['OPERATOR', c]);
  consumedAny = true;
}

if (consumedAny) {
  continue; // only skip to next iteration if we actually consumed operators
}

  /* Case 1: starts with AOECI
  if ($.startsWith(hex, level5.cond.AEOCI)) {
    [hex, z] = $.consumeBytes(hex, 1);
    parsedCond.push(['AEOCI', z]);
    continue; // B.
  }*/
  // Case 4: End or trailing bytes
  if (hex.length === 0) break;
  if (!$.startsWith(hex, level5.cond.READ_MEMORY) && !$.startsWith(hex, level5.cond.READ_LITERAL)) {
    err('Trailing/Unexpected bytes after clause(s)', hex.slice(0, 8));
  }
}
console.log("parsed cond", parsedCond);
      return parsedCond;
    };
 
    function labelForCompVal(hexBytes){ // d.
      console.log("wowaaa", hexSpaced(hexBytes.toUpperCase().replace(/\s+/g,'')))
      console.log("wowwaaee", hexBytes)
      let temp = [level5.cond.settings.showPow, level5.cond.settings.showLim]
      level5.cond.settings.showPow = false;
      level5.cond.settings.showLim = false;
      let out = level5.cond._internals.numberQOL(Number("0x" + hexBytes.toUpperCase().replace(/\s+/g,''))); // now uses the new util
      level5.cond.settings.showPow = temp[0];
      level5.cond.settings.showLim = temp[1];
      return out;
    }
    // ---- render helpers ----
    function labelForResource(hexBytes){ // hexBytes are expected to be formatted as 'AABBCCDD' or 'AA BB CC DD'
      const spaced = hexSpaced(hexBytes.toUpperCase().replace(/\s+/g,''));
      return level5.cond._manual[spaced] ?? knownResourceIDs[spaced];
    }

    function labelForOperator(opByte) {
      const ops = Object.fromEntries(level5.cond.OPERATORS.map((op, i) => [op, level5.cond.OPERATOR_LABELS[i]]));
      return ops[opByte.toUpperCase()] || null;
    }

  function labelForCType(ctypeBytes) {
    const ctypes = level5.cond.CTYPES;
    const spaced = hexSpaced(ctypeBytes.toUpperCase().replace(/\s+/g, '')); // normalise input
    return ctypes[spaced] || null;
  }

  labelForHeader = (val) => `0x${Number("0x" + String(val).replace(/\s+/g, "")).toString(16).toUpperCase()} Cond${Number("0x" + String(val).replace(/\s+/g, "")) == '0' ? " (Normal)" : "This exists??"}`; 

function highlightPseudo(code) {
  if (!code) return '';

  // Escape HTML first so symbols aren't interpreted
  const esc = s => s
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;');

  code = esc(code);

  return code.replace(
    /\b(0x[0-9A-Fa-f]+|\d+|true|false|null)\b|([A-Za-z_]\w*)(?=\s*\()|\b(if|else|for|while|switch|case|break|continue|return|success|fail)\b|\/\/[^\n]*|"(?:\\.|[^"\\])*"/g,
    match => {
      // Booleans
      if (/^(true|false)$/.test(match))
        return `<span class="${match}">${match}</span>`; // cmon thats a creative way to do it!

      // Numbers (e.g., 0xFF, 42)
      if (/^0x/i.test(match) || /^\d+$/.test(match) || /^null$/.test(match))
        return `<span class="accent2">${match}</span>`;

      //  Keywords; must be propritised over function identifiers for situations like "if ()"
      if (/^(if|else|for|while|switch|case|break|continue|return|success|fail)$/.test(match))
        return `<span class="danger">${match}</span>`;

      // Functions (identifier followed by '(')
      if (/^[A-Za-z_]\w*$/.test(match))
        return `<span class="funcaccent">${match}</span>`;

      // Strings
      if (/^"/.test(match))
        return `<span class="label">${match}</span>`;

      // Comments
      if (/^\/\//.test(match))
        return `<span class="muted">${match}</span>`;

      return match;
    }
  );
}

function renderParsed(parsed, EXPECTED_COND_LENGTH = null) {
  const tree = document.getElementById('tree');
  tree.innerHTML = '';
  const pseudo = document.getElementById('pseudo');
  pseudo.textContent = '';

  let seenHeader = false; // avoid duplicating header printing

  parsed.forEach(node => {
    const type = node[0];

    if (type === 'HEADER_BLOCK') {
      const wrap = document.createElement('div');
      wrap.className = 'node';
      wrap.innerHTML = '<strong>HEADER</strong> <span class="small muted">(header + condcode)</span>';

      const inner = document.createElement('div');
      inner.className = 'small muted';
      node[1].forEach(x => {
        console.log("aeyeyya", x)
        inner.innerHTML += '<div>' + x[0] + ': <span class="label">' + 
  (x[0] === 'HEADER' 
    ? hexSpaced(x[1]) //hexSpaced(x[1]) + '<span class="small muted"> — ' + labelForHeader(hexSpaced(x[1])) + '</span>'  h.dis; header txt disabled for now due to recent properties figured out
    : hexSpaced(x[1])) + 
  '</span></div>';

      });
      wrap.appendChild(inner);
      tree.appendChild(wrap);

      if (!seenHeader) seenHeader = true;
    }

    // --- CONDITION (unchanged for tree) ---
    else if (type === 'CONDITION') {
      const clause = node[1];
      const wrap = document.createElement('div');
      wrap.className = 'node';
      wrap.innerHTML = '<strong>CONDITION</strong>';

      const inner = document.createElement('div');
      inner.className = 'small muted';
      clause.forEach(f => {
        const name = f[0];
        const val = f[1];
        let lbl = null;
        if (name.startsWith('RESOURCE_ID')) lbl = labelForResource(val);
        else if (name.startsWith('LITERAL_VALUE')) lbl = labelForCompVal(val);
        else if (name.startsWith('CTYPE')) lbl = labelForCType(val);
        else if (name === 'OPERATOR') lbl = labelForOperator(val);

        inner.innerHTML +=
          '<div><strong>' + name + '</strong>: <span class="label">' +
          hexSpaced(val) + '</span>' +
          (lbl ? (' <span class="small muted"> — ' + lbl + '</span>') : '') +
          '</div>';
      });

      wrap.appendChild(inner);
      tree.appendChild(wrap);
    }

    else if (type === 'OPERATOR') { // 68.
      const val = node[1];
      const lbl = labelForOperator(val); // quick QOL/bug fix: label the top-level ops (how did I even miss this....)
    
      const wrap = document.createElement('div');
      wrap.className = 'node';
      wrap.innerHTML =
        `<strong>${type}</strong>: ` +
        `<span class="label">${hexSpaced(val)}</span>` +
        (lbl ? ` <span class="small muted"> — ${lbl}</span>` : '');

      tree.appendChild(wrap);
    } else {
      // Other node types: show in tree only
      const wrap = document.createElement('div');
      wrap.className = 'node small muted';
      wrap.textContent = type + ' (ignored in pseudo)';
      tree.appendChild(wrap);
    }
  });

  // Psuedo-C generation for RS but also to validate header values
  try {
    const generatedPseudo = level5.cond.condToC(parsed, EXPECTED_COND_LENGTH);
    pseudo.innerHTML = level5.cond.settings.shouldHighlightPsuedo ? highlightPseudo(generatedPseudo) : generatedPseudo;
  } catch (err) {
    console.error('condToC failed:', err);
    pseudo.textContent += '/* condToC parse error */\n';
  }
}

// restored and edited
// basic attempt at cond -> C which is (hopefully!) correctly rewritten by the time this copy is released
level5.cond.condToC = function(parsedArray, EXPECTED_COND_LENGTH = null) {
   function parseAsLiteralIfPossible(flat, cursor) {
    if (cursor >= flat.length) return null;
    const tk = String(flat[cursor][0] || '').toUpperCase();
    const tv = flat[cursor][1];

    // READ_HASH + RESOURCE -> literal hex
    if (tk === 'READ_HASH' || tk === '34') {
      const next = flat[cursor + 1];
      if (next && String(next[0] || '').toUpperCase().includes('RESOURCE')) {
        const id = norm(next[1] || '');
        if (/^[0-9A-F]{8,}$/.test(id)) {
          return { node: { type: 'LITERAL', val: `0x${id}` }, nextIndex: cursor + 2 };
        }
      }
    }

    // RESOURCE token directly -> literal hex
    if (tk.includes('RESOURCE')) {
      const id = norm(tv || '');
      if (/^[0-9A-F]{8,}$/.test(id)) {
        return { node: { type: 'LITERAL', val: `0x${id}` }, nextIndex: cursor + 1 };
      }
    }

    // READ_LITERAL + LITERAL_VALUE -> literal true/false/number
    if (tk === 'READ_LITERAL' || tk === '32') {
      const next = flat[cursor + 1];
      if (next) {
        const nk = String(next[0] || '').toUpperCase();
        if (nk.includes('LIT')) {
          const hex = norm(next[1] || '0');
          const num = parseInt(hex || '0', 16);
          const val = level5.cond._internals.numberQOL(num)
          return { node: { type: 'LITERAL', val }, nextIndex: cursor + 2 };
        }
      }
      // fallback numeric literal from raw
      const hex = norm(tv || '0');
      if (/^[0-9A-F]+$/.test(hex)) {
        const num = parseInt(hex || '0', 16);
        return { node: { type: 'LITERAL', val: String(num) }, nextIndex: cursor + 1 };
      }
    }

    // LITERAL_VALUE alone
    if (tk.includes('LIT')) {
      const hex = norm(tv || '0');
      const num = parseInt(hex || '0', 16);
      const val = level5.cond._internals.numberQOL(num)
      return { node: { type: 'LITERAL', val }, nextIndex: cursor + 1 };
    }

    // couldn't produce a literal
    return null;
  }

  $("base_warn").innerHTML = '';

  const norm = s => String(s || '').replace(/\s+/g, '').toUpperCase();

  const opMap = Object.fromEntries(
    level5.cond.OPERATORS.map((op, i) => [op, level5.cond.OPERATOR_LABELS[i]])
  );

  const OP_OPERAND_COUNT = level5.cond.OP_OPERAND_COUNT;

  const comparisonOps = new Set(['<','<=','>','>=','==','!=']);

  /* ---------------------------------------------------------------------------------------------------- *
   * Step 0: the initial parsing of headers (very shrimple; some later parsing happens near the end tho)
   * --------------------------------------------------------------------------------------------------- */

  const outLines = [];
  let COND_LENGTH_VAL = null;
  let STACK_PRM_VAL = null;

  outLines.push(`// parsed with yw-cond version: v${level5.cond.ver}`);


  for (const blk of parsedArray) {
    if (String(blk[0]).toUpperCase() !== 'HEADER_BLOCK') continue;
    for (const it of blk[1] || []) {
      const key = String(it[0]).toUpperCase();
      const val = it[1];
      if (key === 'COND_LENGTH') COND_LENGTH_VAL = Number("0x" + val);
      if (key === 'STACK_PRM') STACK_PRM_VAL = Number("0x" + val);
      outLines.push(`// ${it[0]}: ${it[1]}`);
      if (it[0] === 'STACK_PRM') outLines.push('');
    }
  }

  /* ------------------------------------------------------------
   * STEP 1: FLATTEN EVERYTHING (FIX #1)
   * ------------------------------------------------------------ */

  const flat = [];
  for (const blk of parsedArray) {
    const key = String(blk[0]).toUpperCase();
    if (key === 'HEADER_BLOCK') continue;
    if (key === 'CONDITION') flat.push(...(blk[1] || []));
    else flat.push(blk);
  }

  if (EXPECTED_COND_LENGTH != null && COND_LENGTH_VAL != null) {
    const expected = EXPECTED_COND_LENGTH.toUpperCase();
    const actual = COND_LENGTH_VAL
      .toString(16)
      .padStart(2, '0')
      .toUpperCase();
    
    if (expected !== actual) {
      $("base_warn").innerHTML +=
        `<br/>Expected COND_LENGTH ${expected} does not match COND_LENGTH ${actual}.`;
    }
  }

  /* ------------------------------------------------------------------------------------------------------------------------------
   * Step 2: lex tokens into a value or op (I totally didnt search on google if lex was a gramatically correct noun on it's own)
   * (just the same old parseValue logic)
   * ---------------------------------------------------------------------------------------------------------------------------- */

  let READ_MEMORY_COUNT = 0;
  let OPERATOR_COUNT = 0;
  let LITERAL_VALUE_NON_PARAM_COUNT = 0;
  let _parsingFunctionParams = false;

  const tokens = [];

  function mapOperator(hexOrSymbol) {
    if (!hexOrSymbol) return '??';
    const s = String(hexOrSymbol);
    if (/^[\!\=\&\|\+\-\*\/<>%\^~?:]+$/.test(s)) return s;
    return opMap[norm(s)] || s;
  }

   // parseValue consumes tokens starting at i; returns { node, nextIndex }
  function parseValue(flat, i) {
    const key = String(flat[i][0] || '').toUpperCase();
    const raw = flat[i][1];

    // READ_LITERAL then a LITERAL_VALUE
    if (key === 'READ_LITERAL' || key === '32') {
      const next = flat[i + 1];
      if (next) {
        const nk = String(next[0] || '').toUpperCase();
        if (nk.includes('LIT')) {
          const hex = norm(next[1] || '0');
          const num = parseInt(hex || '0', 16);
          const val = level5.cond._internals.numberQOL(num);
          if(!_parsingFunctionParams) LITERAL_VALUE_NON_PARAM_COUNT++;
          return { node: { type: 'LITERAL', val }, nextIndex: i + 2 };
        }
      }
      const hex = norm(raw || '0');
      const num = parseInt(hex || '0', 16);
      const val = level5.cond._internals.numberQOL(num); // missed a semicolon here for a WHILE :0 good thing ASI exists lol
      if(!_parsingFunctionParams) LITERAL_VALUE_NON_PARAM_COUNT++;
      return { node: { type: 'LITERAL', val }, nextIndex: i + 1 };
    }

    // direct LITERAL_VALUE
    if (key.includes('LIT')) {
      const hex = norm(raw || '0');
      const num = parseInt(hex || '0', 16);
      const val = level5.cond._internals.numberQOL(num); // here too!?
      if(!_parsingFunctionParams) LITERAL_VALUE_NON_PARAM_COUNT++;
      return { node: { type: 'LITERAL', val }, nextIndex: i + 1 };
    }

    // READ_HASH: by default may be a nested FUNCTION(resource), but caller can request literal parsing
    if (key === 'READ_HASH' || key === '34') {
      const next = flat[i + 1];
      if (next && String(next[0] || '').toUpperCase().includes('RESOURCE')) {
        const id = norm(next[1] || '');
        if (/^[0-9A-F]{8,}$/.test(id)) return { node: { type: 'FUNCTION', id, params: [] }, nextIndex: i + 2 };
      }
      if(!_parsingFunctionParams) LITERAL_VALUE_NON_PARAM_COUNT++;
      return { node: { type: 'LITERAL', val: 'SUBSECTION_UNKNOWN' }, nextIndex: i + 1 };
    }

    // READ_MEMORY: function detection/handling; this was the BIGGEST PAIN EVER TO IMPLEMENTBDFGUIJADFILHFDS\UD\FSIH;IDSFOUOUDSFHUPSDFOUHDSFBSFUAUSDHIADFHOIHFDS
    if (key === 'READ_MEMORY' || key === '35') {
      READ_MEMORY_COUNT++;
      // locate resource and ctype nearby
      let ridIdx = -1, ctypeIdx = -1;
      for (let j = i + 1; j <= i + 6 && j < flat.length; j++) {
        const kj = String(flat[j][0] || '').toUpperCase();
        if (ridIdx === -1 && kj.includes('RESOURCE')) ridIdx = j;
        if (ctypeIdx === -1 && kj.includes('CTYPE')) ctypeIdx = j;
      }

      if (ridIdx !== -1) {
        const resourceId = norm(flat[ridIdx][1] || '');
        const ctypeRaw = ctypeIdx !== -1 ? norm(flat[ctypeIdx][1] || '') : null;

        // If ctype exists and is NOT a function -> resource as literal hex
        if (ctypeRaw && !level5.cond.isFunction(ctypeRaw)) {
          const lit = { type: 'LITERAL', val: `0x${resourceId}` };
          const nextIndex = Math.max(ridIdx, ctypeIdx) + 1;
          if(!_parsingFunctionParams) LITERAL_VALUE_NON_PARAM_COUNT++;
          return { node: lit, nextIndex };
        }

        // Otherwise its..... you guessed it! a function
        let paramCount = 0;
        if (ctypeRaw) {
          const lastByte = ctypeRaw.slice(-2) || '00';
          paramCount = Number('0x' + lastByte) || 0;
        }
        const funcNode = { type: 'FUNCTION', id: resourceId, params: new Array(paramCount).fill(null) };
        let cursor = Math.max(ridIdx, ctypeIdx !== -1 ? ctypeIdx : ridIdx) + 1;

        _parsingFunctionParams = true;
        for (let p = 0; p < paramCount; p++) {
          if (cursor >= flat.length) break;

          // detect explicit CTYPE token for this param
          let localCtype = null;
          if (String(flat[cursor][0] || '').toUpperCase().includes('CTYPE')) {
            localCtype = norm(flat[cursor][1] || '');
            cursor++;
          }

          // handle EXTENSION_DELIM if present
          if (cursor < flat.length && (String(flat[cursor][0] || '').toUpperCase() === 'EXTENSION_DELIM' || String(flat[cursor][1]) === '28')) {
            cursor++;
            if (cursor < flat.length && String(flat[cursor][0] || '').toUpperCase().includes('CTYPE')) {
              localCtype = norm(flat[cursor][1] || '');
              cursor++;
            }
          }

          // IMPORTANT: if localCtype indicates non-function, parse next tokens as LITERAL if possible
          if (localCtype && !level5.cond.isFunction(localCtype)) {
            if (cursor < flat.length) {
              const litRes = parseAsLiteralIfPossible(flat, cursor);
              if (litRes) {
                funcNode.params[p] = litRes.node;
                cursor = litRes.nextIndex;
                continue;
              }
              // fallback to parseValue if special-case didn't match
              const res = parseValue(flat, cursor);
              funcNode.params[p] = res.node;
              cursor = res.nextIndex;
              continue;
            } else {
              funcNode.params[p] = { type: 'LITERAL', val: '/*?*/' };
              break;
            }
          } else {
            // localCtype indicates a function (or absent) -> parse normally (may produce FUNCTION node)
            if (cursor < flat.length) {
              const res = parseValue(flat, cursor);
              funcNode.params[p] = res.node;
              cursor = res.nextIndex;
              continue;
            } else {
              funcNode.params[p] = { type: 'LITERAL', val: '/*?*/' };
              break;
            }
          }
        }
        _parsingFunctionParams = false;
        return { node: funcNode, nextIndex: cursor };
      }

      // fallback: next token may be raw hex id
      const nextToken = flat[i + 1];
      const att = nextToken ? norm(nextToken[1] || '') : '';
      if (/^[0-9A-F]{8,}$/.test(att)) return { node: { type: 'FUNCTION', id: att, params: [] }, nextIndex: i + 2 };
      return { node: { type: 'LITERAL', val: 'FUNC_UNKNOWN' }, nextIndex: i + 1 };
    }

    // RESOURCE token alone
    if (key.includes('RESOURCE')) {
      const id = norm(raw || '');
      if (/^[0-9A-F]{8,}$/.test(id)) return { node: { type: 'FUNCTION', id, params: [] }, nextIndex: i + 1 };
    }

    // fallback literal
    if (!_parsingFunctionParams) LITERAL_VALUE_NON_PARAM_COUNT++;
    return { node: { type: 'LITERAL', val: String(raw) }, nextIndex: i + 1 };
  } // end parseValue

  for (let i = 0; i < flat.length;) {
    const key = String(flat[i][0] || '').toUpperCase();
    const val = flat[i][1];

    // OPERATOR
    if (key === 'OPERATOR' || /^[0-9A-F]{2}$/.test(key)) {
      OPERATOR_COUNT++;
      tokens.push({
        type: 'OPERATOR',
        symbol: mapOperator(val ?? key)
      });
      i++;
      continue;
    }

    // VALUE
    const res = parseValue(flat, i);
    tokens.push({ type: 'VALUE', node: res.node });
    i = res.nextIndex;
  }

  /* --------------------------------------------------------------
   * STEP 3: Main RPN Evaluation (Where most of the stuff happens)
   * ------------------------------------------------------------ */

  const stack = [];

  for (const t of tokens) {
    if (t.type === 'VALUE') {
      stack.push(t.node);
      continue;
    }

    const op = t.symbol;
    const argc = OP_OPERAND_COUNT[op];

    if (argc == null) {
      $("base_warn").innerHTML += `<br/>Unknown operator ${op}`;
      continue;
    }

    const args = [];
    let missing = 0;
    
    for (let i = 0; i < argc; i++) {
      if (stack.length > 0) {
        args.unshift(stack.pop());
      } else {
        missing++;
      }
    }

    // pad missing operands on the left
    for (let i = 0; i < missing; i++) {
      args.unshift({ type: 'LITERAL', val: 'null' });
    }
    
    if (missing > 0) {
      $("base_warn").innerHTML +=
        `<br/>Operator operand mismatch: '${op}' expected ${argc} operand(s), ` +
        `but ${argc - missing} found. Padding with null.`;
    }

    stack.push({
      type: 'EXPR',
      op,
      args
    });
  }

  if (stack.length !== 1) {
    $("base_warn").innerHTML += `<br/>Invalid RPN: stack ended with ${stack.length} values`;
  }


  function isTrueLiteral(node) { // basic helper because like master oogway didn't say... I cant think of anything to put here
    if (!node || node.type !== 'LITERAL') return false;
    
    if (level5.cond.settings.showBool) {
      return node.val === 'true';
    }
    return node.val === '1';
  }

  function simplify(node) {
    if (!node || node.type !== 'EXPR') return node;
    
    node.args = node.args.map(simplify);
    if (node.op === '&&') {
      const [a, b] = node.args;

      if (isTrueLiteral(a)) return b; // helper function call to account for level5.cond.settings.showBool
      if (isTrueLiteral(b)) return a;
    }


    return node;
  }

  /* ---------------------------------------------------------------------
   * step 3.5: simplify stack if enabled. (Hopefully not extremely buggy)
   * ------------------------------------------------------------------ */

  let root = stack[0] || { type: 'LITERAL', val: 'null' };

  if (level5.cond.settings.simplifyCompilerArtifiacts) {
    root = simplify(root);
  }


  /* ---------------------------------------------------------------
   * step 4: render the AST into the actual C
   * ------------------------------------------------------------ */

  function render(node) {
    if (!node) return '/*null*/';
    if (node.type === 'LITERAL') return node.val; // if it's a literal value then just return it
    if (node.type === 'FUNCTION') {
      const args = node.params.map(render).join(', ');
      const spacedId = node.id.match(/../g)?.join(' ') ?? node.id;
      
      const mapped =
        level5.cond.CExpressionInternalMappings?.[spacedId];
      
      if (mapped) {
        return `${mapped}(${args})`;
      }
      
      return `FUNC_${node.id}(${args})`;
    }

    if (node.type === 'EXPR') {
      if (node.args.length === 1) { // unary
        return `(${node.op}${render(node.args[0])})`;
      }
      if (node.args.length === 2) { // binary
        return `(${render(node.args[0])} ${node.op} ${render(node.args[1])})`; // brackets for implicit
      }
    }
    return '/*?*/';
  }

  const expr = render(root);

  /* -------------------------------------------------------------------------------------------
   * step 5: output the finalised control flow and dump debug data if debug mode is activated
   * ---------------------------------------------------------------------------------------- */

  outLines.push(`if (${expr}) {`);
  outLines.push(`    success();`);
  outLines.push(`}`);
  outLines.push(`fail();`);

  if (level5.cond.settings.debugMode) {
    outLines.unshift('// --- DEBUG DUMP ---');
    outLines.unshift('// Tokens: ' + JSON.stringify(tokens));
    outLines.unshift('// AST: ' + JSON.stringify(root, null, 2));
    outLines.unshift('// ------------------');
  }

  /* --------------------------------
   * step 6: validate header data
   * ----------------------------- */

  let EXPECTED_STACK_PRM =
    (((READ_MEMORY_COUNT + LITERAL_VALUE_NON_PARAM_COUNT) * 2) + OPERATOR_COUNT)
      .toString(16).padStart(2, '0').toUpperCase();

  if (STACK_PRM_VAL != null) {
    const actual = STACK_PRM_VAL.toString(16).padStart(2, '0').toUpperCase();
    if (EXPECTED_STACK_PRM !== actual) {
      $("base_warn").innerHTML += `<br/>Expected STACK_PRM ${EXPECTED_STACK_PRM} but got ${actual}`;
    }
  }

  /* ------------------------------------------------------------
   * final step (7): just the final formatting stuff
   * --------------------------------------------------------- */

     function formatIfBlocksSafe(code) {
    let result = '';
    let i = 0;
    let temp = level5.cond.settings.shortenIfBlocks; // just in the EXTREMELY off case that somehow it gets changed mid execution
    while (i < code.length && temp) {
      // Look for 'if(' or 'if (' 
      if (code.startsWith('if', i) && /\bif\b/.test(code.slice(i, i + 3))) {
        let j = i + 2;

        // Skip whitespace
        while (j < code.length && /\s/.test(code[j])) j++;

        if (code[j] === '(') {
          let depth = 1;
          let startCond = ++j;
          let endCond = -1;

          // find matching closing parenthesis
          while (j < code.length && depth > 0) {
            if (code[j] === '(') depth++;
            else if (code[j] === ')') depth--;
            j++;
          }

          if (depth === 0) {
            endCond = j - 1;
            const condition = code.slice(startCond, endCond);
            let formatted = condition;

            // Apply formatting only if condition is long enough
            if (condition.length >= 65) {
              formatted = condition
                .replace(/(\&\&)/g, '$1\n  ')
                .replace(/(\|\|)/g, '$1\n  ');
            }

            // reconstruct
            result += `if (${formatted})`;
            i = endCond + 1;
            continue;
          }
        }
      }

      // default copy
      result += code[i];
      i++;
    }

    return temp ? result : code;
  }

  const normalized = outLines.map(l => l.replace(/\r?\n/g, '') + '\n').join('');
  return formatIfBlocksSafe(normalized).replace(/[ \t]+$/gm, '') + '\n';
};


    level5.cond._internals.hexToBase64 = function(hexString) {
      // Remove all spaces
      const cleanHex = hexString.replace(/\s+/g, '');

      // Validate that it has an even length
      if (cleanHex.length % 2 !== 0) {
        throw new Error("Invalid hex string length");
      }

      // Convert hex to bytes
      const bytes = [];
      for (let i = 0; i < cleanHex.length; i += 2) {
        bytes.push(parseInt(cleanHex.substr(i, 2), 16));
      }

      // Convert bytes to Base64
      const base64String = btoa(String.fromCharCode(...bytes));
      return base64String;
    }


    level5.cond.samples = [
                      '00 00 00 00 0f 05 35 10 b1 40 96 00 01 00 32 00 00 00 01 78', /* main story completed yw2 simple format */
                      '00 00 00 00 18 05 35 2a 3d 45 43 00 0a 01 28 00 06 02 34 00 12 34 56 32 00 00 00 01 78', /* has flag 0x00123456 yw3; basic extended format */
                      '00 00 00 00 12 02 35 69 84 E3 AF 00 0A 01 28 00 06 02 34 96 49 FF 74', /* rare terminatorless and comparison valueless cond */
                      '00 00 00 00 1B 02 35 18 2B 37 5A 00 13 02 28 00 06 02 34 22 61 B7 8A 28 00 06 02 32 00 00 00 01', /* rare terminatorless cond */
                      '00 00 00 00 12 02 35 69 84 E3 AF 00 0A 01 28 00 06 02 34 0E 6B 6F 6B', /* redesign suggesting with resource ID :0 */
                      '00 00 00 00 36 05 35 74 03 A9 CE 00 1C 03 28 00 06 02 34 C1 B2 DA B7 28 00 06 02 34 8E 31 15 F3 28 00 06 02 32 00 00 0E F6 35 69 84 E3 AF 00 0A 01 28 00 06 02 34 42 6F A0 C3 8F', /* 3 resource IDs in the first condition */
                      '00 00 00 00 36 05 35 74 03 A9 CE 00 1C 03 28 00 06 02 34 C1 B2 DA B7 28 00 06 02 34 8E 31 15 F3 28 00 06 02 32 00 00 0E D8 35 69 84 E3 AF 00 0A 01 28 00 06 02 34 94 DE BD 45 8F', /* proper NEST EOCI handling in terminatorless conditions - aka just a random edge case test */
                      '00 00 00 00 48 08 35 74 03 A9 CE 00 1C 03 28 00 06 02 34 0C 24 46 3A 28 00 06 02 34 91 8A 8A 79 28 00 06 02 32 00 00 1A 9A 35 12 09 61 26 00 0A 01 28 00 06 02 32 00 00 1A A4 8F 35 69 84 E3 AF 00 0A 01 28 00 06 02 34 97 14 49 81 8F', /* chaotic best of a cond that has several edge cases for V3 parsing */
                      '00 00 00 00 18 05 35 8D 76 66 D8 00 0A 01 28 00 06 02 34 E5 96 D9 98 32 00 00 00 01 78', /* yw2 jetnayn appearcond (has bell) */
                      '00 00 00 00 09 02 35 7E E8 60 18 00 01 00', /* an extremely simple BATTLE_AI_ACT_CONDITION from yw2 */
                      'AAAAACcONd4X/hgAAQAyAAAD6HE1xlSO4wABADWF476vAAEAXTIAAAAecY8=', /* SV Snaggerjag Psychic Blasters Requirement Cond YW2 */
                      'AAAAAPA7NXe0Y+UACgEoAAYCMgAAAAEyAAAAAXg1d7Rj5QAKASgABgIyAAAAAjIAAAABeI81d7Rj5QAKASgABgIyAAAAAzIAAAABeI81d7Rj5QAKASgABgIyAAAABDIAAAABeI81d7Rj5QAKASgABgIyAAAABTIAAAABeI81d7Rj5QAKASgABgIyAAAABjIAAAABeI81d7Rj5QAKASgABgIyAAAABzIAAAABeI81d7Rj5QAKASgABgIyAAAACDIAAAABeI81d7Rj5QAKASgABgIyAAAACTIAAAABeI81d7Rj5QAKASgABgIyAAAACjIAAAABeI8=', /* hinozalls yw2 psychic blasters cond, demonstrates function calls emulating array access */
                      'AAAAAD8XMgAAAAE12ONpHwABADIAAAABeI8yAAAAAY8yAAAAATWemYSMAAoBKAAGAjQxBWKvMgAAAAJ4jzIAAAABj5A=', /* a yw3 exclusion config cond - you can tell just from the HORRIBLE stack that its from yw3 :<<< */
                      'AAAAADkONd4X/hgAAQAyAAAH0HE1npmEjAAKASgABgI0KzMh6jWemYSMAAoBKAAGAjRW3zFYXTIAAAAecY8=', /* good example of stack merging */
                      'AAAAAAIBcQ==', /* bruh */
                      'AAAAAAcDMgAAAAF4', /* bruh (but a little less) */
                      'AAAAADALNb4EpZgACgEoAAYCNFpFOBwyAAAA/3g1Kj1FQwAKASgABgI0lHk1KzIAAAABeI8=', /* mapo tofu requirement yw2 */
                      'AAAAADwXNWI5O+gAAQAyAAAAA3g1Yjk76AABADIAAAAEeJA1Yjk76AABADIAAAAFeJA1WpnI/wABADIAAAAAeI8=', /* yw2 t131d01 (Rice Paddy Path) oneplace OP_SOUND_POINT_6; checks time and weather*/
                      'AAAAAJYvMgAAAAE1uRk22gABADIAAHU6cY81npmEjAAKASgABgI0A7iP/TIAAAAHeI81npmEjAAKASgABgI03PHmiDIAAAADcY8yAAAAAY8yAAAAATW5GTbaAAEAMgAAdTpxjzWemYSMAAoBKAAGAjQDuI/9MgAAAAh4jzWemYSMAAoBKAAGAjTc8eaIMgAAAANxjzIAAAABj5A=', /* _ (Oneplace) MINIMAP_POINT 6 */
                      'AAAAAXd3MgAAAAE1uRk22gABADIAAHU6cY81npmEjAAKASgABgI0A7iP/TIAAAAJeI81npmEjAAKASgABgI03PHmiDIAAAADcY8yAAAAAY8yAAAAATW5GTbaAAEAMgAAdTpxjzWemYSMAAoBKAAGAjSasd5HMgAAADV4jzWemYSMAAoBKAAGAjRF+LcyMgAAAANxjzIAAAABj5AyAAAAATW5GTbaAAEAMgAAdTpxjzWemYSMAAoBKAAGAjSasd5HMgAAADZ4jzWemYSMAAoBKAAGAjRF+LcyMgAAAANxjzIAAAABj5AyAAAAATW5GTbaAAEAMgAAdTpxjzWemYSMAAoBKAAGAjSasd5HMgAAADd4jzWemYSMAAoBKAAGAjRF+LcyMgAAAANxjzIAAAABj5AyAAAAATW5GTbaAAEAMgAAdTpxjzWemYSMAAoBKAAGAjSasd5HMgAAADh4jzWemYSMAAoBKAAGAjRF+LcyMgAAAANxjzIAAAABj5A=',  /* _ (Oneplace) MINIMAP_POINT 7; I dont even know what to think of this........ */
                      'AAAAADYRMgAAJ0I1uRk22gABAG81uRk22gABADIAACdMb481MhR6kAAKASgABgI05rLGNzIAAAABeY8=', /* uptown springdale (yw2) oneplace OP_ICON_POINT_1 (#2) */
                      'AAAAAEUXNb4EpZgACgEoAAYCNO0IHLMyAAAAAng1Yjk76AABADIAAAADeDViOTvoAAEAMgAAAAR4kDViOTvoAAEAMgAAAAV4kI8=', /* complicated nested && || handling test */
                      'AAAAADALNYaphdYACgEoAAYCMgAAAAEyAAAAAHA1hqmF1gAKASgABgIyAAAAAjIAAAAAcJA=', /* yw2 btl AI cond */
                      'AAAAABgFNUJ5JVAACgEoAAYCMgAAAAoyAAAAAHg=', /* yw2 btl ai cond which uses a func added in 2 */
                      'AAAAAEgXMgAAAAE1JzJtRwAKASgABgI0qOd4DDIAAAABeI8yAAAAAY8yAAAAATUqPUVDAAoBKAAGAjRpzHJVMgAAAAF4jzIAAAABj5A=', /* yw2 rudy contacts/friends app cond */
                      'AAAAAGwjMgAAAAE1vgSlmAAKASgABgI0E6sA9TIAAAD/eI8yAAAAAY8yAAAAATW+BKWYAAoBKAAGAjSNz5VWMgAAAP94jzIAAAABj5AyAAAAATW+BKWYAAoBKAAGAjTj05SBMgAAAP94jzIAAAABj5A=', /* same but for mr barton */
                      'AAAAAA8FNZ5vnyEAAQAyAAAAAXE=', /* same but for det. holdit */
                      'AAAAABgFNewt/OYACgEoAAYCNMIlk98yAAAAAXg=', /* lucy */
                      'AAAAAF0jMgAAAAE1uRk22gABADIAAYagcY81Ju95yAABADIAAAACeY8yAAAAAY8yAAAAATXsLfzmAAoBKAAGAjRKy92MMgAAAAF4jzUm73nIAAEAMgAAAAJ4jzIAAAABj5A=', /* same but for nate's grandma */
                      'AAAAAF0jMgAAAAEyAAAnVjW5GTbaAAEAb481uRk22gABADIAACdqb48yAAAAAY8yAAAAATW5GTbaAAEAMgABEaJ4jzUqPUVDAAoBKAAGAjSSINwnMgAAAAF5jzIAAAABj5A=', /* uptown springdale oneplace */
                      'AAAAAEgXMgAAAAE1Kj1FQwAKASgABgI0RKDKdjIAAAABeI8yAAAAAY8yAAAAATUqPUVDAAoBKAAGAjTFwl4FMgAAAAF4jzIAAAABj5A=' /* data/res/gym > gym_config_*.cfg.bin > GYM_BOSS_SINGLE_INFO_22 */
                    ];


    // ---- love my UI schenanamimigans ----

    function log(msg, kind){ const l = el('log'); const pfx = kind==='error'?'Error: ': kind==='warn'?'Warning: ': ''; l.textContent = pfx + msg; }

    function doParseFromInput(text){ if((text?.trim() ?? text) == '0') {doParseFromInput(); /* clear/flush the UI */ log("Warning: 0 is not a valid CExpression. If this appears in place of a cond, the check will always succeed."); return;}; try{ const hex = inputToHexString(text); if(!hex) {  el('input').value=''; el('tree').innerHTML=''; el('pseudo').textContent=''; el('log').textContent='Ready.'; el('base_warn').innerHTML = ''; return; }; let EXPECTED_COND_LENGTH = ((hex.replace(/\s+/g, "").length / 2) - 5).toString(16).toUpperCase().padStart(2, '0'); const parsed = level5.cond.parsev3Cond(hex); renderParsed(parsed, EXPECTED_COND_LENGTH); log('Parsed OK.'); } catch(e){ log(e.message, 'error'); console.error(e); } }


    el('parseBtn').addEventListener('click', ()=> doParseFromInput(el('input').value));
    el('parseB64Btn').addEventListener('click', () => {  // large util update
      try { 
        let raw = el('input').value.trim(); 

        // If input looks like hex (spaces or only hex digits), convert to Base64
        if(/\s/.test(raw) || /^[0-9A-Fa-f]+$/.test(raw)) {
          const b64 = level5.cond._internals.hexToBase64(raw);
          el('input').value = b64; // update input with Base64
          log('Converted hex → Base64: ' + b64, 'info');
          doParseFromInput(b64)
          return; // stahp it
        }

        // Otherwise, decode Base64 to hex for parsing
        const dec = tryDecodeBase64(raw); 
        const hex = Array.from(dec, c => 
          (typeof c === 'string' ? c.charCodeAt(0) : c).toString(16).padStart(2,'0')
        ).join('').toUpperCase(); 

        el('input').value = hexSpaced(hex); 
        doParseFromInput(hex); 

      } catch(e) { 
        log('Base64 decode failed: ' + e.message, 'error'); 
      } 
    });


  let sampleIndex = 0;
  let direction = 1; // 1 = forward, -1 = backward

  el('sampleBtn').addEventListener('click', () => {
    const samples = level5.cond.samples;
    if (!samples || samples.length === 0) return;

    // Set the input to the current sample
    el('input').value = samples[sampleIndex];
    el('parseBtn').click();

    // Move index
    sampleIndex += direction;

    // If we hit the end, reverse direction
    if (sampleIndex >= samples.length) {
      sampleIndex = samples.length - 2;
      direction = -1;
    }
    // If we hit the start, reverse direction again
    else if (sampleIndex < 0) {
      sampleIndex = 1;
      direction = 1;
    }
  });
    
   // removed to save UI space and in favour of Parse auto clearing if the input is empty : el('clearBtn').addEventListener('click', ()=>{ el('input').value=''; el('tree').innerHTML=''; el('pseudo').textContent=''; el('log').textContent='Ready.'; });

    el('copyPseudoBtn').addEventListener('click', ()=>{ const txt = el('pseudo').textContent; if(!txt){ log('Nothing to copy','warn'); return;} navigator.clipboard?.writeText(txt).then(()=> log('Pseudocode copied to clipboard'), ()=> log('Copy failed','warn')); });

  //  el('downloadBtn').addEventListener('click', ()=>{ const pseudo = el('pseudo').textContent || ''; const blob = new Blob([pseudo], { type: 'text/plain' }); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = 'cond.txt'; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url); });

    // light mode toggle; .......disgusting........ :<
    el('lightMode').addEventListener('change', (ev)=>{ document.body.classList.toggle('light', ev.target.checked); });

// ===== Merge Cond Modal =====
let $ = el; // because I can't be consistent for too long :p
const mergeModal = $('mergeModal');
const mergeBtn = $('mergeBtn');
const mergeDoBtn = $('mergeDoBtn');
const mergeCancelBtn = $('mergeCancelBtn');
const mergeInputB = $('mergeInputB');

mergeBtn.addEventListener('click', () => mergeModal.showModal());
mergeCancelBtn.addEventListener('click', () => mergeModal.close());

// Normalizes hex/base64 -> upper-case continuous hex
function normalizeCondInput(raw) {
    const t = raw.trim();
    if (!t) return "";

    // Try clean hex
    const hexCandidate = t.replace(/0x/gi,"").replace(/[^A-Fa-f0-9]/g,"");
    if (hexCandidate.length % 2 === 0 && /^[A-Fa-f0-9]+$/.test(hexCandidate)) {
        return hexCandidate.toUpperCase();
    }

    // Try base64
    try {
        const b = tryDecodeBase64(t);
        return Array.from(b, c => c.charCodeAt(0).toString(16).padStart(2,"0")).join("").toUpperCase();
    } catch {}

    // Last fallback: space separated hex
    const cleaned = t.replace(/0x/gi,'').replace(/[^A-Fa-f0-9]/g,' ').trim();
    return cleaned.split(/\s+/).map(v => v.padStart(2,'0')).join('').toUpperCase();
}

// Performs the actual merge logic
function mergeConds(hexA, hexB, mode = "AND") {
    if (hexA.length < 12 || hexB.length < 12) {
        throw new Error("Both conds must be at least 6 bytes.");
    }

    const a = hexA.match(/.{2}/g);
    const b = hexB.match(/.{2}/g);

    // length uint16 (bytes [3] & [4])
    let lenA = (parseInt(a[3],16) << 8) | parseInt(a[4],16);
    let lenB = (parseInt(b[3],16) << 8) | parseInt(b[4],16);
    let mergedLen = lenA + lenB;

    if (mode === "NAND") mergedLen++; // increase by 1 if NAND mode to account for the extra ! (logical negation op) that will be added later
    mergedLen = Math.min(mergedLen, 0xFFFF); // clamp to 2 bytes

    a[3] = ((mergedLen >> 8) & 0xFF).toString(16).toUpperCase().padStart(2,"0"); // edit byteA
    a[4] = (mergedLen & 0xFF).toString(16).toUpperCase().padStart(2,"0"); // edit byteB

    // --- 6th byte (weird stack byte thingy lol) ---
    let byte6_A = parseInt(a[5], 16);
    let byte6_B = parseInt(b[5], 16);

    // +1 to account for the combination op, 0x8F for AND, 0x90 for OR etc
    let merged6 = byte6_A + byte6_B + 1;

    // if NAND, add an EXTRA 1 to account for the extra ! op (logical negation)
    if (mode === "NAND") merged6++;

    merged6 = Math.min(merged6, 0xFF); // handle 0xFF edge case just in case (dont know what would/should even happen ina  similar case to this byte but even conds like a page long aren't long enough to have a stack byte > 0xFF)
    a[5] = merged6.toString(16).toUpperCase().padStart(2,"0");

    // --- Mode -> operator byte ---
    let opByte = "8F"; // AND default (&&)

    if (mode === "OR")   opByte = "90"; // || all line up :p
    if (mode === "XNOR") opByte = "78"; // ==
    // NAND uses the same operator but with a logical negation added

    // --- Tail from B --- (I do love me some symmetrical comments; oh wait I just broke i-)
    const bTail = b.slice(6);

    let result = a.join("");

    if (bTail.length > 0) {
        result += bTail.join("") + opByte;
    }

    // NAND special rule: append 0x51 (!) aka  logical negation op
    if (mode === "NAND") {
        result += "51"; // !
    }

    return result;
}

mergeDoBtn.addEventListener('click', () => {
    try {
        const mode = $('mergeMode').value;

        // Cond A comes from main input
        const A = inputToHexString(el('input').value);

        // Cond B from modal
        const B = inputToHexString(mergeInputB.value);

        if (!A || !B) throw new SyntaxError("You need 2 conds to merge them :/ (the 1st should be the cond) required.");

        const merged = mergeConds(A, B, mode);

        el('input').value = merged;
        el('parseB64Btn').click(); el('parseB64Btn').click(); // this (and you guessed it) clicks the button twice to 1. format it properly 2. parse it
 
        mergeModal.close();
    } catch (e) {
        alert("Merge failed:\n" + e.message);
    }
});


  </script>
</body>
</html>
